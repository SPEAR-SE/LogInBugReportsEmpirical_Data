{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "fields": {
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "aggregatetimeestimate": null,
        "aggregatetimeoriginalestimate": null,
        "aggregatetimespent": null,
        "assignee": null,
        "components": [{
            "description": "Core storm daemons and APIs including trident",
            "id": "12327950",
            "name": "storm-core",
            "self": "https://issues.apache.org/jira/rest/api/2/component/12327950"
        }],
        "created": "2013-12-15T05:56:47.000+0000",
        "creator": {
            "active": true,
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xumingming&avatarId=18354",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xumingming&avatarId=18354",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xumingming&avatarId=18354",
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xumingming&avatarId=18354"
            },
            "displayName": "James Xu",
            "key": "xumingming",
            "name": "xumingming",
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=xumingming",
            "timeZone": "Asia/Shanghai"
        },
        "customfield_10010": null,
        "customfield_12310220": "2014-06-13T07:09:33.461+0000",
        "customfield_12310222": null,
        "customfield_12310250": null,
        "customfield_12310290": null,
        "customfield_12310291": null,
        "customfield_12310300": null,
        "customfield_12310310": "0.0",
        "customfield_12310420": "363834",
        "customfield_12310920": "364140",
        "customfield_12310921": null,
        "customfield_12311020": null,
        "customfield_12311120": null,
        "customfield_12311820": "0|i1qpqf:",
        "customfield_12312022": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "customfield_12312026": null,
        "customfield_12312220": null,
        "customfield_12312320": null,
        "customfield_12312321": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312324": null,
        "customfield_12312325": null,
        "customfield_12312326": null,
        "customfield_12312327": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312330": null,
        "customfield_12312331": null,
        "customfield_12312332": null,
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12312335": null,
        "customfield_12312336": null,
        "customfield_12312337": null,
        "customfield_12312338": null,
        "customfield_12312339": null,
        "customfield_12312340": null,
        "customfield_12312341": null,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Feb 11 17:50:38 UTC 2015",
        "customfield_12312720": null,
        "customfield_12312823": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "customfield_12312923": null,
        "customfield_12313422": "false",
        "customfield_12313520": null,
        "description": "https://github.com/nathanmarz/storm/issues/711\n\nHi,\n\nI'm working with Trident and basically what i am trying to do is a windowed join across batches using partitionPersist and stateQuery on two different stream that come from TWO DIFFERENT SPOUTS.\n\nBoth the spouts implement the IBatchSpout interface.\n\nThe error i get is a NPE on StateQueryProcessor or on PartitionPersistProcessor depending on which one of the two spouts starts early.\n\nI try to debug this and what i have understand is that Trident use the same BatchID(txid) for the two different spouts and this take to a wrong initialization of state in the core processing nodes.\n\nIf i use the same throughput for the two spout and i make one spout starts with a delay the problem doesn't occur (we don't have an overlap between the BachID(txid) of the different spouts).\n\n----------\nliesrock: Sorry for the delay.\nI send to you the source code.\n\nhttps://dl.dropboxusercontent.com/u/49470846/TridentBug.tar.gz\n\nIn this example i am using two spout:\n1) the first one starts emitting tuples at a certain rate.\n2) the second one is delayed by 5 seconds and emits at an higher rate than the first one.\n\nI print on the sterr some debug info, the most important is the Batch ID (txid).\nI print on the stdout info about the state window.\n\nYou can see that this is exactly the case that i was explain in my first message.\n\nThank you for your attention, i can't figure out on this, so i left Trident and i start working with Storm(i didn't have problem in implementing this on Storm).\n\nLet me know what is your opinion about it.\n\nLuca Muratore\n\n----------\nxumingming: @liesrock try to minimize your test case so it can reproduce the issue but contains the least source files(preferably only one source file), the least lines of source code --- that makes us more easier to see whether the issue is in your app code or in storm core.\n\n----------\nliesrock: As you requested, in the following link you can find the test case in one source file and with the minimum lines of code:\n\nhttps://dl.dropboxusercontent.com/u/49470846/SimpleTridentBug.zip\n\nThanks for your patience.\n\n----------\nxumingming: paste the case source code here to make it easier for others to follow:\n\npackage storm.starter.trident;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport storm.trident.Stream;\nimport storm.trident.TridentState;\nimport storm.trident.TridentTopology;\nimport storm.trident.operation.TridentCollector;\nimport storm.trident.spout.IBatchSpout;\nimport storm.trident.state.BaseQueryFunction;\nimport storm.trident.state.BaseStateUpdater;\nimport storm.trident.state.State;\nimport storm.trident.state.StateFactory;\nimport storm.trident.tuple.TridentTuple;\nimport backtype.storm.Config;\nimport backtype.storm.LocalCluster;\nimport backtype.storm.task.IMetricsContext;\nimport backtype.storm.task.TopologyContext;\nimport backtype.storm.tuple.Fields;\nimport backtype.storm.tuple.Values;\n\n\npublic class BugTest {\n\n    //Spout that simulates an ATM\n    @SuppressWarnings(\"serial\")\n    public static class ATMSpout implements IBatchSpout {   \n        private int batchSize;\n        private int initialSleepMilliTime;\n        private int rate;\n        private String name;\n        private List<String> currentCCIDList;\n        private long withdrawalID = 0;\n        private final static String[] LOCATIONS = { \"Madrid\", \"Barcelona\", \"Siviglia\", \"Granada\", \"Toledo\", \"Ibiza\", \"Valladolid\", \"Valencia\" };\n\n\n        public ATMSpout(int batchSize, int initialSleepMilliTime, int rate, String name) throws IOException {\n            this.batchSize = batchSize;\n            this.initialSleepMilliTime = initialSleepMilliTime;\n            this.rate = rate;\n            this.name = name;\n        }\n\n        //generate a list of \"size\" CCID\n        private List<String> generateCCID(int size){\n            //check the input parameter\n            if(size < 0){\n                System.err.println(\"Negative CCID list size\");\n                return null;\n            }\n            //initialize some variables\n            List<String> aux = new ArrayList<String>();\n            Integer randDigit = 0;\n            String currentCCID = \"\";\n            //create a random CCID\n            for(int i = 0; i < size; i++){\n                for(int j = 0; j < 16; j++){\n                    randDigit = (int)(Math.random() * 10);\n                    currentCCID +=  randDigit;\n                }\n                aux.add(currentCCID);\n                currentCCID = \"\";\n            }\n            return aux;\n        }\n\n\n        @SuppressWarnings(\"rawtypes\")\n        @Override\n        public void open(Map conf, TopologyContext context) {\n            System.err.println(\"Open Spout instance\");\n            this.currentCCIDList = generateCCID(10000);\n            //initial delay\n            try {\n                Thread.sleep(initialSleepMilliTime);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        @Override\n        public void emitBatch(long batchId, TridentCollector collector) {\n            System.err.println(name + \" ---> Starting emitting Batch number : \" + batchId);\n            for(int i = 0; i < batchSize; i++) {\n                try {\n                    Thread.sleep(rate);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                collector.emit(getNextWithdrawal());\n            }\n        }\n\n        @Override\n        public void ack(long batchId) {\n        }\n\n        @Override\n        public void close() {\n        }\n\n        @SuppressWarnings(\"rawtypes\")\n        @Override\n        public Map getComponentConfiguration() {\n            return new Config();\n        }\n\n        @Override\n        public Fields getOutputFields() {\n            return new Fields(\"withdrawalID\", \"ccID\", \"location\", \"amount\", \"timestamp\");\n        }\n\n        private Values getNextWithdrawal(){\n            int randIndexCCID = (int) ((Math.random()) * this.currentCCIDList.size());\n            int randAmmount = (int) ((Math.random()) * 1000);\n            int randIndexLocation = (int) ((Math.random()) * LOCATIONS.length);\n            return new Values(++withdrawalID, \n                              this.currentCCIDList.get(randIndexCCID), \n                              LOCATIONS[randIndexLocation],\n                              randAmmount,\n                              System.currentTimeMillis());\n        }\n\n    }\n\n\n    //state updater\n    @SuppressWarnings(\"serial\")\n    private static class Updater extends BaseStateUpdater<DB>  {\n        private String streamName;\n\n        public Updater(String streamName) {\n            this.streamName = streamName;\n        }\n\n        @Override\n        public void updateState(DB state, List<TridentTuple> tuples, TridentCollector collector) {\n            System.err.println(streamName + \" Update State\");\n            }\n    }\n\n    //query\n    @SuppressWarnings(\"serial\")\n    public static class Query extends BaseQueryFunction<DB, TridentTuple> {\n        private String streamName;\n\n        public Query(String streamName) {\n            this.streamName = streamName;\n        }\n\n        @Override\n        public List<TridentTuple> batchRetrieve(DB state, List<TridentTuple> inputs) {\n            System.err.println(streamName + \" Query\");\n\n            List<TridentTuple> retList = new ArrayList<TridentTuple>(); //return list\n            for(int i = 0; i < 5; i++){\n                retList.add(null);\n            }\n            return retList;\n        }\n\n        @Override\n        public void execute(TridentTuple tuple, TridentTuple result, TridentCollector collector) {\n\n        }\n\n    }\n\n    //state\n    public static class DB implements State {\n\n        @Override\n        public void beginCommit(Long txid) {\n\n        }\n\n        @Override\n        public void commit(Long txid) {\n\n        }\n\n    }\n\n    //factory\n    @SuppressWarnings(\"serial\")\n    public static class Factory implements StateFactory {\n\n        @SuppressWarnings(\"rawtypes\")\n        @Override\n        public State makeState(Map conf, IMetricsContext metrics, int partitionIndex, int numPartitions) {\n            return new DB();\n        }       \n    }\n\n    public static void main(String[] args) throws Exception {\n        Config conf = new Config();\n        LocalCluster cluster = new LocalCluster();\n\n        final int BATCH_SIZE = 5;\n        final int DELAY_1 = 100;\n        final int RATE_1 = 300;\n        final int DELAY_2 = 5000;\n        final int RATE_2 = 100;\n\n        ATMSpout spout1 = new ATMSpout(BATCH_SIZE, DELAY_1, RATE_1, \"SpoutLowRate\");\n        ATMSpout spout2 = new ATMSpout(BATCH_SIZE, DELAY_2, RATE_2, \"SpoutHighRate\");   \n        TridentTopology topology = new TridentTopology();\n\n        Stream s1 = topology.newStream(\"stream1\", spout1);\n        Stream s2 = topology.newStream(\"stream2\", spout2);\n\n        TridentState leftState = s1.partitionPersist(new Factory(), \n                                                     s1.getOutputFields(),\n                                                     new Updater(\"left\"));\n        s2.stateQuery(leftState,\n                      s1.getOutputFields(),\n                      new Query(\"right\"),\n                      new Fields(\"out\"));\n\n        cluster.submitTopology(\"BugTest\", conf, topology.build());\n\n        Thread.sleep(20000);\n\n        cluster.shutdown();\n    }\n}\n\n----------\nxumingming: stacktrace:\n\n5320 [Thread-27-b-0] ERROR backtype.storm.util - Async loop died!\njava.lang.RuntimeException: java.lang.NullPointerException\n    at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:90) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.utils.DisruptorQueue.consumeBatchWhenAvailable(DisruptorQueue.java:61) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.disruptor$consume_batch_when_available.invoke(disruptor.clj:62) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.daemon.executor$fn__3496$fn__3508$fn__3555.invoke(executor.clj:730) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.util$async_loop$fn__442.invoke(util.clj:403) ~[storm-core-0.9.0-rc3.jar:na]\n    at clojure.lang.AFn.run(AFn.java:24) [clojure-1.4.0.jar:na]\n    at java.lang.Thread.run(Thread.java:680) [na:1.6.0_29]\nCaused by: java.lang.NullPointerException: null\n    at storm.trident.planner.processor.StateQueryProcessor.execute(StateQueryProcessor.java:69) ~[storm-core-0.9.0-rc3.jar:na]\n    at storm.trident.planner.SubtopologyBolt$InitialReceiver.receive(SubtopologyBolt.java:194) ~[storm-core-0.9.0-rc3.jar:na]\n    at storm.trident.planner.SubtopologyBolt.execute(SubtopologyBolt.java:130) ~[storm-core-0.9.0-rc3.jar:na]\n    at storm.trident.topology.TridentBoltExecutor.execute(TridentBoltExecutor.java:355) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.daemon.executor$fn__3496$tuple_action_fn__3498.invoke(executor.clj:615) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.daemon.executor$mk_task_receiver$fn__3419.invoke(executor.clj:383) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.disruptor$clojure_handler$reify__2960.onEvent(disruptor.clj:43) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:87) ~[storm-core-0.9.0-rc3.jar:na]\n    ... 6 common frames omitted\n5320 [Thread-27-b-0] ERROR backtype.storm.daemon.executor -\njava.lang.RuntimeException: java.lang.NullPointerException\n    at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:90) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.utils.DisruptorQueue.consumeBatchWhenAvailable(DisruptorQueue.java:61) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.disruptor$consume_batch_when_available.invoke(disruptor.clj:62) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.daemon.executor$fn__3496$fn__3508$fn__3555.invoke(executor.clj:730) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.util$async_loop$fn__442.invoke(util.clj:403) ~[storm-core-0.9.0-rc3.jar:na]\n    at clojure.lang.AFn.run(AFn.java:24) [clojure-1.4.0.jar:na]\n    at java.lang.Thread.run(Thread.java:680) [na:1.6.0_29]\nCaused by: java.lang.NullPointerException: null\n    at storm.trident.planner.processor.StateQueryProcessor.execute(StateQueryProcessor.java:69) ~[storm-core-0.9.0-rc3.jar:na]\n    at storm.trident.planner.SubtopologyBolt$InitialReceiver.receive(SubtopologyBolt.java:194) ~[storm-core-0.9.0-rc3.jar:na]\n    at storm.trident.planner.SubtopologyBolt.execute(SubtopologyBolt.java:130) ~[storm-core-0.9.0-rc3.jar:na]\n    at storm.trident.topology.TridentBoltExecutor.execute(TridentBoltExecutor.java:355) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.daemon.executor$fn__3496$tuple_action_fn__3498.invoke(executor.clj:615) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.daemon.executor$mk_task_receiver$fn__3419.invoke(executor.clj:383) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.disruptor$clojure_handler$reify__2960.onEvent(disruptor.clj:43) ~[storm-core-0.9.0-rc3.jar:na]\n    at backtype.storm.utils.DisruptorQueue.consumeBatchToCursor(DisruptorQueue.java:87) ~[storm-core-0.9.0-rc3.jar:na]\n    ... 6 common frames omitted\n5334 [Thread-27-b-0] INFO  backtype.storm.util - Halting process: (\"Worker died\")\n\nThe NullPointerException is thrown because state is null:\n\nhttps://github.com/nathanmarz/storm/blob/master/storm-core/src/jvm/storm/trident/planner/processor/StateQueryProcessor.java?source=cc#L57-L61\n\n    @Override\n    public void execute(ProcessorContext processorContext, String streamId, TridentTuple tuple) {\n        BatchState state = (BatchState) processorContext.state[_context.getStateIndex()];\n        state.tuples.add(tuple);\n        state.args.add(_projection.create(tuple));\n    }\nWhy state is null? state is initialized in startBatch method:\nhttps://github.com/nathanmarz/storm/blob/master/storm-core/src/jvm/storm/trident/planner/processor/StateQueryProcessor.java?source=cc#L52-L54\n\n    public void startBatch(ProcessorContext processorContext) {\n        processorContext.state[_context.getStateIndex()] =  new BatchState();\n    }\nIn this case, startBatch is not called before execute is called.\n\nWhy startBatch is not called? startBatch is called by initBatchState, initBatchState should be called by TridentBoltExecutor.execute:\n\n        if(tracked==null) {\n            tracked = new TrackedBatch(new BatchInfo(batchGroup, id, _bolt.initBatchState(batchGroup, id)), _coordConditions.get(batchGroup), id.getAttemptId());\n            _batches.put(id.getId(), tracked);\n        }\nIn the code above, initBatchState is called with a batchGroup arg, when there are multiple batchGroups in one batch, the TrackedBatch will only be created once, then the initBatchState will only be called for the first batchGroup, then startBatch method of processors in the rest batchGroups will not be called, then the NullPointerException, @nathanmarz, is this a bug or just not using Trident in the correct way?\n\n----------\nnathanmarz: Looks like a bug.",
        "duedate": null,
        "environment": null,
        "fixVersions": [],
        "issuelinks": [],
        "issuetype": {
            "avatarId": 21133,
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "id": "1",
            "name": "Bug",
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "subtask": false
        },
        "labels": [],
        "lastViewed": null,
        "priority": {
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "id": "4",
            "name": "Minor",
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4"
        },
        "progress": {
            "progress": 0,
            "total": 0
        },
        "project": {
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12314820&avatarId=21667",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12314820&avatarId=21667",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12314820&avatarId=21667",
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12314820&avatarId=21667"
            },
            "id": "12314820",
            "key": "STORM",
            "name": "Apache Storm",
            "projectCategory": {
                "description": "Apache Storm Related",
                "id": "13260",
                "name": "Storm",
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13260"
            },
            "self": "https://issues.apache.org/jira/rest/api/2/project/12314820"
        },
        "reporter": {
            "active": true,
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xumingming&avatarId=18354",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xumingming&avatarId=18354",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xumingming&avatarId=18354",
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xumingming&avatarId=18354"
            },
            "displayName": "James Xu",
            "key": "xumingming",
            "name": "xumingming",
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=xumingming",
            "timeZone": "Asia/Shanghai"
        },
        "resolution": null,
        "resolutiondate": null,
        "status": {
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "id": "1",
            "name": "Open",
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "statusCategory": {
                "colorName": "blue-gray",
                "id": 2,
                "key": "new",
                "name": "To Do",
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2"
            }
        },
        "subtasks": [],
        "summary": "[Trident] Bug when working with two spouts with stateful operator",
        "timeestimate": null,
        "timeoriginalestimate": null,
        "timespent": null,
        "updated": "2015-10-09T00:31:16.000+0000",
        "versions": [],
        "votes": {
            "hasVoted": false,
            "self": "https://issues.apache.org/jira/rest/api/2/issue/STORM-136/votes",
            "votes": 1
        },
        "watches": {
            "isWatching": false,
            "self": "https://issues.apache.org/jira/rest/api/2/issue/STORM-136/watchers",
            "watchCount": 3
        },
        "workratio": -1
    },
    "id": "12684762",
    "key": "STORM-136",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/12684762"
}