[System.nanoTime is not necessarily that cheap.  System.currentTimeMillis is reading from a place in shared memory, and incurs little if any overhead.  System.nanoTime on large multi core systems requires coordination between all of the CPUs to sync them and be sure that it can give that guarantee of a monotonically increasing value.  It is not necessarily that expensive but it is not that cheap either.  For me personally if we don't need sub-millisecond resolution I would prefer to see the code written so that it still uses currentTimeMillis but handles the case where now - _lastUpdateMs is negative and treats it as if time has expired instead of waiting. , I agree with you,@revans2.

I think we can change:

{code}
        long now = System.currentTimeMillis();
        if ((now - _lastUpdateMs) > _spoutConfig.stateUpdateIntervalMs)
{code}

on
 
{code}
        long diffWithNow = System.currentTimeMillis() - _lastUpdateMs;
        if (diffWithNow > _spoutConfig.stateUpdateIntervalMs || diffWithNow < 0) {
{code}, Sounds good the only change I would make is to add a comment explaining why diffWithNow can be `< 0` just in case someone else comes along sees it and decides to "FIX" some broken code., added pull request [https://github.com/apache/storm/pull/763], Github user 3Dragan commented on the pull request:

    https://github.com/apache/storm/pull/763#issuecomment-143292866
  
    Sure, my fault)
, Github user Parth-Brahmbhatt commented on the pull request:

    https://github.com/apache/storm/pull/763#issuecomment-143310184
  
    +1.
, Github user zhuoliu commented on the pull request:

    https://github.com/apache/storm/pull/763#issuecomment-143787228
  
    Looks good. I am +1.
, Github user revans2 commented on the pull request:

    https://github.com/apache/storm/pull/763#issuecomment-144071299
  
    Still +1
, Github user asfgit closed the pull request at:

    https://github.com/apache/storm/pull/763
, Thanks [~3dragan],

I merged this into master.  Keep up the good work.]