[This seems to indicate that a tick tuple was trying to publish to the receive queue of an executor, but could not because the queue was full.  While at the same time an executor, possibly a different one, was waiting for data to be available on its queue.  I'm not sure that there is any way to tie the two together, in fact if the two are for the same queue it probably means that you have found a bug in disruptor.  If this is reproducible, we should be able to get to the bottom of it, so long as you are OK with sharing stack traces, and possibly a heap dump of a worker experiencing this issue.  If this is something you are not going to be able to share it will be much more difficult to track down what is happening., Thanks [~revans2] to discuss this with me.

The root cause was a spout that blocks in the nextTuple method for a long time (hours) listening on a socket. Note that the spout doesn't emit anything in that time frame and therefore doesn't have any pending ack or fail to be called; topology doesn't use anchoring as well.

Apparently spout's receive queue is used by storm for metrics and system stream. Spout's thread (the one that also calls nextTuple) pulls these ticks out from that queue. The metrics and system stream are driven by a global timer thread, which gets blocked on trying to publish a new tuple to the spout's receive queue. The blocked global timer thread causes a complete halt of tick tuples to other bolt instances.
 
It will be good to document that a spout should NEVER sleep more than few seconds to keep the system running.]