{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13168631","self":"https://issues.apache.org/jira/rest/api/2/issue/13168631","key":"STORM-3124","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":5400,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12314820","id":"12314820","key":"STORM","name":"Apache Storm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12314820&avatarId=21667","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12314820&avatarId=21667","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12314820&avatarId=21667","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12314820&avatarId=21667"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/13260","id":"13260","description":"Apache Storm Related","name":"Storm"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12334657","id":"12334657","name":"2.0.0","archived":false,"released":false}],"aggregatetimespent":5400,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2018-06-28T20:31:51.625+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Thu Jun 28 20:31:51 UTC 2018","customfield_12312320":null,"customfield_12310222":"1_*:*_1_*:*_18513755_*|*_3_*:*_1_*:*_93316521_*|*_5_*:*_1_*:*_0","customfield_12310420":"9223372036854775807","customfield_12312321":null,"resolutiondate":"2018-06-28T20:31:51.607+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/STORM-3124/watchers","watchCount":1,"isWatching":false},"created":"2018-06-27T13:28:01.367+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/2","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/critical.svg","name":"Critical","id":"2"},"labels":["pull-request-available"],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":0,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12334657","id":"12334657","name":"2.0.0","archived":false,"released":false}],"customfield_12312339":null,"issuelinks":[],"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=agresch","name":"agresch","key":"agresch","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Aaron Gresch","active":true,"timeZone":"Etc/UTC"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2018-06-29T15:19:05.273+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[],"timeoriginalestimate":null,"description":"{code:java}\r\n2018-06-25 20:21:05.220 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 7 more attempts.\r\n2018-06-25 20:21:06.220 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:06.220 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 6 more attempts.\r\n2018-06-25 20:21:07.220 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:07.221 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 5 more attempts.\r\n2018-06-25 20:21:08.221 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:08.221 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 4 more attempts.\r\n2018-06-25 20:21:09.222 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:09.222 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 3 more attempts.\r\n2018-06-25 20:21:10.222 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:10.222 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 2 more attempts.\r\n2018-06-25 20:21:11.223 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:11.223 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 1 more attempts.\r\n2018-06-25 20:21:12.223 o.a.s.p.PacemakerClient timer [ERROR] error attempting to write to a channel Timed out waiting for channel ready..\r\n2018-06-25 20:21:12.223 o.a.s.p.PacemakerClient timer [ERROR] Not getting response or getting null response. Making 0 more attempts.\r\n2018-06-25 20:21:13.224 o.a.s.p.PacemakerClientPool timer [WARN] Failed to connect to the pacemaker server openqe74blue-n2.blue.ygrid.yahoo.com\r\n2018-06-25 20:21:13.229 o.a.s.d.n.Nimbus pool-37-thread-481 [INFO] uploadedJar /home/y/var/storm/nimbus/inbox/stormjar-c5893ba3-21c6-4397-84e2-54aab8e091a9.jar\r\n2018-06-25 20:21:13.225 o.a.s.d.n.Nimbus timer [ERROR] Error while processing event\r\njava.lang.RuntimeException: java.lang.RuntimeException: org.apache.storm.pacemaker.PacemakerConnectionException: Failed to connect to any Pacemaker.\r\n        at org.apache.storm.daemon.nimbus.Nimbus.lambda$launchServer$37(Nimbus.java:2773) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.StormTimer$1.run(StormTimer.java:110) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.StormTimer$StormTimerTask.run(StormTimer.java:226) [storm-client-2.0.0.y.jar:2.0.0.y]\r\nCaused by: java.lang.RuntimeException: org.apache.storm.pacemaker.PacemakerConnectionException: Failed to connect to any Pacemaker.\r\n        at org.apache.storm.cluster.PaceMakerStateStorage.get_worker_hb_children(PaceMakerStateStorage.java:214) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.StormClusterStateImpl.heartbeatStorms(StormClusterStateImpl.java:482) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.topoIdsToClean(Nimbus.java:897) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.doCleanup(Nimbus.java:2469) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.lambda$launchServer$37(Nimbus.java:2771) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        ... 2 more\r\nCaused by: org.apache.storm.pacemaker.PacemakerConnectionException: Failed to connect to any Pacemaker.\r\n        at org.apache.storm.pacemaker.PacemakerClientPool.sendAll(PacemakerClientPool.java:71) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.PaceMakerStateStorage.get_worker_hb_children(PaceMakerStateStorage.java:199) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.StormClusterStateImpl.heartbeatStorms(StormClusterStateImpl.java:482) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.topoIdsToClean(Nimbus.java:897) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.doCleanup(Nimbus.java:2469) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.lambda$launchServer$37(Nimbus.java:2771) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        ... 2 more\r\n2018-06-25 20:21:13.231 o.a.s.u.Utils timer [ERROR] Halting process: Error while processing event\r\njava.lang.RuntimeException: Halting process: Error while processing event\r\n        at org.apache.storm.utils.Utils.exitProcess(Utils.java:470) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.lambda$new$17(Nimbus.java:490) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.StormTimer$StormTimerTask.run(StormTimer.java:253) [storm-client-2.0.0.y.jar:2.0.0.y]\r\n2018-06-25 20:21:13.232 o.a.s.d.n.Nimbus Thread-12 [INFO] Shutting down master\r\n2018-06-25 20:21:13.232 o.a.s.u.Utils Thread-13 [INFO] Halting after 10 seconds\r\n\r\n\r\n2018-06-25 20:21:13.677 o.a.s.d.n.Nimbus pool-37-thread-481 [INFO] desired replication count 1 achieved, current-replication-count for conf key = 1, current-replication-count for code key = 1, current-replication-count for jar key = 1\r\n2018-06-25 20:21:13.678 o.a.s.d.n.Nimbus pool-37-thread-481 [WARN] Topology submission exception. (topology name='run')\r\njava.lang.IllegalStateException: instance must be started before calling this method\r\n        at org.apache.storm.shade.org.apache.curator.shaded.com.google.common.base.Preconditions.checkState(Preconditions.java:444) ~[shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.shade.org.apache.curator.framework.imps.CuratorFrameworkImpl.checkExists(CuratorFrameworkImpl.java:432) ~[shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.zookeeper.ClientZookeeper.existsNode(ClientZookeeper.java:144) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.zookeeper.ClientZookeeper.mkdirsImpl(ClientZookeeper.java:288) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.zookeeper.ClientZookeeper.mkdirs(ClientZookeeper.java:70) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.ZKStateStorage.mkdirs(ZKStateStorage.java:114) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.PaceMakerStateStorage.mkdirs(PaceMakerStateStorage.java:69) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.StormClusterStateImpl.setupHeatbeats(StormClusterStateImpl.java:435) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.submitTopologyWithOpts(Nimbus.java:3024) [storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.generated.Nimbus$Processor$submitTopologyWithOpts.getResult(Nimbus.java:3511) [storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.generated.Nimbus$Processor$submitTopologyWithOpts.getResult(Nimbus.java:3490) [storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.thrift.ProcessFunction.process(ProcessFunction.java:38) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.thrift.TBaseProcessor.process(TBaseProcessor.java:39) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.security.auth.sasl.SaslTransportPlugin$TUGIWrapProcessor.process(SaslTransportPlugin.java:147) [storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.thrift.server.TThreadPoolServer$WorkerProcess.run(TThreadPoolServer.java:291) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_131]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_131]\r\n        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]\r\n2018-06-25 20:21:13.680 o.a.s.t.ProcessFunction pool-37-thread-481 [ERROR] Internal error processing submitTopologyWithOpts\r\njava.lang.RuntimeException: java.lang.IllegalStateException: instance must be started before calling this method\r\n        at org.apache.storm.daemon.nimbus.Nimbus.submitTopologyWithOpts(Nimbus.java:3049) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.generated.Nimbus$Processor$submitTopologyWithOpts.getResult(Nimbus.java:3511) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.generated.Nimbus$Processor$submitTopologyWithOpts.getResult(Nimbus.java:3490) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.thrift.ProcessFunction.process(ProcessFunction.java:38) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.thrift.TBaseProcessor.process(TBaseProcessor.java:39) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.security.auth.sasl.SaslTransportPlugin$TUGIWrapProcessor.process(SaslTransportPlugin.java:147) [storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.thrift.server.TThreadPoolServer$WorkerProcess.run(TThreadPoolServer.java:291) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_131]\r\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_131]\r\n        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]\r\nCaused by: java.lang.IllegalStateException: instance must be started before calling this method\r\n        at org.apache.storm.shade.org.apache.curator.shaded.com.google.common.base.Preconditions.checkState(Preconditions.java:444) ~[shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.shade.org.apache.curator.framework.imps.CuratorFrameworkImpl.checkExists(CuratorFrameworkImpl.java:432) ~[shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.zookeeper.ClientZookeeper.existsNode(ClientZookeeper.java:144) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.zookeeper.ClientZookeeper.mkdirsImpl(ClientZookeeper.java:288) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.zookeeper.ClientZookeeper.mkdirs(ClientZookeeper.java:70) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.ZKStateStorage.mkdirs(ZKStateStorage.java:114) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.PaceMakerStateStorage.mkdirs(PaceMakerStateStorage.java:69) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.cluster.StormClusterStateImpl.setupHeatbeats(StormClusterStateImpl.java:435) ~[storm-client-2.0.0.y.jar:2.0.0.y]\r\n        at org.apache.storm.daemon.nimbus.Nimbus.submitTopologyWithOpts(Nimbus.java:3024) ~[storm-server-2.0.0.y.jar:2.0.0.y]\r\n        ... 9 more\r\n\r\n{code}\r\nWe're having sporadic failures talking to Pacemaker.  This callstack shows us unable to launch topologies.","customfield_10010":null,"timetracking":{"remainingEstimate":"0h","timeSpent":"1.5h","remainingEstimateSeconds":0,"timeSpentSeconds":5400},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"attachment":[],"customfield_12312340":null,"aggregatetimeestimate":0,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"Failures talking to Pacemaker","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=agresch","name":"agresch","key":"agresch","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Aaron Gresch","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=agresch","name":"agresch","key":"agresch","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Aaron Gresch","active":true,"timeZone":"Etc/UTC"},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":5400,"total":5400,"percent":100},"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":5400,"total":5400,"percent":100},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/comment/16525451","id":"16525451","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=agresch","name":"agresch","key":"agresch","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Aaron Gresch","active":true,"timeZone":"Etc/UTC"},"body":"I found by overriding lots of methods that after KerberosSaslClientHandler was registered for one of the pacemaker servers, it was immediately deregistered:\r\n{code:java}\r\nat org.apache.storm.messaging.netty.KerberosSaslClientHandler.channelUnregistered(KerberosSaslClientHandler.java:170) [storm-client-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.invokeChannelUnregistered(AbstractChannelHandlerContext.java:181) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.invokeChannelUnregistered(AbstractChannelHandlerContext.java:167) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.fireChannelUnregistered(AbstractChannelHandlerContext.java:160) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.ChannelInboundHandlerAdapter.channelUnregistered(ChannelInboundHandlerAdapter.java:53) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.invokeChannelUnregistered(AbstractChannelHandlerContext.java:181) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.invokeChannelUnregistered(AbstractChannelHandlerContext.java:167) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.fireChannelUnregistered(AbstractChannelHandlerContext.java:160) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.DefaultChannelPipeline$HeadContext.channelUnregistered(DefaultChannelPipeline.java:1412) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.invokeChannelUnregistered(AbstractChannelHandlerContext.java:181) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannelHandlerContext.invokeChannelUnregistered(AbstractChannelHandlerContext.java:167) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.DefaultChannelPipeline.fireChannelUnregistered(DefaultChannelPipeline.java:865) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:844) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:465) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n{code}\r\nAdding some logging in Netty, it was a connection refused:\r\n\r\n \r\n{code:java}\r\njava.net.ConnectException: Connection refused\r\n\r\n        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[?:1.8.0_131]\r\n\r\n        at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717) ~[?:1.8.0_131]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:325) ~[shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:341) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:635) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:582) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:499) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:461) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at org.apache.storm.shade.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884) [shaded-deps-2.0.0.y.jar:2.0.0.y]\r\n\r\n        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_131]\r\n{code}\r\nI could not find any built in logging or easily understandable way to determine this is happening.  It looks like we have code to reconnect to the pacemaker server when catching an exception, but none is being passed back to us visibly in this case.  Adding a reconnect call after giving up on the number of attempts appears to fix the issue.  Will do further testing.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=agresch","name":"agresch","key":"agresch","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Aaron Gresch","active":true,"timeZone":"Etc/UTC"},"created":"2018-06-27T18:44:57.939+0000","updated":"2018-06-27T18:44:57.939+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/comment/16526754","id":"16526754","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=revans2","name":"revans2","key":"revans2","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Robert Joseph Evans","active":true,"timeZone":"America/Chicago"},"body":"Thanks [~agresch],\r\n\r\n \r\n\r\nI merged this into master.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=revans2","name":"revans2","key":"revans2","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Robert Joseph Evans","active":true,"timeZone":"America/Chicago"},"created":"2018-06-28T20:31:51.625+0000","updated":"2018-06-28T20:31:51.625+0000"}],"maxResults":2,"total":2,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/STORM-3124/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":9,"worklogs":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/116589","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"GitHub user agresch opened a pull request:\n\n    https://github.com/apache/storm/pull/2741\n\n    STORM-3124 reconnect to pacemaker on failure\n\n    \n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/agresch/storm agresch_pacemaker_connect\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/storm/pull/2741.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #2741\n    \n----\ncommit 8cd3aa25fd8463a161b684e2674b653aa344efbe\nAuthor: Aaron Gresch <agresch@...>\nDate:   2018-06-27T19:57:28Z\n\n    STORM-3124 reconnect to pacemaker on failure\n\n----\n","created":"2018-06-27T20:24:24.002+0000","updated":"2018-06-27T20:24:24.002+0000","started":"2018-06-27T20:24:24.002+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"116589","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/116598","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user revans2 commented on a diff in the pull request:\n\n    https://github.com/apache/storm/pull/2741#discussion_r198638417\n  \n    --- Diff: storm-client/src/jvm/org/apache/storm/messaging/netty/KerberosSaslClientHandler.java ---\n    @@ -96,53 +96,69 @@ private void handleControlMessage(ChannelHandlerContext ctx, ControlMessage cont\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n             if (controlMessage == ControlMessage.SASL_COMPLETE_REQUEST) {\n    -                LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n    +            LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n     \n    -                if (!saslNettyClient.isComplete()) {\n    +            if (!saslNettyClient.isComplete()) {\n                     String errorMessage =\n                         \"Server returned a Sasl-complete message, but as far as we can tell, we are not authenticated yet.\";\n                     LOG.error(errorMessage);\n                     throw new Exception(errorMessage);\n    -                }\n    +            }\n                 ctx.pipeline().remove(this);\n                 this.client.channelReady(channel);\n     \n                 // We call fireChannelRead since the client is allowed to\n    -                // perform this request. The client's request will now proceed\n    -                // to the next pipeline component namely StormClientHandler.\n    +            // perform this request. The client's request will now proceed\n    +            // to the next pipeline component namely StormClientHandler.\n                 ctx.fireChannelRead(controlMessage);\n    -            } else {\n    +        } else {\n                 LOG.warn(\"Unexpected control message: {}\", controlMessage);\n    -            }\n    +        }\n         }\n     \n         private void handleSaslMessageToken(ChannelHandlerContext ctx, SaslMessageToken saslMessageToken) throws Exception {\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n    -            LOG.debug(\"Responding to server's token of length: {}\",\n    -            saslMessageToken.getSaslToken().length);\n    -\n    -            // Generate SASL response (but we only actually send the response if\n    -            // it's non-null.\n    -            byte[] responseToServer = saslNettyClient\n    -            .saslResponse(saslMessageToken);\n    -            if (responseToServer == null) {\n    -                // If we generate a null response, then authentication has completed\n    -                // (if not, warn), and return without sending a response back to the\n    -                // server.\n    -                LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    -                if (!saslNettyClient.isComplete()) {\n    -                    LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    -                    throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    -                }\n    -            this.client.channelReady(channel);\n    -            } else {\n    -                LOG.debug(\"Response to server token has length: {}\",\n    -                          responseToServer.length);\n    -            // Construct a message containing the SASL response and send it to the\n    +        LOG.debug(\"Responding to server's token of length: {}\", saslMessageToken.getSaslToken().length);\n    +\n    +        // Generate SASL response (but we only actually send the response if\n    +        // it's non-null.\n    +        byte[] responseToServer = saslNettyClient.saslResponse(saslMessageToken);\n    +        if (responseToServer == null) {\n    +            // If we generate a null response, then authentication has completed\n    +            // (if not, warn), and return without sending a response back to the\n                 // server.\n    +            LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    +            if (!saslNettyClient.isComplete()) {\n    +                LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    +                throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    +            }\n    +            this.client.channelReady(channel);\n    +        } else {\n    +            LOG.debug(\"Response to server token has length: {}\",\n    +                      responseToServer.length);\n    +            // Construct a message containing the SASL response and send it to the server.\n                 SaslMessageToken saslResponse = new SaslMessageToken(responseToServer);\n                 channel.writeAndFlush(saslResponse, channel.voidPromise());\n             }\n         }\n    +\n    +    @Override\n    +    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    +        super.channelRegistered(ctx);\n    +        LOG.info(\"channelRegistered {}\", ctx);\n    +    }\n    --- End diff --\n    \n    These look like they are for debugging.  could we make them debug logs instead?\n","created":"2018-06-27T20:59:12.505+0000","updated":"2018-06-27T20:59:12.505+0000","started":"2018-06-27T20:59:12.504+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"116598","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/116599","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user revans2 commented on a diff in the pull request:\n\n    https://github.com/apache/storm/pull/2741#discussion_r198638777\n  \n    --- Diff: storm-client/src/jvm/org/apache/storm/pacemaker/PacemakerClient.java ---\n    @@ -153,13 +154,13 @@ public String secretKey() {\n         }\n     \n         public HBMessage send(HBMessage m) throws PacemakerConnectionException, InterruptedException {\n    -        LOG.debug(\"Sending message: {}\", m.toString());\n    +        LOG.debug(\"Sending pacemaker message to {}: {}\", host, m.toString());\n    --- End diff --\n    \n    nit: can we drop the `.toString()` for m? The log command should do it for you, if it is needed.\n","created":"2018-06-27T20:59:12.542+0000","updated":"2018-06-27T20:59:12.542+0000","started":"2018-06-27T20:59:12.542+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"116599","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/116610","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user agresch commented on the issue:\n\n    https://github.com/apache/storm/pull/2741\n  \n    @revans2 - made the changes you wanted.\n","created":"2018-06-27T21:19:34.612+0000","updated":"2018-06-27T21:19:34.612+0000","started":"2018-06-27T21:19:34.612+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"116610","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/116829","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user danny0405 commented on a diff in the pull request:\n\n    https://github.com/apache/storm/pull/2741#discussion_r198736753\n  \n    --- Diff: storm-client/src/jvm/org/apache/storm/messaging/netty/KerberosSaslClientHandler.java ---\n    @@ -96,53 +96,69 @@ private void handleControlMessage(ChannelHandlerContext ctx, ControlMessage cont\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n             if (controlMessage == ControlMessage.SASL_COMPLETE_REQUEST) {\n    -                LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n    +            LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n     \n    -                if (!saslNettyClient.isComplete()) {\n    +            if (!saslNettyClient.isComplete()) {\n                     String errorMessage =\n                         \"Server returned a Sasl-complete message, but as far as we can tell, we are not authenticated yet.\";\n                     LOG.error(errorMessage);\n                     throw new Exception(errorMessage);\n    -                }\n    +            }\n                 ctx.pipeline().remove(this);\n                 this.client.channelReady(channel);\n     \n                 // We call fireChannelRead since the client is allowed to\n    -                // perform this request. The client's request will now proceed\n    -                // to the next pipeline component namely StormClientHandler.\n    +            // perform this request. The client's request will now proceed\n    +            // to the next pipeline component namely StormClientHandler.\n                 ctx.fireChannelRead(controlMessage);\n    -            } else {\n    +        } else {\n                 LOG.warn(\"Unexpected control message: {}\", controlMessage);\n    -            }\n    +        }\n         }\n     \n         private void handleSaslMessageToken(ChannelHandlerContext ctx, SaslMessageToken saslMessageToken) throws Exception {\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n    -            LOG.debug(\"Responding to server's token of length: {}\",\n    -            saslMessageToken.getSaslToken().length);\n    -\n    -            // Generate SASL response (but we only actually send the response if\n    -            // it's non-null.\n    -            byte[] responseToServer = saslNettyClient\n    -            .saslResponse(saslMessageToken);\n    -            if (responseToServer == null) {\n    -                // If we generate a null response, then authentication has completed\n    -                // (if not, warn), and return without sending a response back to the\n    -                // server.\n    -                LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    -                if (!saslNettyClient.isComplete()) {\n    -                    LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    -                    throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    -                }\n    -            this.client.channelReady(channel);\n    -            } else {\n    -                LOG.debug(\"Response to server token has length: {}\",\n    -                          responseToServer.length);\n    -            // Construct a message containing the SASL response and send it to the\n    +        LOG.debug(\"Responding to server's token of length: {}\", saslMessageToken.getSaslToken().length);\n    +\n    +        // Generate SASL response (but we only actually send the response if\n    +        // it's non-null.\n    +        byte[] responseToServer = saslNettyClient.saslResponse(saslMessageToken);\n    +        if (responseToServer == null) {\n    +            // If we generate a null response, then authentication has completed\n    +            // (if not, warn), and return without sending a response back to the\n                 // server.\n    +            LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    +            if (!saslNettyClient.isComplete()) {\n    +                LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    +                throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    +            }\n    +            this.client.channelReady(channel);\n    +        } else {\n    +            LOG.debug(\"Response to server token has length: {}\",\n    +                      responseToServer.length);\n    +            // Construct a message containing the SASL response and send it to the server.\n                 SaslMessageToken saslResponse = new SaslMessageToken(responseToServer);\n                 channel.writeAndFlush(saslResponse, channel.voidPromise());\n             }\n         }\n    +\n    +    @Override\n    +    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    +        super.channelRegistered(ctx);\n    +        LOG.debug(\"channelRegistered {}\", ctx);\n    +    }\n    +\n    +    @Override\n    +    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n    +        super.channelUnregistered(ctx);\n    +        LOG.debug(\"channelUnregistered {}\", ctx);\n    +\n    +    }\n    +\n    +    @Override\n    +    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    +        LOG.warn(\"{} exceptionCaught\", ctx, cause);\n    +        super.exceptionCaught(ctx, cause);\n    --- End diff --\n    \n    LOG.warn(\"{} exceptionCaught\", ctx, cause) you have one {} but 2 variables here.\n","created":"2018-06-28T07:46:59.350+0000","updated":"2018-06-28T07:46:59.350+0000","started":"2018-06-28T07:46:59.349+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"116829","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/117008","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user asfgit closed the pull request at:\n\n    https://github.com/apache/storm/pull/2741\n","created":"2018-06-28T20:32:06.493+0000","updated":"2018-06-28T20:32:06.493+0000","started":"2018-06-28T20:32:06.493+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"117008","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/117199","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user srdo commented on a diff in the pull request:\n\n    https://github.com/apache/storm/pull/2741#discussion_r199057391\n  \n    --- Diff: storm-client/src/jvm/org/apache/storm/messaging/netty/KerberosSaslClientHandler.java ---\n    @@ -96,53 +96,69 @@ private void handleControlMessage(ChannelHandlerContext ctx, ControlMessage cont\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n             if (controlMessage == ControlMessage.SASL_COMPLETE_REQUEST) {\n    -                LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n    +            LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n     \n    -                if (!saslNettyClient.isComplete()) {\n    +            if (!saslNettyClient.isComplete()) {\n                     String errorMessage =\n                         \"Server returned a Sasl-complete message, but as far as we can tell, we are not authenticated yet.\";\n                     LOG.error(errorMessage);\n                     throw new Exception(errorMessage);\n    -                }\n    +            }\n                 ctx.pipeline().remove(this);\n                 this.client.channelReady(channel);\n     \n                 // We call fireChannelRead since the client is allowed to\n    -                // perform this request. The client's request will now proceed\n    -                // to the next pipeline component namely StormClientHandler.\n    +            // perform this request. The client's request will now proceed\n    +            // to the next pipeline component namely StormClientHandler.\n                 ctx.fireChannelRead(controlMessage);\n    -            } else {\n    +        } else {\n                 LOG.warn(\"Unexpected control message: {}\", controlMessage);\n    -            }\n    +        }\n         }\n     \n         private void handleSaslMessageToken(ChannelHandlerContext ctx, SaslMessageToken saslMessageToken) throws Exception {\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n    -            LOG.debug(\"Responding to server's token of length: {}\",\n    -            saslMessageToken.getSaslToken().length);\n    -\n    -            // Generate SASL response (but we only actually send the response if\n    -            // it's non-null.\n    -            byte[] responseToServer = saslNettyClient\n    -            .saslResponse(saslMessageToken);\n    -            if (responseToServer == null) {\n    -                // If we generate a null response, then authentication has completed\n    -                // (if not, warn), and return without sending a response back to the\n    -                // server.\n    -                LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    -                if (!saslNettyClient.isComplete()) {\n    -                    LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    -                    throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    -                }\n    -            this.client.channelReady(channel);\n    -            } else {\n    -                LOG.debug(\"Response to server token has length: {}\",\n    -                          responseToServer.length);\n    -            // Construct a message containing the SASL response and send it to the\n    +        LOG.debug(\"Responding to server's token of length: {}\", saslMessageToken.getSaslToken().length);\n    +\n    +        // Generate SASL response (but we only actually send the response if\n    +        // it's non-null.\n    +        byte[] responseToServer = saslNettyClient.saslResponse(saslMessageToken);\n    +        if (responseToServer == null) {\n    +            // If we generate a null response, then authentication has completed\n    +            // (if not, warn), and return without sending a response back to the\n                 // server.\n    +            LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    +            if (!saslNettyClient.isComplete()) {\n    +                LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    +                throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    +            }\n    +            this.client.channelReady(channel);\n    +        } else {\n    +            LOG.debug(\"Response to server token has length: {}\",\n    +                      responseToServer.length);\n    +            // Construct a message containing the SASL response and send it to the server.\n                 SaslMessageToken saslResponse = new SaslMessageToken(responseToServer);\n                 channel.writeAndFlush(saslResponse, channel.voidPromise());\n             }\n         }\n    +\n    +    @Override\n    +    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    +        super.channelRegistered(ctx);\n    +        LOG.debug(\"channelRegistered {}\", ctx);\n    --- End diff --\n    \n    Sorry, didn't get to this in time. It looks good overall, but I'm wondering what these methods are for? If you want to monitor the reconnect, I think channelActive/channelInactive would be a better fit (see https://netty.io/wiki/new-and-noteworthy-in-4.0.html#simplified-channel-state-model)\n","created":"2018-06-29T05:40:04.707+0000","updated":"2018-06-29T05:40:04.707+0000","started":"2018-06-29T05:40:04.706+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"117199","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/117378","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user agresch commented on a diff in the pull request:\n\n    https://github.com/apache/storm/pull/2741#discussion_r199145547\n  \n    --- Diff: storm-client/src/jvm/org/apache/storm/messaging/netty/KerberosSaslClientHandler.java ---\n    @@ -96,53 +96,69 @@ private void handleControlMessage(ChannelHandlerContext ctx, ControlMessage cont\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n             if (controlMessage == ControlMessage.SASL_COMPLETE_REQUEST) {\n    -                LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n    +            LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n     \n    -                if (!saslNettyClient.isComplete()) {\n    +            if (!saslNettyClient.isComplete()) {\n                     String errorMessage =\n                         \"Server returned a Sasl-complete message, but as far as we can tell, we are not authenticated yet.\";\n                     LOG.error(errorMessage);\n                     throw new Exception(errorMessage);\n    -                }\n    +            }\n                 ctx.pipeline().remove(this);\n                 this.client.channelReady(channel);\n     \n                 // We call fireChannelRead since the client is allowed to\n    -                // perform this request. The client's request will now proceed\n    -                // to the next pipeline component namely StormClientHandler.\n    +            // perform this request. The client's request will now proceed\n    +            // to the next pipeline component namely StormClientHandler.\n                 ctx.fireChannelRead(controlMessage);\n    -            } else {\n    +        } else {\n                 LOG.warn(\"Unexpected control message: {}\", controlMessage);\n    -            }\n    +        }\n         }\n     \n         private void handleSaslMessageToken(ChannelHandlerContext ctx, SaslMessageToken saslMessageToken) throws Exception {\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n    -            LOG.debug(\"Responding to server's token of length: {}\",\n    -            saslMessageToken.getSaslToken().length);\n    -\n    -            // Generate SASL response (but we only actually send the response if\n    -            // it's non-null.\n    -            byte[] responseToServer = saslNettyClient\n    -            .saslResponse(saslMessageToken);\n    -            if (responseToServer == null) {\n    -                // If we generate a null response, then authentication has completed\n    -                // (if not, warn), and return without sending a response back to the\n    -                // server.\n    -                LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    -                if (!saslNettyClient.isComplete()) {\n    -                    LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    -                    throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    -                }\n    -            this.client.channelReady(channel);\n    -            } else {\n    -                LOG.debug(\"Response to server token has length: {}\",\n    -                          responseToServer.length);\n    -            // Construct a message containing the SASL response and send it to the\n    +        LOG.debug(\"Responding to server's token of length: {}\", saslMessageToken.getSaslToken().length);\n    +\n    +        // Generate SASL response (but we only actually send the response if\n    +        // it's non-null.\n    +        byte[] responseToServer = saslNettyClient.saslResponse(saslMessageToken);\n    +        if (responseToServer == null) {\n    +            // If we generate a null response, then authentication has completed\n    +            // (if not, warn), and return without sending a response back to the\n                 // server.\n    +            LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    +            if (!saslNettyClient.isComplete()) {\n    +                LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    +                throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    +            }\n    +            this.client.channelReady(channel);\n    +        } else {\n    +            LOG.debug(\"Response to server token has length: {}\",\n    +                      responseToServer.length);\n    +            // Construct a message containing the SASL response and send it to the server.\n                 SaslMessageToken saslResponse = new SaslMessageToken(responseToServer);\n                 channel.writeAndFlush(saslResponse, channel.voidPromise());\n             }\n         }\n    +\n    +    @Override\n    +    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    +        super.channelRegistered(ctx);\n    +        LOG.debug(\"channelRegistered {}\", ctx);\n    --- End diff --\n    \n    In my case, the channel never went active.  I did not understand what was happening at the time.  By overriding the registered and unregistered, my first clue was that unregister was called immediately after register.  \r\n    \r\n    Since it took me a day and a half to debug this issue and this was my first real clue, I thought it was important to log to save time for debugging future issues.\r\n    \r\n    I will say I do not know anything about Netty though, I am sure you could have solve this much quicker.\n","created":"2018-06-29T12:40:01.973+0000","updated":"2018-06-29T12:40:01.973+0000","started":"2018-06-29T12:40:01.972+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"117378","issueId":"13168631"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13168631/worklog/117415","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user srdo commented on a diff in the pull request:\n\n    https://github.com/apache/storm/pull/2741#discussion_r199193610\n  \n    --- Diff: storm-client/src/jvm/org/apache/storm/messaging/netty/KerberosSaslClientHandler.java ---\n    @@ -96,53 +96,69 @@ private void handleControlMessage(ChannelHandlerContext ctx, ControlMessage cont\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n             if (controlMessage == ControlMessage.SASL_COMPLETE_REQUEST) {\n    -                LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n    +            LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n     \n    -                if (!saslNettyClient.isComplete()) {\n    +            if (!saslNettyClient.isComplete()) {\n                     String errorMessage =\n                         \"Server returned a Sasl-complete message, but as far as we can tell, we are not authenticated yet.\";\n                     LOG.error(errorMessage);\n                     throw new Exception(errorMessage);\n    -                }\n    +            }\n                 ctx.pipeline().remove(this);\n                 this.client.channelReady(channel);\n     \n                 // We call fireChannelRead since the client is allowed to\n    -                // perform this request. The client's request will now proceed\n    -                // to the next pipeline component namely StormClientHandler.\n    +            // perform this request. The client's request will now proceed\n    +            // to the next pipeline component namely StormClientHandler.\n                 ctx.fireChannelRead(controlMessage);\n    -            } else {\n    +        } else {\n                 LOG.warn(\"Unexpected control message: {}\", controlMessage);\n    -            }\n    +        }\n         }\n     \n         private void handleSaslMessageToken(ChannelHandlerContext ctx, SaslMessageToken saslMessageToken) throws Exception {\n             Channel channel = ctx.channel();\n             KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n    -            LOG.debug(\"Responding to server's token of length: {}\",\n    -            saslMessageToken.getSaslToken().length);\n    -\n    -            // Generate SASL response (but we only actually send the response if\n    -            // it's non-null.\n    -            byte[] responseToServer = saslNettyClient\n    -            .saslResponse(saslMessageToken);\n    -            if (responseToServer == null) {\n    -                // If we generate a null response, then authentication has completed\n    -                // (if not, warn), and return without sending a response back to the\n    -                // server.\n    -                LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    -                if (!saslNettyClient.isComplete()) {\n    -                    LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    -                    throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    -                }\n    -            this.client.channelReady(channel);\n    -            } else {\n    -                LOG.debug(\"Response to server token has length: {}\",\n    -                          responseToServer.length);\n    -            // Construct a message containing the SASL response and send it to the\n    +        LOG.debug(\"Responding to server's token of length: {}\", saslMessageToken.getSaslToken().length);\n    +\n    +        // Generate SASL response (but we only actually send the response if\n    +        // it's non-null.\n    +        byte[] responseToServer = saslNettyClient.saslResponse(saslMessageToken);\n    +        if (responseToServer == null) {\n    +            // If we generate a null response, then authentication has completed\n    +            // (if not, warn), and return without sending a response back to the\n                 // server.\n    +            LOG.debug(\"Response to server is null: authentication should now be complete.\");\n    +            if (!saslNettyClient.isComplete()) {\n    +                LOG.warn(\"Generated a null response, but authentication is not complete.\");\n    +                throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n    +            }\n    +            this.client.channelReady(channel);\n    +        } else {\n    +            LOG.debug(\"Response to server token has length: {}\",\n    +                      responseToServer.length);\n    +            // Construct a message containing the SASL response and send it to the server.\n                 SaslMessageToken saslResponse = new SaslMessageToken(responseToServer);\n                 channel.writeAndFlush(saslResponse, channel.voidPromise());\n             }\n         }\n    +\n    +    @Override\n    +    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n    +        super.channelRegistered(ctx);\n    +        LOG.debug(\"channelRegistered {}\", ctx);\n    --- End diff --\n    \n    Thanks for explaining. Happy you solved it.\n","created":"2018-06-29T15:19:05.267+0000","updated":"2018-06-29T15:19:05.267+0000","started":"2018-06-29T15:19:05.266+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"117415","issueId":"13168631"}]},"customfield_12311820":"0|i3vanr:"}}