[i was able to reproduce this by having 10 threads share a session, all sending messages to the same queue 0..100ms between sends. it failed after a few thousand messages. restarting the broker fixes the problem. the producer and broker were separate VM's.

i then tried the trunk snapshot from 3/18, and the same test program worked fine.

i can modify my test to see if it can happen with everything in the same VM, so a unit test can be created (if there is interest from the AMQ developers).

i did a cursory review of the changes between 1/16 and 3/18 and nothing jumped out. are there any notable concurrency related bugs that were fixed in this time?, This looks like a case of  'slow consumer' and producer flowcontrol. You can fail producers, block them or spool to disk. The default out of the box 5.2 behavior is to use producer flow control and stall/block the producer. The SystemUsage.setSendFailIfNoSpace attribute can force a failure and configuring a memory limit for message spooling can ensure memory limits are not exceeded.

In your test case, it is 10 threads sharing a connection rather than a session, correct?. A session should be reserved for a single thread.

I am wondering if this issue can be closed or if you want an additional facility to enable fail with timeout when producer flow control is configured., Thanks for the followup, Gary.

I believe they were all sharing a session, but I don't recall anymore (this was at a project with a past employer, and I don't have access to the test code anymore).

iirc, the test was to a persistent queue, so a slow consumer shouldn't block producers. If the consumer is slow the messages would spool to disk.

You can probably close this for now.. but my thought at the time was using the method that took a timeout would help prevent blocking forever for unsuspecting users. Even if the default was several minutes, if its blocked for that long, things are likely fubar.

, closing this following comments from reporter. no test code available]