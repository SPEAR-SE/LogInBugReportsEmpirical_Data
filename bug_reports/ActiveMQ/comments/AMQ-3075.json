[Thanks for the detailed log information.
Yes, the use case is auto upgrading an existing datastore.
Can you validate that the rest of the statements  work on postgresql by making the changed to the xml  configuration using a spring property update of the form. This can also provide a workaround.

Think we can pull out the alter table statements to have them easily overridden by the postgresql adapter.
{code}

<persistenceAdapter>
 <jdbcPersistenceAdapter dataSource="#postgres-ds" useDatabaseLock="false">
         <statements>
            <statements>
                        <property xmlns="http://www.springframework.org/schema/beans" name="createSchemaStatements">
                            <list>
                             <value>CREATE TABLE ACTIVEMQ_MSGS(ID BIGINT NOT NULL, CONTAINER VARCHAR(250), MSGID_PROD
                                VARCHAR(250), MSGID_SEQ BIGINT, EXPIRATION BIGINT, MSG BYTEA, PRIMARY KEY ( ID ) )</value>
                             <value>CREATE INDEX ACTIVEMQ_MSGS_MIDX ON ACTIVEMQ_MSGS (MSGID_PROD,MSGID_SEQ)</value>
                             <value>CREATE INDEX ACTIVEMQ_MSGS_CIDX ON ACTIVEMQ_MSGS (CONTAINER)</value>
                             <value>CREATE INDEX ACTIVEMQ_MSGS_EIDX ON ACTIVEMQ_MSGS (EXPIRATION)</value>
                             <value>CREATE TABLE ACTIVEMQ_ACKS(CONTAINER VARCHAR(250) NOT NULL, SUB_DEST VARCHAR(250), CLIENT_ID VARCHAR(250) NOT NULL, SUB_NAME VARCHAR(250) NOT NULL, SELECTOR VARCHAR(250), LAST_ACKED_ID BIGINT, PRIMARY KEY ( CONTAINER, CLIENT_ID, SUB_NAME))</value>
                             <value>CREATE TABLE ACTIVEMQ_LOCK( ID BIGINT NOT NULL, TIME BIGINT, BROKER_NAME VARCHAR(250), PRIMARY KEY (ID) )</value>
                             <value>INSERT INTO ACTIVEMQ_LOCK(ID) VALUES (1)</value>
                             <value>ALTER TABLE ACTIVEMQ_MSGS ADD PRIORITY BIGINT</value>
                             <value>CREATE INDEX ACTIVEMQ_MSGS_PIDX ON ACTIVEMQ_MSGS (PRIORITY)</value>
                             <value>ALTER TABLE ACTIVEMQ_ACKS ADD PRIORITY BIGINT DEFAULT 5 NOT NULL</value>
                             <value> ALTER TABLE activemq_acks drop constraint activemq_acks_pkey</value>
                             <value>ALTER TABLE ACTIVEMQ_ACKS ADD PRIMARY KEY (CONTAINER, CLIENT_ID, SUB_NAME, PRIORITY)</value>
                         </list>
                 </property>
      </statements>
   </statements>
 </jdbcPersistenceAdapter>
</persistenceAdapter>
{code}, or maybe the "ALTER TABLE activemq_acks drop constraint activemq_acks_pkey" syntax will work across the board., r1049122

Postgres adapter overrides the alter statement to resolve. new attribute on statements to expose the variability and acksPkName attribute on posgres adapter in case generated name of pk constraint changes.
, I'll check out the update and double-check that it solves the issue. I don't know if the alter table statement is thee same for every db AMQ supports, but I can test out psql with what's in there., Hi Gary, 

SQL Server 2005 has the same problem as PostgreSQL. Could you please update TransactJDBCAdapter as well?

--Kevin, @Kevin, do you know what a sensible default name for the PK in SQLServer is?
As there is no name provided when the constraint is created the name auto-generated by sql server, seems to be of the form "PK..."
, Hi Gary,

You are right. "ACTIVEMQ_ACKS" has a composite primary key and the contraint has the form like this: PK__ACTIVEMQ_ACKS__6DC22B62. This primary key constraint is auto-generated by SQL Server and also everytime the contraint is different.
This script works "ALTER TABLE [dbo].[ACTIVEMQ_ACKS] DROP CONSTRAINT [PK__ACTIVEMQ_ACKS__6DC22B62]" and I have tried "ALTER TABLE [dbo].[ACTIVEMQ_ACKS] DROP CONSTRAINT [PK__ACTIVEMQ_ACKS]" but it doesn't work.

We could use "select name from sysobjects where xtype = 'PK' and parent_obj = object_id('ACTIVEMQ_ACKS')" to get the contraint name. It may need to use dynamic SQL to drop the primary key from SQL Server.

There are also some links may give some hints:
SQL Server: drop table primary key, without knowing its name: http://stackoverflow.com/questions/1587812/sql-server-drop-table-primary-key-without-knowing-its-name
SQL SERVER - How to Drop Primary Key Contraint: http://blog.sqlauthority.com/2009/05/12/sql-server-how-to-drop-primary-key-contraint/

--Kevin, Hi Gary,

Could we define the primary key constraint name when creating ACTIVEMQ_ACKS? Then we could have a fixed constraint name and this name could be used in ALTER SQL.
For instance, when creating the table we use the following SQL: 

CREATE TABLE ACTIVEMQ_ACKS
(

   CONTAINER VARCHAR(250) NOT NULL, 
   SUB_DEST VARCHAR(250), 
   CLIENT_ID VARCHAR(250) NOT NULL, 
   SUB_NAME VARCHAR(250) NOT NULL, 
   SELECTOR VARCHAR(250), 
   LAST_ACKED_ID BIGINT, 
   CONSTRAINT PK_ACTIVEMQ_ACKS PRIMARY KEY
   (
        CONTAINER, 
        CLIENT_ID, 
        SUB_NAME
    )
)

We could have the unique CONSTRAINT name as PK_ACTIVEMQ_ACKS. Then we could drop the constraint like this:ALTER TABLE ACTIVEMQ_ACKS DROP CONSTRAINT PK_ACTIVEMQ_ACKS.
This solution works for SQL server and could work for Oracle as well. I am not sure if this could work for other DBs.

It seems for MySQL we should use this SQL to drop primary key. 
ALTER TABLE ACTIVEMQ_ACKS DROP PRIMARY KEY

--Kevin, I think we may have to go with the dynamic sql to find the pk, the problem is an upgrade from a schema where the pk name was not provided when the constraint was created. Adding the pk name is probably a good idea though for the future., need to add some dynamic sql to determine the pk for the drop statements., Will this be included into the next release, maybe 5.14.1?, The issue remains on SQLserver in 5.14.1 and prevents broker startup, as the tables do not get created. Despite the existence of a workaround (manually precreate tables) it's rather stunning that such a critical issue remains unfixed.]