[Problem can be reproduced in ActiveMQ 5.8.0.
Here is a test driver to reproduce it.
Replace the MessagePriorityTest.java in a vanilla installation and run the test :
mvn -Dtest=JDBCMessagePriorityTest test
Note : "asserts" have been disabled to avoid stop on first error., Here is a new version of the test driver that almost solves the problem of the priorities not taken into account.  The workaround is to  restart the broker before message consumption.  In real-life, this is of course not possible, but it can help find the root cause of the problem.  Instead of hundreds of messages not being prioritized properly, only 2 messages are not, but this minor problem can also be solved with "queuePrefetch=0" instead of 1.
Note : the test driver does not reproduce the problem where the messages with high priority are never consumed anymore (this problem could not be isolated)., A third version (_frozen) of the test driver that reproduces the "frozen" consumption of messages.  After 3600 messages, there are still 1200 messages in the queue, but the browser sees "0". The workaround to restart the broker resumes the message consumption., I just gave org.apache.activemq.store.JDBCMessagePriorityTest#testQueues (with ur modified MessagePriorityTest) a run on trunk and it works, is that the test that should show the problem?
maybe try against at 5.9-SNAPSHOT or did I miss something., Gary, thanks for looking into this.
I just tried with the ZIP from Hudson build ActiveMQ-Java7 #187 and the problem is still present.
Beware that the "asserts" have been disabled in the test driver, otherwise it is impossible to see how many messages are not sorted according to priority (it aborts on the first failed one).  The easiest way to see it is to change the parameter "redirectTestOutputToFile" in the root pom.xml to false, and launch the following command :
mvn -Dtest=JDBCMessagePriorityTest#testQueues test.
, [~gtully] : Gary, my understanding from this problem is the following : with an ActiveMQ broker configured with JDBC persistence, if the queue depth is larger than what can fit in-memory, any non-FIFO consumer on the queue may be blocked receiving messages in the queue, because messages in the JMS store are only considered for consumption after in-memory messages.  This problem can happen when JMS priorities are used, but also when JMS message selectors are used.
Is that correct ?
, @metatach I have not had the opportunity to dig deeper into your tests case but for priority, the db gets to order the messages (once it is queried). For selectors, the match only occurs on the cursor. So priority and selectors are different in the jdbc case. It may be that the db is not queried if the cursor gets filled with low priority messages due to the fill order., This cases seems to be the same as that in AMQ-5853 which is now resolved.  Tried out the attached tests and it seems they now work as best I can tell.  ]