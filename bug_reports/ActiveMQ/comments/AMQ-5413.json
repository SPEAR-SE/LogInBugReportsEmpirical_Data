[I believe that the broker is mishandling the Flow performative 'drain' flag. Referring to trace http://people.apache.org/~chug/adverb_qpid_send_receive_1/qpid-send-receive_activemq-5.11_nodelay_1.html the following flow exchange happens:
{noformat}
◊  ◊◊  Frame 97  127.0.0.1:38598  -> 127.0.0.1:5672  10.422229 flow [0,0] (0,1000)   (drain=false)
◊  ◊◊  Frame 98  127.0.0.1:38598  -> 127.0.0.1:5672  10.422252 flow [0,0] (0,1000)   (drain=true)
◊  ◊◊  Frame 100  127.0.0.1:38598 <-  127.0.0.1:5672  10.423470 flow [0,0] (1000,0)
◊  ◊◊  Frame 101  127.0.0.1:38598  -> 127.0.0.1:5672  10.423595 flow [0,0] (1000,1000)
◊  ◊◊  Frame 102  127.0.0.1:38598 <-  127.0.0.1:5672  10.423810 flow [0,0] (2000,0)
{noformat}
The client sends two closely spaced flow messages to the broker. They are identical except that the drain flag is false in Frame 97 but true in Frame 98. The broker responds in Frame 100 by advancing the delivery count to 1000 to drain the available credit.  Frames 101 and 102 are a repeat of the flow-with-drain from the client followed by the broker effecting the drain with an advanced delivery count.

The protocol error is that by AMQP 1.0 the sender receiving a flow with drain=true SHOULD send all available messages before advancing the delivery count to effect the drain.

Just a guess here but the broker looks like it starts to form a delivery for the message it has in the queue but can't deliver it because the drain behavior kicked in. That's why when the client finally gets the message it is 'redelivered'.

Since the behavior is marked with SHOULD and not with MUST then the drain behavior is probably acceptable. However, if the drain bypasses available messages then a user might expect that the messages would finally be delivered with Redelivered=false. , This is resolved with the addition of proper drain support.  , Found an issue with the credit handling after drain completes., Additional fix and tests added]