[In fact this fails for all types except char and boolean as the following unit tests demonstrate:


import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Session;

import org.apache.activemq.ActiveMQConnectionFactory;

import junit.framework.TestCase;

public class MapMessageTest extends TestCase {

    private ConnectionFactory factory;
    private Connection connection;   
    private MapMessage message;
    
    protected void setUp() throws Exception {
        factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false");
        connection = factory.createConnection();
        connection.start();             
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        message = session.createMapMessage();
        super.setUp();
    }
    
    protected void tearDown() throws Exception {
        connection.close();
        super.tearDown();
    }    
    
    
    public void testUnmappedBooleanMessage() throws JMSException {
        
        Object expected;
        try {
            expected = Boolean.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Boolean actual = message.getBoolean("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }
        
    }
    
    public void testUnmappedIntegerMessage() throws JMSException {
        
        Object expected;
        try {
            expected = Integer.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Integer actual = message.getInt("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }
        
    }
    
    
    public void testUnmappedShortMessage() throws JMSException {
        
        Object expected;
        try {
            expected = Short.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Short actual = message.getShort("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }
        
    }
    
    
    public void testUnmappedLongMessage() throws JMSException {
        
        Object expected;
        try {
            expected = Long.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Long actual = message.getLong("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }
        
    }
    
    
    public void testUnmappedStringMessage() throws JMSException {
        Object expected;
        try {
            expected = String.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            String actual = message.getString("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }
    }
   

    public void testUnmappedCharMessage() throws JMSException {
        try {
            message.getChar("foo");
            fail("should have thrown NullPointerException");
        }
        catch (NullPointerException success) {
            assertNotNull(success);
        }
    } 
    
    public void testUnmappedByteMessage() throws JMSException {
        Object expected;
        try {
            expected = Byte.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Byte actual = message.getByte("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }


    }
    
    public void testUnmappedDoubleMessage() throws JMSException {

        Object expected;
        try {
            expected = Double.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Double actual = message.getDouble("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }


    }
    
    public void testUnmappedFloatMessage() throws JMSException {
        
        Object expected;
        try {
            expected = Float.valueOf(null);
        }
        catch (Exception ex) {
            expected = ex;
        }

        try {
            Float actual = message.getFloat("foo");
            assertEquals(expected, actual);
        }
        catch (Exception ex) {
            assertEquals(expected, ex);
        }

    }
    
}, JUnit test case demonstrating bugs in MapMessage class with conversion of unmapped values, #getBytes also appears to be incorrect in two ways. 

First, from  [MapMessage.html|http://java.sun.com/j2ee/1.4/docs/api/javax/jms/MapMessage.html] this method should return null if the entry does not exist. From the code, it appears as if MessageFormatException is thrown instead.

Second, if an attempt is made to MessageFormatException for a null value, an NPE will be generated due to the "value.getClass().getName()".

{code}
public byte[] getBytes(String name) throws JMSException {
        initializeReading();
        Object value = map.get(name);
        if (value instanceof byte[]) {
            return (byte[])value;
        } else {
            throw new MessageFormatException(" cannot read a byte[] from " + value.getClass().getName());
        }
    }
{code}
, Fixed by SVN revision 791708]