[Possible workarounds:
- concurrentStoreAndDispatchTopics="false" as recommended in AMQ-2864,
- use a different persistence store, e.g. LevelDB
, Attaching unit test in AMQ-5668Test.tgz. It uses Eclipse Paho MQTT library., [~tmielke],

Thanks for the bug report and for your test case.  I took a look at this and there is a race condition.  As you pointed out, the best work around is probably to use concurrentStoreAndDispatchTopics="false" for now.

In detail, the issue lies in the setLastCacheId method in AbstractStoreCursor which you can see in the stack trace.  In the else clause in that method lastCachedIds[ index].getFutureOrSequenceLong() is returning null because it hasn't been set yet.  KahaDB assigns that value when the message is added to the store in a transaction.   However the TopicStorePefetch cursor is calling trackLastCached before KahaDB actually gets around to finishing the transaction and assigning the value, which happens asynchronously.

[~tabish121] and [~gtully], What do you guys thisnk about this?  It's certainly easy enough to add a null check but then the value is never cached in setLastCachedId as it just skips it.  This may not actually be a problem depending on what the lastCacheId is used for.  If I add a null check in, the test case passes but it seems like there could be a larger concurrency issue here that might need to be resolved besides just adding in a check for a null.
, [~christopher.l.shannon] - great that you are looking into this, it always helps to have another set of eyes.
I think there are two things to consider: 1) the value of concurrentStoreAndDispatchTopics=true - I don't really see the benefit b/c it is very unlikely that all subs will get to ack a message before it is persisted. In the queue case, it does have a beneficial effect b/c it is just a single client that needs to ack fast.
2) what lastCacheId is used for? When the cache is full it stops tracking messages and when the cache is empty, to avoid replaying all messages from the store the cursor wants to start a store replay from the last message that it cached. There is a setBatch that sets the start point. Implicit in this is that the sequenceId in the store is in sync with the order messages are placed in the cursor. That is the crux of it. If the start point is off, there is a potential for a missed dispatch or a duplicate dispatch. Note - I think the durable topic case is a little simpler because of the per sub index, but that would need to be validated.

In the queue case, there are a bunch of hoops that ensure ordering because it is complicated with concurrentStoreAndDispatch. The same attention has not been given to the topic case to date.
If there is a proven usecase for  concurrentStoreAndDispatchTopics=true (point 1) - then the is a case for migrating the work done on queue cursors around lastCacheId to topics.
, Seeing as how there isn't really a benefit based on your first point and that there is at least one issue documented (as shown by this NPE), should we go ahead and update the documentation here http://activemq.apache.org/kahadb.html to specify that {{concurrentStoreAndDispatchTopics}} is not recommended to be enabled?  , Agree with that, there doesnâ€™t seem to be a compelling reason to enable that for Topics. , I went ahead and updated the documentation with a warning to specify concurrentStoreAndDispatchTopics is not recommended.  I would say we should probably close this ticket as there is a larger issue here than just the NPE and there isn't a reason to enable this property right now.  As Gary said, if there is a proven use case then it can be revisited later and a new ticket can be created to migrate the work from the queue case to ensure proper ordering is done., Today I got the exact same null pointer exception in the same spot of the code (setLastCachedId method).  I was just using JMS and not MQTT.  I was doing some testing and I had a producer publishing messages as fast as possible to a topic.  At the time there was an existing offline durable subscription on that topic.  While the producer was running, I removed the durable subscription (using broker.removeSubscription) and the producer received that null pointer exception and closed.  I repeated the test and it didn't happen every time but I can get it to happen every few times.

So it seems like it might be a good idea to at least add in a null pointer check to prevent an exception since there is a race condition issue., i wonder if you could try and manufacture a unit test that can reproduce? it does look like some work is needed., I'll try and come up with a test tomorrow that can reproduce it.  It might be hard to get something that happens reliably but I'll see what I can do. , I was actually able to reproduce this reliably in a unit test.  What I discovered with my use case is that the same line is throwing the exception as the test case that was uploaded to this ticket, but it's a slightly different issue.  For the the original issue, astCachedIds[ index].getFutureOrSequenceLong() is returning null which causes the Long.compare method to fail.  In my case, with the durable unsubscribe, candidate.getFutureOrSequenceLong() is returning null and causing the problem.

I'm working on a pull request now to fix both issues and I will push it up shortly., GitHub user cshannon opened a pull request:

    https://github.com/apache/activemq/pull/116

    https://issues.apache.org/jira/browse/AMQ-5668

    This commit fixes a race condition in AbstractStoreCursor setLastCacheId that could
    cause a null pointer exception in certain cases.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/cshannon/activemq AMQ-5668

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/activemq/pull/116.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #116
    
----
commit 72f30e9c82d157f2810a9bff315da99d8b7098fb
Author: Christopher L. Shannon (cshannon) <christopher.l.shannon@gmail.com>
Date:   2015-06-17T13:23:08Z

    https://issues.apache.org/jira/browse/AMQ-5668
    
    This commit fixes a race condition in AbstractStoreCursor setLastCacheId that could
    cause a null pointer exception in certain cases.

----
, I submitted a PR that fixes the race condition causing the NPE for both the test case uploaded to this ticket and the case that I found.  It solves the race condition problem by saving references off locally to prevent the issue of the state changing (ie becoming null) after the null check was performed. I included a unit test to show that it is fixed.

Edit: I forgot to mention that there is probably more work to be done here, but this patch at least will prevent the producer from blowing up on sends because of a NPE., Github user asfgit closed the pull request at:

    https://github.com/apache/activemq/pull/116
, Seems sensible enough to protect from the NPE case, patch applied, thanks!]