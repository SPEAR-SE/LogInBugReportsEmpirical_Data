[Can you post a complete sample app that demonstrates your consumer code, can't tell from this snippet what your client is doing.  , Here is a bare-bone implementation of my app:-


public class ActiveMQConsumer implements MessageListener
{
    private Connection myConnection;
    
    private Session mySession;
    
    private void start()
    {
        try {
             ActiveMQConnectionFactory connectionFactory = 
                new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER,
                                              ActiveMQConnection.DEFAULT_PASSWORD,
                                              ourBrokerUrl);
            myConnection = connectionFactory.createConnection();
            myConnection.start();
            mySession = myConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
            MessageConsumer consumer = mySession.createConsumer(mySession.createTopic("test_topic"));
            consumer.setMessageListener(this);
        }
        catch (JMSException e) {
            throw new RuntimeException(e);
        }     
    }
   
    private void stop()
    {
        myConnection.close();
    }
   
    public void onMessage(Message message)
    {
	 // Do Something
    }

    public static void main(final String args[])
    {
        TerminatingThreadGroup.runInTerminatingThreadGroup(new Runnable() {
            public void run()
            {
                final ActiveMQConsumer consumer = new ActiveMQConsumer();

                ShutdownTasks.addShutdownHook(new Runnable() {
                    @Override
                    public void run()
                    {
                        consumer.stop();
                    }
                }, "Shutdown-ActiveMQConsumer");

                consumer.start();
            }
        });
    }
}

What I might be doing wrong here ??, Woah ! Something messed up the indentation quiet badly !! :(
, There doesn't appear to be anything in main preventing the Process from going down, so you are seeing a shutdown related to: AMQ-796, I think we should fix AMQ-796, Yeah, It seems quiet weird to explicitly maintain a non-daemon thread. From what I understood is in my app the only non-daemon thread was the ActiveMQ Transport thread. When the broker dies, the client Transport thread dies with an EOFException and the failover protocol tries to start a new Transport(non-daemon) thread to initiate connection with the failover broker. In this small window since no thread was non-daemon, the client application exits.

One shot at AMQ-796 can be something like maintaining a non-daemon failover thread apart from the regular ActiveMQ Transport thread. This failover thread should perform the reconnection and subsequent failover ActivMQ Transport thread spawning.

Thanks a lot guys !!, Rob resolved AMQ-796 so you may want to give the latest SNAPSHOT build a go and mark this as resolved if your code is working as expect now.  , This was resolved by the fix for AMQ-796]