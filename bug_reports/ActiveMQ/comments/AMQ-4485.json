[fix in http://svn.apache.org/r1475734

idea is to have a beforeCompletion in a per destination sync that is called with the store index exclusive lock. This tracks the required cursor update oder. The first afterCompletion thread that is in order executes all pending updates in the correct order. Out of order completions queue their work or see it already complete. The batch update of pending work prevents further contention/race on the queue sendlock.
We may want to introduce blocking for an ordered execution slot if multiple sync after completions have strict ordered dependencies. For the moment in the broker, after completions are only  used for cursor updates., The fix was reworked/improved for leveldb use case., There are still some gremlins in here, seems to be contention between concurrent commits with composite dests and contention with non transactional work. , fix in http://git-wip-us.apache.org/repos/asf/activemq/commit/511b60c6

non transactional work could interleave with ordered transactional work. that resulted in the cursor and index being out of sync and skipping a dispatch, further rework - jdbc store showed contention was not limited to transactions but to interleaving transactional and non transactional work. Contention between the cursor fill and store scan and for kahadb concurrentStoreAndDispatch - contention with async work queue.
Fix that introduces ordered interplay between store index and destination cursor update on a per message basis:
https://git-wip-us.apache.org/repos/asf?p=activemq.git;a=commit;h=54e2e3be]