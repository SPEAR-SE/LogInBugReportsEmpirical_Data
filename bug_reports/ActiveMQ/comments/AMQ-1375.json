[The stack trace just implies that the current JMS connection is blocked; I suspect its due to a producer being blocked? Are you sharing the connection in spring's listener container stuff?

http://activemq.apache.org/my-producer-blocks.html

I wonder - do you have any way of reproducing this? e.g. a JUnit test case?

Also can you reproduce this on 5.0; which has much more flexible flow control which avoids blocking the entire connection if a single producer is blocked?, Can you explain why a producer would be blocked if all the client does when handling the message is add it to the executor in a Runnable? The reason for doing this was specifically to avoid taking time in the handling the message to prevent blocking the producer....

There is a session & producer created for each client request in a thread local fashion, but only one connection is created on server side. We dont share connection between client and server. Server has one connection only, created using connectionFactory.createConnection(); where connectionFactory is defined as follows in a server side Spring config file:

	<bean id="connectionFactory"
		class="org.apache.activemq.ActiveMQConnectionFactory" depends-on="broker">
		<property name="brokerURL" value="tcp://localhost:50057"/>
	</bean>


Each client listener is defined as follows in a separate client XML file:

   <bean id="destinationResolver" class="com.xxx.yyy.platform.core.transport.activemq.TempDestinationResolver"/>
    
	<bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
		<property name="brokerURL" value="tcp://${jms.server}:${jms.port}"/>
	</bean>
	
	<bean id="listenerContainer" class="org.springframework.jms.listener.SimpleMessageListenerContainer"
        destroy-method="destroy">
		<property name="concurrentConsumers" value="1"/>
		<property name="connectionFactory" ref="connectionFactory" />
		<property name="messageListener" ref="messageListener" />
		<property name="destinationName" value="destination"/>
		<property name="destinationResolver" ref="destinationResolver"/>
	</bean>
	
	<bean id="messageListener" class="com.xxx.yyy.platform.core.transport.activemq.MessageDispatcher"
        destroy-method="dispose">
		<property name="destinationFactory" ref="destinationResolver"/> 
                <property name="messageConverter">
                    <bean class="org.springframework.jms.support.converter.SimpleMessageConverter"/>
                 </property>
	</bean>	

Hence the connections are separate entities created by the ActiveMQConnectionFactory.

Im am trying to reproduce this without our GUI/server stuff, just a simple AMQ Junit............, I found similar stack traces in following issues like AMQ-768 and AMQ-2147. I have the same issue in production now with syncSendPacket(Command) blocking forever. I am thinking that you would have a problem anywhere this method is called, because result may never come back. In AMQ-768 it does not come back because of connection reset or a server side error, in AMQ-2147 it does not come back because of memory issues on the client side.

Here is my stack trace (amq v5.1.0), which is identical to the one listed above, but is parseable by IDEA.

   java.lang.Thread.State: WAITING on edu.emory.mathcs.backport.java.util.concurrent.locks.CondVar@15ee98b5
	at java.lang.Object.wait(Native Method)
	at java.lang.Object.wait(Object.java:485)
	at edu.emory.mathcs.backport.java.util.concurrent.locks.CondVar.await(CondVar.java:75)
	at edu.emory.mathcs.backport.java.util.concurrent.ArrayBlockingQueue.take(ArrayBlockingQueue.java:318)
	at org.apache.activemq.transport.FutureResponse.getResult(FutureResponse.java:42)
	at org.apache.activemq.transport.ResponseCorrelator.request(ResponseCorrelator.java:75)
	at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1175)
	at org.apache.activemq.ActiveMQConnection.createTempDestination(ActiveMQConnection.java:1600)
	at org.apache.activemq.ActiveMQSession.createTemporaryQueue(ActiveMQSession.java:1134)
	at org.logicblaze.lingo.jms.impl.SingleThreadedRequestor.createTemporaryDestination(SingleThreadedRequestor.java:109)
	at org.logicblaze.lingo.jms.impl.SingleThreadedRequestor.<init>(SingleThreadedRequestor.java:56)
	at org.logicblaze.lingo.jms.impl.MultiplexingRequestor.<init>(MultiplexingRequestor.java:64)
	at org.logicblaze.lingo.jms.impl.MultiplexingRequestor.<init>(MultiplexingRequestor.java:69)
	at org.logicblaze.lingo.jms.impl.MultiplexingRequestor.newInstance(MultiplexingRequestor.java:55), I have a similiar case with embedded AMQ 5.2 + tomcat 6.x + java 6, where my embedded jms client ( via vm:// ...) send operation hangs when the broker is heavily processing messages from an another external jms client ( via tcp:// ) . We are using non persistent messages.  Any advice to work around this issue is greatly appreciated.

here is the stack trace

Daemon Thread [Thread-14] (Suspended)	
	Unsafe.park(boolean, long) line: not available [native method]	
	LockSupport.park(Object) line: 158	
	AbstractQueuedSynchronizer$ConditionObject.await() line: 1925	
	ArrayBlockingQueue<E>.take() line: 317	
	FutureResponse.getResult() line: 40	
	ResponseCorrelator.request(Object) line: 80	
	ActiveMQConnection.syncSendPacket(Command) line: 1233	
	ActiveMQSession.send(ActiveMQMessageProducer, ActiveMQDestination, Message, int, int, long, MemoryUsage, int) line: 1659	
	ActiveMQMessageProducer.send(Destination, Message, int, int, long) line: 227	
	ActiveMQMessageProducer(ActiveMQMessageProducerSupport).send(Message) line: 241	
	JmsTemplate.doSend(MessageProducer, Message) line: 597	
	JmsTemplate.doSend(Session, Destination, MessageCreator) line: 574	
	JmsTemplate$4.doInJms(Session) line: 551	
	JmsTemplate.execute(SessionCallback, boolean) line: 471	
	JmsTemplate.send(String, MessageCreator) line: 548	
	OracleSGAAgentProxy(AbstractAsyncAgentProxy).sendMessageToAgent(String) line: 92	
	OracleSGAAgentProxy(AbstractAsyncAgentProxy).pingAgent() line: 147	
	OracleSGAAgentProxy(AbstractAsyncAgentProxy).run() line: 173	
	Thread.run() line: 619	
, and it hangs after i stop the external client and drain all of its messages, No tests provided and no info given if this occurs with the 5.x broker., Hi,
I have the same problem by using java 7, apache-tomcat-7.0.41 and apache-activemq-5.9.0.
The same code is working well from a unit test,but from tomcat environment connection.start() never returns, the blocking point is the same reported in the stacktrace from Dan Tran.
The code sample is here:
{code}
   BrokerService broker = new BrokerService();

        // configure the broker
        try
            {
            broker.addConnector("tcp://localhost:61616");
            broker.start();
            broker.waitUntilStarted();
            CONNECTION_FACTORY = new ActiveMQConnectionFactory(broker.getVmConnectorURI());
            sendConnection = CONNECTION_FACTORY.createConnection();
            sendConnection.start();

            }
        catch (Exception e)
            {
            e.printStackTrace();
            }
{code}
Everything blocks at *sendConnection.start()*.
Please suggest an workaround or add a fix for that.
Thank you]