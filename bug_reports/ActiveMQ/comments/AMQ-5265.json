[GitHub user jgenender opened a pull request:

    https://github.com/apache/activemq/pull/31

    AMQ-5265 - fix race condition for task

    AMQ-5265 - fix race condition for task in MBeanBridgeDestination for running the purgeInactiveDestinationViewTask and the execution of onOutboundMessage and onInboundMessage

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jgenender/activemq trunk

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/activemq/pull/31.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #31
    
----
commit a519384355d0e4acc74e9871ea33e2ee1d113ed5
Author: Jeff Genender <jgenender@savoirtech.com>
Date:   2014-07-08T21:05:41Z

    AMQ-5265 - fix race condition for task

----
, Patch applied. Thanks!, Github user asfgit closed the pull request at:

    https://github.com/apache/activemq/pull/31
, Hello,

I do still see the problem in 5.11.1. The culprit is destinationObjectNameMap which is being used for both inbound and outbound messages.  A destination that is put from the onInBoundMessage gets trashed by the one put from the onOutBoundMessage. The cleanup code in the stop() method will clean only one MBean instance leaving the other one dangling. 

My setup is as follows:

Two Networked Brokers (Full Duplex) (A and B). Two clients each publishing on the same exact topic. Each client is connected to exactly one of the brokers. Kill Broker B. Restart Broker B. On reconnect, you will see the error in Broker A. 

, Attached is a patch that believe will address the issue., GitHub user Hauenstein opened a pull request:

    https://github.com/apache/activemq/pull/114

    https://issues.apache.org/jira/browse/AMQ-5265

    This is a revision of AMQ-5265 -- the original fix didn't quite clean up all of the mbeans that MBeanBridgeDestination created, as [noted in the original issue by Tarek Hammoud](https://issues.apache.org/jira/browse/AMQ-5265?focusedCommentId=14527137&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14527137).  The key for the map used to track the ObjectNames was an ActiveMQDestination (which uses the destination's physical name for its equals() implementation) caused the inbound and outbound entries in the map to randomly replace each other.
    
    Like Tarek, I could reproduce this issue using 5.11.1 with two networked brokers (full duplex) with a client publishing to a topic.  After I restart a broker, the logs on the non-restarted broker show the MBeanBridgeDestination reporting many InstanceAlreadyExistsExceptions when trying to register the unintentionally-duplicated mbeans.
    
    Please let me know if this makes sense or if there are any changes you would suggest (ex: is there a reasonable way or an example I could follow to add a unit test for something like this?).  Thanks!

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/Hauenstein/activemq master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/activemq/pull/114.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #114
    
----
commit 139916e3eee1b60992e13657069358186e57247f
Author: L. Hauenstein <logan.hauenstein@gmail.com>
Date:   2015-06-11T18:34:28Z

    https://issues.apache.org/jira/browse/AMQ-5265
    
    Revision of AMQ-5265 - fixed the map that tracks
    MBeanBridgeDestination's registered mbeans so that it cleans itself up
    correctly when stopped.

----
, [~Hauenstein] peek at https://github.com/apache/activemq/blob/138e52b08c2f49b730817932a6e63f2a135854f1/activemq-unit-tests/src/test/java/org/apache/activemq/network/DuplexNetworkMBeanTest.java for some unit test inspiration, or other tests in that package]