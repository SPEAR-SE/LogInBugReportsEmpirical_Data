[Unit test demonstrating how an expiring message at the end of a queue may never get processed., Have you played with maxExpirePageSize > 400, the intent is that a larger value of this will force the browse to examine more than a page full of messages but will not keep them in memory. 
The problem of timely processing of messages at the end of the queue is still an issue though.
It may be possible to remember the last checked message id and implement a moving window on subsequent processing. That would require support in the cursor for setting that start point which is not currently exposed. It is there under the covers though so it is worth a look. The down side is that it will kill performance (in the case of concurrent dispatch) as it will lock the cursor. 

btw: I agree that the browse idiom is not ideal but it is consistent with existing cursor usage. The main difficulty in a ideal solution is synchronization with message dispatch and acking. For that reason, I think 6.0 is the place for the ideal solution., The Apollo project implements a store that allows for this to work as described.  , reopen to set fix version to 5.6, closing again with correct fix version]