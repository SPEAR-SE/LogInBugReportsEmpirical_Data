[Attaching possible fix and corresponding JUnit test, IMHO the fix is to synchronize access to the cache and the creation of the session pool.

{code:java}
public Session createSession(boolean transacted, int ackMode) throws JMSException {
        SessionKey key = new SessionKey(transacted, ackMode);
        SessionPool pool = null;
        synchronized (cache) {
        	pool = cache.get(key);
        	if (pool == null) {
	            pool = createSessionPool(key);
	            cache.put(key, pool);
	        }
        }
        PooledSession session = pool.borrowSession();
        return session;
    }
{code}, We might consider redefining the cache field from Map to ConcurrentMap and change the code somewhat.

{code:java}
public Session createSession(boolean transacted, int ackMode) throws JMSException {
        SessionKey key = new SessionKey(transacted, ackMode);
        SessionPool pool = null;
        pool = cache.get(key);
        if (pool == null) {
	    SessionPool newPool = createSessionPool(key);
	    SessionPool prevPool = cache.putIfAbsent(key, newPool);
            if (prevPool != null && prevPool != newPool) {
              // newPool was not the first one to be associated with this key... close created session pool
              newPool.destroy(); // don't remember the method call
            }
            pool = cache.get(key); // this will return a non-null value...
	}
        PooledSession session = pool.borrowSession();
        return session;
    }
{code}, Claudio's suggestion should also work (using newPool.close() to discard the pool). I tested it against the JUnit tests of activemq-pool and against a Camel route that consumes from JMS.
It has the advantage that once the cache contains a pool object, there is no additional overhead. All overhead is only in the case when the cache does not yet contain the key.
In my solution there is a synchronized call for every createSession() invocation.
, Applied supplied test case and used the concurrent map approach over the synchronization option.  Please review and reopen if an issue is found with the fix.]