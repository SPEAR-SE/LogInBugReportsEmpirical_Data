[Table definition and single offending record that creates a NegativeArraySizeException, Broker initialization code:

				String host = InetAddress.getLocalHost().getHostAddress();
				String brokerName = host + ":" + ServerProperties.getJobqueueBrokerPort();
				broker = new BrokerService();
				broker.setBrokerName(brokerName);
				broker.setBrokerId(brokerName);
				broker.setUseJmx(true);
				broker.setSchedulerSupport(true);

				//Setup dead letter queue
				IndividualDeadLetterStrategy deadLetterStrategy = new IndividualDeadLetterStrategy();
				deadLetterStrategy.setQueuePrefix("DLQ.");
				deadLetterStrategy.setUseQueueForQueueMessages(true);
				PolicyMap destinationPolicy = new PolicyMap();
				ArrayList<PolicyEntry> entries = new ArrayList<PolicyEntry>();
				PolicyEntry entry = new PolicyEntry();
				entry.setQueue(">");
				entry.setDeadLetterStrategy(deadLetterStrategy);
                                entries.add(entry);
				destinationPolicy.setPolicyEntries(entries);
				broker.setDestinationPolicy(destinationPolicy);

				//Setup destinations
				ActiveMQDestination[] destinations = new ActiveMQDestination[]
				{
						new ActiveMQQueue("q.myapp.job"),
						new ActiveMQTopic("t.myapp.config")
				};
				broker.setDestinations(destinations);

				//Setup persistence
				JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
				jdbcPersistenceAdapter.setCreateTablesOnStartup(false);
				jdbcPersistenceAdapter.setDataSource(dataSource);
				jdbcPersistenceAdapter.setUseDatabaseLock(false);
				broker.setPersistenceAdapter(jdbcPersistenceAdapter);
				broker.setPersistent(true);

				//Setup transports
				TransportConnector connector = new TransportConnector();
				connector.setUri(new URI("tcp://" + broker.getBrokerName()));
				connector.setDiscoveryUri(new URI("multicast://default?group="
						+ ServerProperties.getJobqueueMulticastGroup()));
				broker.addConnector(connector);
				broker.start();
				broker.waitUntilStopped();

, I stepped through the code and found the following scenario:
MessageMarshaller calls Message.setMarshalledProperties(looseUnmarshalByteSequence(dataIn) Line 229

dataIn is a DataByteArrayInputStream which in this case is 65535 in length with a private pos == 65535

readInt is used to get the size to set a local byte[] but readInt returns -16843009 based on the fact that read() returns -1 since the end of the stream has been reached.

It would appear that the message is incomplete in the queue (corrupt) and the reading fails.

My guess is that readInt should understand when the end of the stream has been reached and fail gracefully.

This would provide some level of corrupt message handling to protect the broker. 

I believe that the corrupt message get there to begin with due to an environmental issue.  ie. two brokers trying to access the same message store.  This fix would nevertheless protect the Broker from failing to distribute messages.

The fix to our production environment was just to delete the message from the ACTIVEMQ_MSGS tables.  Once the message was removed the Broker started delivering messages about a minute later.

, We experience the same problem with 5.11.1 and the KahaDB storage.

But here, we have to delete the full kahadb (and loose the messages) . ]