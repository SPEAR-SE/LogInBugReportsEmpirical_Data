[I have just tried an unit test and it sleeps for 30 seconds.
[                          main] RedeliveryPolicy               DEBUG Sleeping for: 30000 millis until attempting redelivery

And then on the 2nd
[                          main] RedeliveryPolicy               DEBUG Sleeping for: 60000 millis until attempting redelivery

Your route doesn't do anything with the received message from activemq:NEW. How do you actually trigger the failure and the redelivery?, I have tried with a jms example and it works in the unit tests in the source code.

Are you sure you have Camel 1.4-SNAPSHOT in ActiveMQ where you run your project?, Hi Claus.

Meanwhile I've realized that the problem is a misunderstanding on my side what camel is supposed to do.
I thought I can configure the redelivery behavior of ActiveMQ within the camelContext as part of the acivemq.xml configuration on a per destination basis. What I haven't mentioned is, that my listener/consumer for the queue isn't configured within camel or activemq but in a separate spring baked application. What I now have realized is, that I have to consume a message via camel to get it's routing/mediation support (including redelivery
features) - now it's crystal clear to me (or not?). So I configured redeliveryPolicy on a ActiveMQConnectionFactory on my spring baked application and the settings are working fine now.

Sorry for mixing things up.

Thanks for you help.

Regards,
Veit
, Hi.

Sorry for reopening but the redeliveryDelay problem still exists. But it seems no camel problem then because I'm not using camel anymore, instead the redeliveryPolicy on the AQConnectionFactory.

So, should that be moved to the AQM project then? There I'm using AMQ 5.1.0 (Camel 1.3).
, Hi Veit

Yes please open a ticket on the ActiveMQ project if its solely an ActiveMQ problem.
http://issues.apache.org/activemq/browse/AMQ, Veit. I managed to move the issue from Camel to ActiveMQ project., Veit. Can you add your new configuration etc. for the ActiveMQ that demonstrates the problem? I am sure the ActiveMQ comitters want to see your configuration file and what the problem is you have., Thanks Claus.

Sure, here's my applicationContext.xml:

<?xml version="1.0" encoding="UTF-8"?>
<beans 
	xmlns="http://www.springframework.org/schema/beans" 
	xmlns:amq="http://activemq.apache.org/schema/core"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
	http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.1.0.xsd">
	
	<!--  ActiveMQ destinations to use  -->
	<bean id="destination" class="org.apache.activemq.command.ActiveMQQueue" autowire="constructor">
		<constructor-arg value="NEW" />
	</bean>

	<bean id="jmsFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
		<property name="brokerURL">
			<value>discovery:multicast://test</value>
		</property>
		<property name="redeliveryPolicy">
			<ref local="redeliveryPolicy" />
		</property>
	</bean>
	<bean id="redeliveryPolicy" class="org.apache.activemq.RedeliveryPolicy">
		<property name="initialRedeliveryDelay" value="10000" />
		<property name="maximumRedeliveries" value="4" />
		<property name="useExponentialBackOff" value="true" />
		<property name="backOffMultiplier" value="2" />
	</bean>
		
	<!-- Spring JMS Template -->
	<bean id="myJmsTemplate" class="org.springframework.jms.core.JmsTemplate">
		<property name="connectionFactory">
			<!-- lets wrap in a pool to avoid creating a connection per send -->
			<bean class="org.springframework.jms.connection.SingleConnectionFactory">
				<property name="targetConnectionFactory">
					<ref local="jmsFactory" />
				</property>
			</bean>
		</property>
	</bean>
	
	<bean id="consumerJmsTemplate" class="org.springframework.jms.core.JmsTemplate">
		<property name="connectionFactory" ref="jmsFactory"/>
	</bean>
	

	<!-- and this is the message listener container -->
	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="jmsFactory"/>
		<property name="destination" ref="destination"/>
		<property name="messageListener" ref="messageListener" />
		<property name="concurrentConsumers" value="100" />
		<property name="maxMessagesPerTask" value="1" />
		<property name="sessionTransacted" value="true" />		
	</bean>
	<!-- this is the Message Driven POJO (MDP) -->
	<bean id="messageListener" class="com.foo.bar.jms.Consumer" />	
	
</beans>


The messageListener will create a RuntimeException on the onMessage method to produce an error. The first redelivery attempt occurs immediately, without respect to the initialRedeliveryDelay.
, Redelivery policy doesn't work with Spring's org.springframework.jms.listener.DefaultMessageListenerContainer at all

That happens, because DefaultMessageListenerContainer closes the consumer, session and connection, and do the reconnect if message listener throws exception, and of course previous delivery timepoint is empty in the new consumer.

It happens, because DefaultMessageListenerContainer doesn't know what a cause of JMSException. Maybe it was disconnection... and ConnectionFactory haven't reconnection logic...

I wrote my own simple MessageListenerContainer, that doesn't do reconnection if JMSException is thrown, because ActiveMQConnectionFactory has reconnection logic
, I'm sorry to correct you, but it IS working with the above configuration. All parameters I change within the redeliveryPolicy bean definition affecting the redelivery within the sping bean! The only thing that doesn't work correctly (or needs enhancement) is the initial redelivery., I don't know how do you reach that, but if I use DefaultMessageListenerContainer  all redeliveries happens immediately, not first only.

If any Execption in MessageListener happens it always closes the connnection

{code:title=DefaultMessageListenerContainer.java}
private class AsyncMessageListenerInvoker implements SchedulingAwareRunnable {

....

    catch (Throwable ex) {
    clearResources();

...


    }

...
}


private void clearResources() {
    if (sharedConnectionEnabled()) {
    synchronized (sharedConnectionMonitor) {
	JmsUtils.closeMessageConsumer(this.consumer);
	JmsUtils.closeSession(this.session);
        }
    }
    else {
	JmsUtils.closeMessageConsumer(this.consumer);
	JmsUtils.closeSession(this.session);
    }
	this.consumer = null;
	this.session = null;
}


{code}, I don't know. Perhaps configuration, ActiveMQ 5.1.0 or Spring 2.5.5. Perhaps someone fixed/enhanced something :).
, @Dima:

Now, I can confirm your findings! After I set the jmsTransactionManager in my config (not just sessionTransacted=true like before) I encounter immediate redelivery without delay/backoffs, too:

	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="jmsFactory"/>
		<property name="destination" ref="destination"/>
		<property name="messageListener" ref="messageListener" />
		<property name="concurrentConsumers" value="2" />
		<property name="maxMessagesPerTask" value="1" />
		<property name="sessionTransacted" value="true" />
		<property name="transactionManager" ref="jmsTransActionManager" />			
	</bean>

After I set this, the MesageListener also checks connections actively - which is very noisy. So in the end: is this all expected behavior? I'm a bit confused...

, transactions change redelivery semantics for a consumer. I think you are seeing expected behavior if the session is transacted considering https://issues.apache.org/activemq/browse/AMQ-1032

If this is not the case, a complete Junit tests case with a listener that throws an exception would help. There are a bunch of spring test cases in the activemq-core module that you could use as a template, resolving pending junit test case that can show otherwise., additional clarification. There is indeed an immediate retry with the redelivery flag set, this allows an app to immediately deal with a redelivered message (one having the redelivered flag set) if it needs to. For subsequent redeliveries the delay semantics kick in. This was implemented in https://issues.apache.org/activemq/browse/AMQ-1032
hence this is working as designed, Fix implemented in r982903

initialRedeliveryDelay is not respected, set it to 0 to have immediate redelivery. Additional deliveryDelay (default  = 1000) which controls subsequent redelivery delay if initialRedeliveryDelay==0, going to fix this, make it configurable, done]