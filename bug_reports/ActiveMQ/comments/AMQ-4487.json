[Hi, Please provide a fix for this issue., Hi Subathra, could you provide a bit more information about the issue? Any idea how many messages is in the queue? What are the conditions to reproduce it?
Thanks!, Hi Jaromir,

We are not able to browse the queues if the messages are near to 100.

When we click a queue with more than 100 messages in it, we end up in java heap space error.

Thanks,
Subathra., Hi; Another thread same problem: https://issues.apache.org/jira/browse/AMQ-4372

, Has anyone managed to look into this please? We have had to upgrade to active mq 5.8 due to the persistent DB locking problem with lease time with 5.7. After upgrading to 5.8, the DB locking issue was resolved, however, this problem of not being able to browse messages more than 99 in queue is causing a huge problem for us, anyone? Please assist...., Does not happen on 5.7. Tested on 1.6 and 1.7 JDK.

If you click on 'active consumers' in the console when this is happening, you can see an enormous amount of enqueue and dequeues from the MQ host itself which seems to eat the box.

A few more details on our setup;

ActiveMQ 5.8.0, Running on Java 1.6.x
Backend Storage is Multi-Master Percona 5.5.x
, Can you please provide us an update on this issue.
, What's the size of your messages?
Have you tried on a 5.9 SNAPSHOT?

, I have same issue with 5.8.0. I checked the heap dump and debugged the web console, hope this will help to fix it. Please provide an update.

In the heap dump I found an instance of VMPendingMessageCursor holding 18+ millions of PendingNode elements (the queue had actually just two hundreds message). 

I did debugging - the method Queue.iterate() is repeated in an endless loop.

In first run it adds 200 messages to the browser. The second run should normally add no new messages and remove the browserDispatch from the browserDispatches. However this does not happen 
- the if (!node.isAcked() && !browser.getPending().getMessageAudit().isDuplicate(node.getMessageId()))  returns true again and messages are added again. 

The third run adds messages again and so on. Messages are added until OOM occurs.
I found it strange that method ActiveMQMessageAuditNoSync.isDuplicate() returns false in the second iteration and checked it. 

    public boolean isDuplicate(final MessageId id) {
        boolean answer = false;

        if (id != null) {
            ProducerId pid = id.getProducerId();
            if (pid != null) {
                BitArrayBin bab = map.get(pid);  << here the bab is null in the second iteration. why? it should been added in the first iteration
                if (bab == null) {
                    bab = new BitArrayBin(auditDepth);
                    map.put(pid, bab);           << here new entry is added to the map, but the size of keySet() is NOT increased!
                    modified = true;             << here  map.get(pid) returns a coorect value in the debugger. 
						 << However in the next iteration it returns null again...
                }
                answer = bab.setBit(id.getProducerSequenceId(), true);
            }
        }
        return answer;
    }
It looks like a collision in the map. Does ProducerId comes with a proper hashCode() and equals() methods? 

, Create a unit test that can reproduce the issue if possible. , Hello,
The issue is caused by too high number of different producers (>64). When the number of producers exceeds 64, it is not possible to use QueueBrowser for this queue.

Two problems cause the issue.
1. ActiveMQMessageAuditNoSync has a default max number of producers of 64. (field maximumNumberOfProducersToTrack)
When the actual number of producers exceeds this value, the isDuplicate() does not work anymore correctly and sometimes returns false instead of true. This leads to infinite loop in Queue.iterate method and thus to an out-of-memory situation. 
Ideally Queue.iterate() should recognize that the audit class does not work correctly and fail. For example the ActiveMQMessageAuditNoSync.isDuplicate can throw an exception if map is full.

2. It is not possible to increase the default max value via PolicyEntry. The PolicyEntry's configure() method does not populate MaxProducersToAudit to PrefetchSubscription ( sub.setMaxProducersToAudit(getMaxProducersToAudit()); is missing)
The PrefetchSubscription also does not populate the value to the underlying PendingMessageCursor .
     public void setMaxProducersToAudit(int maxProducersToAudit) {
         this.maxProducersToAudit = maxProducersToAudit;
+        if (pending!=null) {
+               pending.setMaxProducersToAudit(maxProducersToAudit);
+        }
     }

How can I create a unit test for the second issue?

regards,
ilya

, Simple reproducer (however, I am not sure it happens every time).
1/ I used default server config, except changing producerFlowControl to false
2/ I used activemq 5.3.2 tool to send 100k messages (used JMX to check number of messages)
java -classpath activemq-all-5.3.2.jar org.apache.activemq.benchmark.Producer tcp://localhost:61616 false TEST.FOO false 1
3/ I used activemq 5.3.2 tool to dequeue messages, still 9k messages in the queue (used JMX to check number of messages)
4/ I used the code below to browse messages - it slowed down over time with the jvm keeping doing full GC
I stopped after 100k iterations, on a queue with 9k messages...

import java.util.Date;
import java.util.Enumeration;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.QueueBrowser;
import javax.jms.Session;

import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.command.ActiveMQQueue;

public class QBrowse {
	ConnectionFactory connectionFactory;
	Connection connection;
	Session session;

	static public void main(String[] parms) throws JMSException {
		QBrowse qb = new QBrowse();
		qb.initCli();
		qb.oldestMsgInQueue("BENCHMARK.FEED0");
		qb.endCli();
	}

	public void initCli() throws JMSException {
		connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:61616");
		connection = connectionFactory.createConnection();
		connection.start();
		session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
	}

	public void endCli() throws JMSException {
		session.close();
		connection.close();
	}

	
	public void oldestMsgInQueue(String qname) throws JMSException{
		Queue q1= new ActiveMQQueue(qname );
		QueueBrowser br = session.createBrowser(q1,null);
		int iter = 0;
		Enumeration e = br.getEnumeration();
		while(e.hasMoreElements()){
			if((iter % 1000) == 0)
				System.out.println(iter);
			iter = iter+1;
			Message m = (Message) e.nextElement();
		}
		br.close();
		}
}
, Please also note that while browsing the queue, cpu went very high mainly comparing a message id with all the message ids from the OrderedPendingList (method org.apache.activemq.broker.region.cursors.OrderedPendingList.contains(..))

I have not read the whole server code, so I may be wrong, still:
- I do not see the relationship between the pending status of a message and the message browsing work
- while not having read all the code in detail (I may be wrong), I got huge performance improvments by rewriting the method:

  public boolean contains(MessageReference message)
  {
    if (message != null)
    	return map.containsKey(message.getMessageId());    	
    return false;
}

(but I still had that infinite loop and memory spike), activemq-unit-tests/src/test/java/org.apache.activemq.usecases.QueueBrowsingTest could be a good place to start if you want to try to and help by creating a real JUnit test case. , Please use following test case to reproduce the problem. The test case illustrates two problems: 
- it is not possible to use Web Console (and QueueBrowser) if a queue contains messages from more then *64* producers. The enumeration gives endless number of messages in the queue which causes out of memory in case of the Web Console.
- it is not possible to increase this threshold of 64 via PolicyEntry (the value does not get propagated properly to ActiveMQMessageAuditNoSync class). Check my comment 31/May/13 16:20 for a possible fix.


package org.apache.activemq.bugs;

import static org.junit.Assert.assertEquals;

import java.net.URI;
import java.util.Enumeration;

import javax.jms.Connection;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageProducer;
import javax.jms.QueueBrowser;
import javax.jms.Session;

import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.broker.BrokerService;
import org.apache.activemq.broker.TransportConnector;
import org.apache.activemq.broker.region.policy.PolicyEntry;
import org.apache.activemq.broker.region.policy.PolicyMap;
import org.apache.activemq.command.ActiveMQQueue;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Ilya Stepanov
 */
public class AMQ4487Test {

	private static final Logger LOG = LoggerFactory
			.getLogger(AMQ4487Test.class);

	private BrokerService broker;
	private URI connectUri;
	private ActiveMQConnectionFactory factory;

	@Before
	public void startBroker() throws Exception {
		broker = new BrokerService();
		TransportConnector connector = broker.addConnector("tcp://0.0.0.0:0");
		broker.deleteAllMessages();
		broker.start();
		broker.waitUntilStarted();
		connectUri = connector.getConnectUri();
		factory = new ActiveMQConnectionFactory(connectUri);
	}

	@After
	public void stopBroker() throws Exception {
		broker.stop();
		broker.waitUntilStopped();
	}

	@Test
	public void testBrowsing() throws JMSException {

		PolicyEntry policy = new PolicyEntry();
		policy.setQueue(">");
		policy.setMaxProducersToAudit(400);
		PolicyMap pMap = new PolicyMap();
		pMap.setDefaultEntry(policy);
		broker.setDestinationPolicy(pMap);

		int messageToSend = 370;

		ActiveMQQueue queue = new ActiveMQQueue("TEST");
		Connection connection = factory.createConnection();
		connection.start();
		Session session = connection.createSession(false,
				Session.AUTO_ACKNOWLEDGE);

		String data = "";
		for (int i = 0; i < 1024 * 2; i++) {
			data += "x";
		}

		for (int i = 0; i < messageToSend; i++) {
			Connection msg_connection = factory.createConnection();
			msg_connection.start();
			Session msg_session = msg_connection.createSession(false,
					Session.AUTO_ACKNOWLEDGE);
			MessageProducer msg_producer = msg_session.createProducer(queue);
			msg_producer.send(msg_session.createTextMessage(data));
		}

		QueueBrowser browser = session.createBrowser(queue);
		Enumeration enumeration = browser.getEnumeration();
		int received = 0;
		while (enumeration.hasMoreElements()) {
			Message m = (Message) enumeration.nextElement();
			received++;
			if (received > messageToSend)
				break;
		}

		browser.close();

		assertEquals(messageToSend, received);
	}

}






, Expanded the test case a bit, will look into it and get it fixed in v5.9.0, I've submitted the fix that allows for maxProducersToAudit to be configured which can help to work around the underlying issue.  We will still look for a better solution here though since we can't expect everyone to know how many producers they will have.  , Fixed on trunk, use the next v5.9.0 SNAPSHOT to test.]