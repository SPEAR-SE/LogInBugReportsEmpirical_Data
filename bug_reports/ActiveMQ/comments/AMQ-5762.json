[Have you done any profiling to narrow down what the leak is?  , Yep. We built a test harness off of the example based on the fusesource client. It is really straightforward - it creates a thousand connections and then cycles through closing them and opening them. We ran this test overnight several times on different versions of AMQ. After a 100 of cycles the memory heap was at 7Gb after the manually triggered GC. We also tested the hard close by killing the client app and restarting it as well as cutting off network by playing with firewall settings. This is where we got the 300K per close. We ran all of this on the out of the box AMQ config. The only change was we turned on thread pooling and configure nio. The same tests did not show any memory leaks on the openwire connections

I would be happy to share the test harness if it would help any., Thanks, it helps to know what client you are using.  I can probably whip up a test but if you want to contribute a unit test based reproducer we love contributions :)  Did you happen to look at the JVM with a tool like VisualVM or Yourkit to see what was holding the memory?  , Yep. We used JConsole (and VisualVM) I have a capture of the memory graph - it shows a steady growth. , Oh one more clarification - the test consists of connect with a certain clientID, subscribe to a topic with the name based on the clientID and then disconnect. I have the testharness to be placed here: https://github.com/Hill30/amq-tests. Currently the repo is a mess - there are several versions of the test harness all mashed together, but I have a guy bring some order to it., Was curious about which objects were taking up the memory, I will try and reproduce later on today and see what I can observe.  , I appreciate your involvement. This is really important for us. For now we can work around this problem by restarting AMQ overnight, but as the traffic and number of the clients grows..., The github links isn't working.  If you want to look at the ActiveMQ unit tests for MQTT we have bunch that use the FuseSource MQTT client that you can work off of to create a small unit test that captures your specific scenario.  Does the client connect to a Topic with an active producer or is everything pretty much idle at the time of connect / disconnect ?, My apologies - the repo was private, I just turned it into public. It is still messy though. And to answer your question - yes, it is idle, no messages are sent in or out. connect, subscribe, disconnect, that's it, So having looked at the tests you have so far I see some things right off that can account for memory climb.  The test is creating durable subscriptions to Topics, meaning that some data is going to be created for each that will be held until the durable subscription is removed.  Next the test creates a client that subscribes to a unique Topic on each iteration meaning that a new Topic is created for every client connection which will not go away on disconnect.  Given that I am not surprised with the results you are seeing.  , What you are saying is that the redundant subscribe creates the memory leak? I would expect that when the same client tries to subscribe once more to the same topic the subscription should be considered redundant and ignored. Anyway this is important info and we will run the test without the subscribe to confirm that this is the case. 

I also think that the extra 230K per hard close is still a concern. We will run a few more tests and I will keep you posted, Just sharing some thoughts based on initial look at the repo which is a little cluttered so I wasn't 100% sure what all was under test.  Would be nice to reduce the test to the simplest possible reproducer.  I created a simple unit test based on what I thought the code was attempting to do and did some profiling and didn't see anything that was surprising.  For a test case where the subscriptions are not durable and the broker had been configured to GC inactive destinations my memory remained fairly stable although it did look as though the MQTT FuseSource client was retaining memory for closed connections.  You might want to give the Paho MQTT client a shot in your testing.  , Unfortunately our use case requires durable subscriptions. 

We use MQTT to synchronize the data between our servers and multiple (up to 4000 at this time) mobile devices. We create a topic per device and every device connects to this topic with the clientID specific for the device. The specifics of the mobile connectivity demands to account for multiple disconnects and connection drops. 

I asked the code to be pared down to bare bones and will share it with you shortly. 

Also we ran another test overnight - no subscribe at all, just connect/disconnect on durable subscription, and the heap seems to be growing. I will keep you posted, Using durable subscriptions is of course perfectly valid.  We just need to narrow down the testing to determine if the behaviour you are seeing is just normal resource utilization or an actual problem.  , Here is the memory consumption chart from our latest test run https://github.com/Hill30/amq-tests/blob/master/mqtt_conncect-disconnect/memory_leak_example.png

The code for this particular run is here: https://github.com/Hill30/amq-tests/tree/master/mqtt_conncect-disconnect

As you can see the memory leak seems to be present, even though nothing is happening except connect/disconnect. Keep in mind that this test was ran on the same instance of ActiveMQ as our previous tests which did include subscribe to the topic, and the subscribe was done with QoS=2.

My guess for why we see the same result even though there is no subscribe is that it is because the session connect is attaching to is already there (clean session=false) and it has a reference to a durable topic created during previous test runs (when a topic was created in response to a subscribe with QoS=2)

We will re-run the test over a clean ActiveMQ installation and I will share the results, Please also share the broker configuration you are using to help match up your environment., Also, I'd recommend trying against the latest ActiveMQ 5.12-SNAPSHOT as that has a bunch of fixes.  , ok. It is official. We re-ran the same test over a clean instance of AMQ - no memory leak. https://github.com/Hill30/amq-tests/blob/master/mqtt_conncect-disconnect/no-leak.png. We will modify the test as follows:

1. connect
2. subscribe to a topic with QoS 2
3. disconnect
4. repeat
4.1 connect
4.2 disconnect

will keep you posted

 , Alright. I can share some results.

I created 2 versions of test harness a single file version and batch version. 

The single version (https://github.com/Hill30/amq-tests/tree/master/MQTTDisconnect) runs against a single topic repeats the following operations: connect to the topic, wait for connection, subscribe to the topic QoS=2, disconnect, wait for the disconnect.

The batch version (https://github.com/Hill30/amq-tests/tree/master/MQTTBatchDisconnect) for every connection on the list of 500 connections it creates a connection, and once it connects successfully it subscribes to the topic. After the process of creating connections is completed, it disconnects all of them. Then the process is repeated. 

Here is what I have discovered

1. The single file test did not reliably show any memory leaks. Several test runs of 100000 connect/subscribe/disconnect cycles show memory increase of 200 bytes per cycle, which may be just an inconsistency in the way heap size is measured.

2. The batch test shows memory leak of ~75K per connect/disconnect on 5.10.2 and ~35K per on 5.12 SNAPSHOT. The most puzzling part is that after the batch test has been run, all other tests (including the single file) start leaking at the same rate. This behavior continues even after broker restart.

On the side note, repeating subscribe for the session has no impact on the memory leak

You can examine the results of the test runs here: https://github.com/Hill30/amq-tests/blob/master/MQTTBatchDisconnect/src/com/hill30/AMQTests/runs.txt

AMQ configuration is taken out of the box - just unzipped and started, I tried your test cases against both a 5.12-SNAPSHOT and 5.11.2 build and see no leaks.  I believe that what you are seeing is the typical rise in heap usage that will continue until a GC cycle is run.  You can see this in action if you run your broker with a profiler attached such as VisualVM or YourKit and force a full GC, the memory will drop back to near your initial starting point each time.

I modified your batch connect client to run for 30 minutes for so and then on completion forced a GC and ended up back down around my starting usage point and each version.  , Well I am not sure what to tell you. In my case it is clearly a leak - every measure of the heap level I take I do so after forcing GC manually through the JConsole - several times. What platform you are running this on? I ran my tests on Mac OS. I will re run them on the Windows. 

Any chance we can do a webex so that I would share my setup with you?

I really need to get to the bottom of this. We do have a memory leak in our prod - that's why we started , Michael Feingold asked me to try MQTTBatchDisconnect program against ActiveMQ broker installed on a Windows Server. Broker version number installed on our test server is 5.10.2. I have used jconsole tool from JDK to look at heap during the the test. I ran application 5th times (each run creates 500x10=5000 MQTT connections with QOS subscription level 2). After each application run and manual GC ('Perform GC' button in jconsole) I can see that some amount of memory leaked (~150-200 MB per application run). I am going to attach ActiveMQ configuration files from the server and screenshot that was taken from jconsole. , I looks like we can consistently reproduce the memory leak in a variety of environments AMQ versions and configuration options.

A stupid though just occurred to me - when you were running my MQTTBatchDisconnect test - did you take it from github as is? If it so, the test was only running connect/disconnect scenario. On clean install thus scenario does not leak. 

My initial intent was to run the test from a command line with parameters, but then I grew lazy and set parameters directly in the code, currently in line 12. The checked in version of the test sets the QoS to "none", so there is no call to subscribe during the test. The test runs with the leak have the second parameter set to "2". I will modify the code in the repo for your convinience, heapdumps comparison, I believe I know what's going on. It looks like every time a connection to any topic is closed, some memory is leaked. The amount of memory leaked is ~100b times number of currently existing durable topics. Therefore if the number of durable topics is low, the leak us so slow you can hardly see it. Also if connect/disconnect is happening only once in a blue moon - same thing. In my use case both are pretty high, so here we are.

I captured a few memory dumps while I was running my tests and they show that every time a connection is disconnected, for every durable topic there are 2 objects leaking - a hashmap and a linkedlist Node. You  can clearly see it in the heapdump compare screenshot (attached https://issues.apache.org/jira/secure/attachment/12732941/Screen%20Shot%202015-05-14%20at%202.06.02%20PM.png). Here is what I did:

1. on a clean install I created 2 durable topics via console
2. created a heapdump1
3. I ran a test connecting to the same topic and immediately disconnecting from it. The connect/dosconnect cyscle was repeated 50000 times.
4. another heapdump created

What you see in the picture is a comparison between the two. You can clearly see the 2 culprits., I've found the issue already, and have a patch going in soon.  I will let you know once I've finished testing and added committed the fix, you can then pull down the latest source from github and build or you can wait until a new SNAPSHOT build is done and run against that.  , That's great news, thank you. Let me know when it is ready, Added a fix to workaround the leak in KahaDB from the lookup of Durable subscriptions from an MQTT connection. , The 5.12-SNAPSHOT builds are available here but it will take a day or so for one that includes the fix to be run.

https://repository.apache.org/content/repositories/snapshots/org/apache/activemq/apache-activemq/5.12-SNAPSHOT/, Our tests confirm that there is no memory leaks on the patched version. Thank you. 

Do you know when we can expect the 5.12.0 release? Will the fix be rolled in the 5.10.x and/or 5.11.x?, I don't know of any firm plans for releases at this point, I think a 5.12 is worth considering soon given all the work we've done to harden it.  I did a merge back to 5.11.x for this fix in case you want to build your own version of 5.11.  It could go back to 5.10.x if someone wanted to do that also.  ]