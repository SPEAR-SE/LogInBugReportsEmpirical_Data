[The same BUG can be reproduced if AMQ is configured without journal and with JDBCPersistenceAdaptor. I've reproduced it with postgres JDBC.

If  JDBCPersistenceAdaptor is used in combination with journal, AMQ allows queuing of new 28 messages after every restart. Which is also wrong because messages are accumulated with each AMQ restart. This behavior is different then previously described case in which flow control allows infinite queuing after first restart.  Also I have checked table activemq_msgs in postgres and found that messages are really persisted and accumulated after first restart.  , Adding a bit to this report... The problem seems to be related to the fact that we're using persistent messages.  Furthermore, with persistent messages, we're getting (easily reproducible) lock-ups of producers.  When a producer gets throttled back by flow control, it ends up in waitForSpace() and it never returns (despite of consuming all the messages in its queue)., We ran into a different problem, but came across information that may shed light on the present problem.

We at mSpoke had a problem (with version 5.2.0, using topics and durable subscriptions) where all producers would lock up when we used producer flow control.  What's strange is that the producers were *not* explicitly waiting in ActiveMQMessageProducer in the call to producerWindow.waitForSpace().  Instead, the producers were blocked waiting for acks.  But the problem went away when we disabled producer flow control.  

As I traced through the ActiveMQ code to try to understand what might be happening, I found myself with two concerns:

(1) Possibly pertinent to Josip Gracin's observation above (11/3/08), I am concerned that the calculation of available flow-control-window is based on totalling the message sizes as measured by the producer and subtracting the message sizes as measured by the consumer (or at least by whatever ends up producing the ack).  But the code in org.apache.activemq.command.Message#getSize() is a bit complex; how sure are we that the same size will be reported across marshalling/unmarshalling operations and in different contexts?

(2) In trying to understand how enabling producer flow-control might have left the producer waiting forever for an ack that never came, I see fairly complex code in org.apache.activemq.broker.region.Topic#send that schedules a deferred ack when the topic is full.  I believe our consumers are functioning correctly (and indeed our whole system works once we disable producer flow-control), so I don't see how any topic remained full forever -- yet, our producers wound up waiting for acks forever.  So I am suspicious that the acks deferred by                   messagesWaitingForSpace.add(new Runnable() {...} may, under some circumstances, never get sent.
, We experienced this problem with ActiveMQ 5.3.0.
Today it seems to be fixed in 5.3.1-SNAPSHOT., No test case given to reproduce and commenter report issue is not seen in later build.  Should test against a new release and see if you still see the issue.]