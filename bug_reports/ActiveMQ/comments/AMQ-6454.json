[Program to reproduce the issue, What you describe does look like the correct behaviour w.r.t the java doc. 
For reference, broker side, messages are retained in the subscription that matches the consumer. On close, any unacked messages are replayed back to the queue for delivery to another consumer.
It looks like the close needs to be deferred till the session closes in this client ack case. That is the behaviour in a transaction. However we would need a new callback on the session to track this. Not a trivial fix but doable.
For your use case, is a transacted session an option?, Gary, thank you for the quick response.
I know that transacted session will work and it does, but in our case there is an explicit requirement to use a non-transacted JMS session.
By the way this sequence works for other JMS providers like IBM WebSphere MQ, OpenMQ and WebLogic.
Another issue here is acknowledge() returns successfully, which in general means that message was acknowledged on JMS server side.
, actually the fix may be a simple as deferring the close in this case, the session close will cleanup in any event. Will give the unit tests a whirl to see if this change breaks any existing use case., This essentially comes down to being able to do the following:
{code}
        consumer.close();
        message.acknowledge();
{code}
Deferring the close till the session closes makes this work but there are many tests that demo uses cases where close is expected to release un-acked messages. I think we can't break this expectation so it would need to be configurable (yet another option).
As an alternative, we can make message.acknowledge(); fail if the consumer is closed. This will ensure that the is no false positive from the acknowledge call.
Would that be sufficient for your use case?

, [~gtully], I've been watching this thread and my first thoughts were what you discovered, that things would break if this behavior changed.  I know I have written code that relies on this behavior (ie closing the consumer will cause redelivery without closing the session)

To me this use case seems a bit odd as a JMS session should not be shared across threads.  The spec is clear in that a session should be single threaded.  So having two different threads receive a message and then try to call acknowledge should be considered invalid anyways in my opinion based on the spec.

That seems to be the fundamental issue in this use case is the timing with the two threads.  If it was a single thread receiving and acknowledge then it could be written in such a way to always call acknowledge before closing.

So based on that, I would think having message.acknowledge() fail if a consumer was already closed being the best solution., Gary, I think having message.acknowledge() fail if a consumer was already closed can be considered as workaround, which prevents unexpected redelivery (in other words duplication of messages).

But this type of fix will not make behavior compliant to JMS specification.
You are right: JMS session should not be shared across threads.
But JMS specification explicitly states that method close() is the only method of message consumer and session, which can be called concurrently:
https://docs.oracle.com/javaee/7/api/javax/jms/MessageConsumer.html#close--
https://docs.oracle.com/javaee/7/api/javax/jms/Session.html#close--
That's why consumer.close() is frequently used from another thread to make consumer.receive() return. 

In the described use case both receive() and acknowledge() methods are invoked from the same thread. Method close() is invoked from another thread.
Therefore it is absolutely valid use case.

Thread1 : Message message = consumer.receive();
Thread2 : consumer.close();
Thread1: message.acknowledge();

I think that till the next major release of ActiveMQ some configuration option that will allow to switch to legacy behavior (or otherwise to the new behavior) would be acceptable solution for all ActiveMQ users., Yep, you are right about the close() call being allowed and I suppose now that I think about it that makes sense to be able to close a message listener or consumer. So based on the spec allowing the close() method to be called from another thread I do agree that this is in fact a valid use case.

I think the default behavior should just be message.acknowledge() will fail if the consumer was closed.  Then, depending on how much work it is to implement, a flag could also be added to allow the close to be deferred to the session close to change the behavior.  I'll let Gary comment on this as he has looked into it and knows better about the level of effort required to make these changes.

Whatever fix is done I can back port it to 5.14.x so that it will go into a 5.14.2 release., Commit e91f5c8062f81a76e6983c489bfd092ce4071480 in activemq's branch refs/heads/master from [~gtully]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=e91f5c8 ]

AMQ-6454 - ensure message.acknowledge throws if consumer has closed and message has been released broker side
, What would be a good name for the connection factory config option that ignores consumer.close for client or invdvidual ack mode such that session close is required to release the consumer and unacked messages? 

Here is one candidate:
 - ignoreConsumerCloseOnClientAck=true

I think it would default to false to preserve typical usage., Gary, will it be possible to specify this configuration option in "java.naming.provider.url" like "tcp://localhost:61616?option=value" when instantiation of JNDI initial context and connection factory is done in JMS provider independent way?

Will enabling of this option (deferred close) make consumer.receive() to return after consumer.close()?, yes, that would be in the intent. When the broker url is: host:port?jms ignoreConsumerCloseOnClientAck=true 
the close would be ignored, session close will call close on all consumers. Then the close check in the message.acknowledge would pass and the ack would work.]