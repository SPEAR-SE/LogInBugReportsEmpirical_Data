[The test case, which should demonstrate the {{Queue}} memory leak on {{indexOrderedCursorUpdates}} list, is added into attached {{JmsTransactionCommitFailureTest}} class (only java reflection is used for acquiring list size after unsuccessful send operations). Usage of {{LeaseLockerIOExceptionHandler}} has still same effect - {{ActiveMQsession.commit()}} is blocked., [~rkraus] thanks for the great test and analysis. I think you have identified the problem being the lack of work on the sync rollback. Am just wondering if the hash/equals of messageContext should be implemented such that indexOrderedCursorUpdates.remove() would be sufficient and am wondering about calling the completion in the rollback case, but it may be necessary for cleanup.
I will investigate some more. thanks again for the great bug report :-)
, Commit f96a20e831755505b31df2e14fd3266f74d5a149 in activemq's branch refs/heads/master from [~gtully]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=f96a20e ]

[AMQ-6891] apply fix and test from Radek Kraus with thanks. Pending cursor adds are now dropped on rollback
, It think your fix is on the money and the completion should be run. Thanks., Thank you for your time and confirmation my issue. Thanks for your great reaction time. 
But unfortunately, I think, that problem is more complex. IMHO the invocation of \{{rollbackPendingCursorAdditions(MessageContext)}} method only from \{{afterRollback()}} solves problem when JMS transaction is used - it is great. But the similar problem (entry is not removed from list) occurs even when JMS transaction is not used (I noted it in issue description too). The problem is, that in this situation the "rollback" method is not invoked at all. In this case exception handling in \{{doMessageSend(ProducerBrokerExchange, Message)}} doesn't contains remove action too. In normal flow (no exception), the method \{{tryOrderedCursorAdd()}} is invoked and remove operation is finally done by "standard" \{{doPendingCursorAdditions()}} method. 

{code}
void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException,
  ...
  try {
    //AMQ-6133 - don't store async if using persistJMSRedelivered
    //This flag causes a sync update later on dispatch which can cause a race
    //condition if the original add is processed after the update, which can cause
    //a duplicate message to be stored
    if (messages.isCacheEnabled() && !isPersistJMSRedelivered()) {
      result = store.asyncAddQueueMessage(context, message, isOptimizeStorage());
      result.addListener(new PendingMarshalUsageTracker(message));
    } else {
      store.addMessage(context, message);
    }
  } catch (Exception e) {
    // we may have a store in inconsistent state, so reset the cursor
    // before restarting normal broker operations
    resetNeeded = true;
    pendingSends.decrementAndGet();
    // !!! 
    // Here should be remove operation too, probably?
    //rollbackPendingCursorAdditions(messageContext);
    // !!!
    throw e;
  }

  ...

  if(tryOrderedCursorAdd(message, context)) {
    break;
  }
{code}

Yes it is my fault, because I didn't provide test case for this situation (send message without JMS transaction), sorry. I can extend my test class for this test case too. Sorry again., the non transacted case has this issue also. Most often store IOErrors would result in the broker stop. However there are cases where we want to let these error bubble back to the producers and in that case we still have leak in the non transacted case., Commit dd2572bcb1c3793a8a2fa19cc4fc88cc8481f96e in activemq's branch refs/heads/master from [~gtully]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=dd2572b ]

[AMQ-6891] test and fix non tx variant of this leak
, fixed up the non transacted path and reused the leak test, thanks.]