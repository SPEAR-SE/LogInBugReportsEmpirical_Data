[the problem relates to the number of consumers associated with a topic message send. If 10 consumers are present when the message is persisted, and 11 when the message is dispatched, the ack from the 11th will remove the message. redispatch to any of the others can then fail with the above exception.

With the AMQPersistenceAdapter, writes are batched, so the reference store is updated async. At the point of update, the reference store prepares the required acks for each subscriber in order to keep the message reference around till all subscribers have acked.
The problem arises when the consumer list is updated and another consumer (one that is not in the count that is persisted) gets the message. The set of subscribers used during dispatch is independent of the set persisted. This is a problem. The logic that sets up the acks based on the subscription list is at org.apache.activemq.store.kahadaptor.KahaTopicReferenceStore.addMessageReference(ConnectionContext, MessageId, ReferenceData)
One fix is to serialize dispatch with a flush to the store and with subscriber additions.I think this will lock up the dispatch logic quite a bit.

The logic in org.apache.activemq.store.kahadaptor.KahaTopicReferenceStore.acknowledgeReference(ConnectionContext, String, String, MessageId) can deal with no reference, the case where a message has not been persisted, but it cannot deal with the case of a persisted message and an additional subscriber. Adding the logic to not remove a reference if it is referenced from another subscription resolves the issue. , for 6.0 we may want to tie down the set of subscribers a topic message has and carry that with the message reference in some way so that it can be shared by dispatch and by any (possibly async) persistence mechanism. ]