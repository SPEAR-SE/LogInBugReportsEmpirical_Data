[I mentioned above that in my non-vmQueueCursor testcase "attempts to restart ActiveMQ hang right after kahadb journal recovery" when restarted. This happens with this vmQueueCursor as well. Here's the info:

$ bin/activemq
Java Runtime: Sun Microsystems Inc. 1.5.0_22 /opt/java5u22/jre
  Heap sizes: current=4992k  free=3984k  max=504896k
    JVM args: -Xmx512M -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dcom.sun.management.jmxremote -Dactivemq.classpath=/home/activemq_cluster/conf; -Dactivemq.home=/home/activemq_cluster -Dactivemq.base=/home/activemq_cluster
ACTIVEMQ_HOME: /home/activemq_cluster
ACTIVEMQ_BASE: /home/activemq_cluster
Loading message broker from: xbean:activemq.xml
 INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@f47bf5: startup date [Fri Apr 22 09:52:12 PDT 2011]; root of context hierarchy
 INFO | PListStore:/home/activemq_cluster/data/cluster_a/tmp_storage started
 INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[/home/activemq_cluster/data/kahadb]
 INFO | JMX consoles can connect to service:jmx:rmi:///jndi/rmi://localhost:7923/jmxrmi
 INFO | KahaDB is version 3
 INFO | Recovering from the journal ...
 INFO | Recovery replayed 2 operations from the journal in 0.028 seconds.
 INFO | ActiveMQ 5.4.2 JMS Message Broker (cluster_a) is starting
 INFO | For help or more information please see: http://activemq.apache.org/

--- HANGS HERE ---

kahadb directory has same contents as above, and du -sh shows it still consuming 129M.


---------

Full thread dump Java HotSpot(TM) Server VM (1.5.0_22-b03 mixed mode):

"Topic  ActiveMQ.Advisory.Expired.Queue.orchestrationResponse" daemon prio=1 tid=0x088978d8 nid=0x2d22 in Object.wait() [0x890f0000..0x890f1080]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x917bf4d0> (a java.lang.Object)
        at java.lang.Object.wait(Object.java:474)
        at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:105)
        - locked <0x917bf4d0> (a java.lang.Object)
        at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)

"Topic  ActiveMQ.Advisory.MessageDLQd.Queue.orchestrationResponse" daemon prio=1 tid=0x08894428 nid=0x2d21 in Object.wait() [0x89171000..0x89172100]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x917bf5d0> (a java.lang.Object)
        at java.lang.Object.wait(Object.java:474)
        at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:105)
        - locked <0x917bf5d0> (a java.lang.Object)
        at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)

"Queue:orchestrationResponse" daemon prio=1 tid=0x08d2fd30 nid=0x2d1f in Object.wait() [0x894f8000..0x894f8d80]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x911c1e58> (a java.lang.Object)
        at java.lang.Object.wait(Object.java:474)
        at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:105)
        - locked <0x911c1e58> (a java.lang.Object)
        at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)

"ActiveMQ Broker[cluster_a] Scheduler" daemon prio=1 tid=0x092ca540 nid=0x2d1d in Object.wait() [0x891f2000..0x891f2e00]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x91047800> (a java.util.TaskQueue)
        at java.lang.Object.wait(Object.java:474)
        at java.util.TimerThread.mainLoop(Timer.java:483)
        - locked <0x91047800> (a java.util.TaskQueue)
        at java.util.TimerThread.run(Timer.java:462)

"ActiveMQ Data File Writer" daemon prio=1 tid=0x092ca8c8 nid=0x2d1c in Object.wait() [0x89273000..0x89273e80]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x91047a90> (a org.apache.kahadb.journal.DataFileAppender$1)
        at java.lang.Object.wait(Object.java:474)
        at org.apache.kahadb.journal.DataFileAppender.processQueue(DataFileAppender.java:325)
        - locked <0x91047a90> (a org.apache.kahadb.journal.DataFileAppender$1)
        at org.apache.kahadb.journal.DataFileAppender$2.run(DataFileAppender.java:216)

"ActiveMQ Journal Checkpoint Worker" daemon prio=1 tid=0x089b6500 nid=0x2d1b waiting on condition [0x89f8d000..0x89f8df00]
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:118)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:716)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:746)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1076)
        at java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync.wlock(ReentrantReadWriteLock.java:342)
        at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:637)
        at org.apache.activemq.store.kahadb.MessageDatabase.checkpointCleanup(MessageDatabase.java:690)
        at org.apache.activemq.store.kahadb.MessageDatabase$3.run(MessageDatabase.java:293)

"KahaDB Scheduler" daemon prio=1 tid=0x092c9410 nid=0x2d1a in Object.wait() [0x8977d000..0x8977df80]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x91047d28> (a java.util.TaskQueue)
        at java.util.TimerThread.mainLoop(Timer.java:509)
        - locked <0x91047d28> (a java.util.TaskQueue)
        at java.util.TimerThread.run(Timer.java:462)

"RMI LeaseChecker" daemon prio=1 tid=0x08b66310 nid=0x2d17 waiting on condition [0x893f6000..0x893f7100]
        at java.lang.Thread.sleep(Native Method)
        at sun.rmi.transport.DGCImpl$LeaseChecker.run(DGCImpl.java:310)
        at java.lang.Thread.run(Thread.java:595)

"RMI RenewClean-[10.4.64.66:37218]" daemon prio=1 tid=0x08cb7720 nid=0x2d15 in Object.wait() [0x89477000..0x89477e00]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x910d8040> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:120)
        - locked <0x910d8040> (a java.lang.ref.ReferenceQueue$Lock)
        at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:501)
        at java.lang.Thread.run(Thread.java:595)

"GC Daemon" daemon prio=1 tid=0x091aa2a0 nid=0x2d12 in Object.wait() [0x895fa000..0x895faf80]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x91124278> (a sun.misc.GC$LatencyLock)
        at sun.misc.GC$Daemon.run(GC.java:100)
        - locked <0x91124278> (a sun.misc.GC$LatencyLock)

"RMI Reaper" prio=1 tid=0x08c7f9c0 nid=0x2d11 in Object.wait() [0x8967b000..0x8967c000]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x90b3e2b0> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:120)
        - locked <0x90b3e2b0> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:136)
        at sun.rmi.transport.ObjectTable$Reaper.run(ObjectTable.java:336)
        at java.lang.Thread.run(Thread.java:595)

"RMI TCP Accept-0" daemon prio=1 tid=0x092fe4e8 nid=0x2d10 runnable [0x896fc000..0x896fd080]
        at java.net.PlainSocketImpl.socketAccept(Native Method)
        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:384)
        - locked <0x9111bf78> (a java.net.SocksSocketImpl)
        at java.net.ServerSocket.implAccept(ServerSocket.java:450)
        at java.net.ServerSocket.accept(ServerSocket.java:421)
        at sun.rmi.transport.tcp.TCPTransport.run(TCPTransport.java:340)
        at java.lang.Thread.run(Thread.java:595)

"RMI TCP Accept-7923" daemon prio=1 tid=0x0907ab00 nid=0x2d0e runnable [0x897fe000..0x897fed80]
        at java.net.PlainSocketImpl.socketAccept(Native Method)
        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:384)
        - locked <0x910d39b0> (a java.net.SocksSocketImpl)
        at java.net.ServerSocket.implAccept(ServerSocket.java:450)
        at java.net.ServerSocket.accept(ServerSocket.java:421)
        at sun.rmi.transport.tcp.TCPTransport.run(TCPTransport.java:340)
        at java.lang.Thread.run(Thread.java:595)

"RMI TCP Accept-0" daemon prio=1 tid=0x0866f760 nid=0x2d0c runnable [0x8be34000..0x8be34e80]
        at java.net.PlainSocketImpl.socketAccept(Native Method)
        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:384)
        - locked <0x90c192a8> (a java.net.SocksSocketImpl)
        at java.net.ServerSocket.implAccept(ServerSocket.java:450)
        at java.net.ServerSocket.accept(ServerSocket.java:421)
        at sun.management.jmxremote.LocalRMIServerSocketFactory$1.accept(LocalRMIServerSocketFactory.java:31)
        at sun.rmi.transport.tcp.TCPTransport.run(TCPTransport.java:340)
        at java.lang.Thread.run(Thread.java:595)

"Timer-0" daemon prio=1 tid=0x0866d9b0 nid=0x2d0b in Object.wait() [0x8beb5000..0x8beb5f00]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x90c19368> (a java.util.TaskQueue)
        at java.lang.Object.wait(Object.java:474)
        at java.util.TimerThread.mainLoop(Timer.java:483)
        - locked <0x90c19368> (a java.util.TaskQueue)
        at java.util.TimerThread.run(Timer.java:462)

"Low Memory Detector" daemon prio=1 tid=0x08609be0 nid=0x2d0a runnable [0x00000000..0x00000000]

"CompilerThread1" daemon prio=1 tid=0x08608800 nid=0x2d09 waiting on condition [0x00000000..0x8c07d228]

"CompilerThread0" daemon prio=1 tid=0x08607880 nid=0x2d08 waiting on condition [0x00000000..0x8c0fe2a8]

"AdapterThread" daemon prio=1 tid=0x086068d0 nid=0x2d07 waiting on condition [0x00000000..0x00000000]

"Signal Dispatcher" daemon prio=1 tid=0x08605990 nid=0x2d06 waiting on condition [0x00000000..0x00000000]

"Finalizer" daemon prio=1 tid=0x085fb210 nid=0x2d05 in Object.wait() [0x8c5f3000..0x8c5f3e00]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x90bd9468> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:120)
        - locked <0x90bd9468> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:136)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)

"Reference Handler" daemon prio=1 tid=0x085fab78 nid=0x2d04 in Object.wait() [0x8c674000..0x8c674e80]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x90bd5ba0> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:474)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)
        - locked <0x90bd5ba0> (a java.lang.ref.Reference$Lock)

"main" prio=1 tid=0x0851b0c0 nid=0x2cf8 waiting on condition [0xbfb20000..0xbfb222a8]
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:118)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:716)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:746)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1076)
        at java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync.wlock(ReentrantReadWriteLock.java:342)
        at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:637)
        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:886)
        at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:833)
        at org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand.visit(KahaRemoveMessageCommand.java:220)
        at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:825)
        at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:751)
        at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeMessage(KahaDBStore.java:378)
        at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.removeAsyncMessage(KahaDBStore.java:350)
        at org.apache.activemq.store.kahadb.KahaDBTransactionStore.removeAsyncMessage(KahaDBTransactionStore.java:457)
        at org.apache.activemq.store.kahadb.KahaDBTransactionStore$1.removeAsyncMessage(KahaDBTransactionStore.java:171)
        at org.apache.activemq.broker.region.Queue.acknowledge(Queue.java:797)
        at org.apache.activemq.broker.region.Queue.removeMessage(Queue.java:1527)
        at org.apache.activemq.broker.region.Queue.removeMessage(Queue.java:1519)
        at org.apache.activemq.broker.region.Queue.messageExpired(Queue.java:1584)
        at org.apache.activemq.broker.region.Queue.messageExpired(Queue.java:1574)
        at org.apache.activemq.broker.region.Queue$5.recoverMessage(Queue.java:283)
        at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore$4.execute(KahaDBStore.java:472)
        at org.apache.kahadb.page.Transaction.execute(Transaction.java:728)
        at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore.recover(KahaDBStore.java:464)
        at org.apache.activemq.store.ProxyMessageStore.recover(ProxyMessageStore.java:52)
        at org.apache.activemq.broker.region.Queue.initialize(Queue.java:269)
        at org.apache.activemq.broker.region.DestinationFactoryImpl.createDestination(DestinationFactoryImpl.java:86)
        at org.apache.activemq.broker.region.AbstractRegion.createDestination(AbstractRegion.java:473)
        at org.apache.activemq.broker.jmx.ManagedQueueRegion.createDestination(ManagedQueueRegion.java:56)
        at org.apache.activemq.broker.region.AbstractRegion.addDestination(AbstractRegion.java:123)
        - locked <0x91155e68> (a java.lang.Object)
        at org.apache.activemq.broker.region.RegionBroker.addDestination(RegionBroker.java:298)
        at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)
        at org.apache.activemq.advisory.AdvisoryBroker.addDestination(AdvisoryBroker.java:157)
        at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)
        at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)
        at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)
        at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:145)
        at org.apache.activemq.security.AuthorizationBroker.addDestination(AuthorizationBroker.java:81)
        at org.apache.activemq.broker.MutableBrokerFilter.addDestination(MutableBrokerFilter.java:151)
        at org.apache.activemq.broker.region.AbstractRegion.start(AbstractRegion.java:95)
        at org.apache.activemq.broker.region.RegionBroker.start(RegionBroker.java:198)
        at org.apache.activemq.broker.jmx.ManagedRegionBroker.start(ManagedRegionBroker.java:106)
        at org.apache.activemq.broker.BrokerFilter.start(BrokerFilter.java:157)
        at org.apache.activemq.broker.BrokerFilter.start(BrokerFilter.java:157)
        at org.apache.activemq.broker.TransactionBroker.start(TransactionBroker.java:109)
        at org.apache.activemq.broker.BrokerFilter.start(BrokerFilter.java:157)
        at org.apache.activemq.broker.BrokerFilter.start(BrokerFilter.java:157)
        at org.apache.activemq.broker.BrokerService$3.start(BrokerService.java:1781)
        at org.apache.activemq.broker.BrokerService.start(BrokerService.java:489)
        at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:60)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:592)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1536)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1477)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1409)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)
        - locked <0x90bd3550> (a java.util.concurrent.ConcurrentHashMap)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:574)
        - locked <0x90bd3858> (a java.util.concurrent.ConcurrentHashMap)
        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)
        - locked <0x90bd7120> (a java.lang.Object)
        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)
        at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)
        at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:117)
        at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:115)
        at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:71)
        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)
        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)
        at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:115)
        at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:74)
        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)
        at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:143)
        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)
        at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:85)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:592)
        at org.apache.activemq.console.Main.runTaskClass(Main.java:251)
        at org.apache.activemq.console.Main.main(Main.java:107)

"VM Thread" prio=1 tid=0x085f86f0 nid=0x2d03 runnable 

"GC task thread#0 (ParallelGC)" prio=1 tid=0x08535ad0 nid=0x2cff runnable 

"GC task thread#1 (ParallelGC)" prio=1 tid=0x08536720 nid=0x2d00 runnable 

"GC task thread#2 (ParallelGC)" prio=1 tid=0x08537358 nid=0x2d01 runnable 

"GC task thread#3 (ParallelGC)" prio=1 tid=0x08537f90 nid=0x2d02 runnable 

"VM Periodic Task Thread" prio=1 tid=0x0852cfe8 nid=0x2d0d waiting on condition 
, With some additional testing we were also able to hit AMQ-3120.

We decided to give ActiveMQ 5.5.0 a try, but with the exact same config we were using in 5.4.2 we hit an OutOfMemory within a few minutes. Max heap is 512M, mem store is 256M.

Exception in thread "ConcurrentQueueStoreAndDispatch" java.lang.OutOfMemoryError: Java heap space
        at org.apache.activemq.util.DataByteArrayOutputStream.ensureEnoughBuffer(DataByteArrayOutputStream.java:249)
        at org.apache.activemq.util.DataByteArrayOutputStream.writeBoolean(DataByteArrayOutputStream.java:140)
        at org.apache.activemq.openwire.v6.BaseDataStreamMarshaller.looseMarshalByteSequence(BaseDataStreamMarshaller.java:628)
        at org.apache.activemq.openwire.v6.MessageMarshaller.looseMarshal(MessageMarshaller.java:296)
        at org.apache.activemq.openwire.v6.ActiveMQMessageMarshaller.looseMarshal(ActiveMQMessageMarshaller.java:111)
        at org.apache.activemq.openwire.v6.ActiveMQTextMessageMarshaller.looseMarshal(ActiveMQTextMessageMarshaller.java:111)
        at org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:166)
, Attached jms.java - producer testcase. Typically running 5 of these in a loop in parallel. This derived from some JMS sample code found somewhere out on the 'net., Attached configuration - activemq.xml, Hi Scott, lots of info and different scenarios.

Lets first concentrate on 5.5. You need to configure a destination memory limit to limit the cache for the default store cursor.

<policyEntry queue=">" memoryLimit="256mb" >

That will avoid the OOM for persistent messages., Thanks, that was a piece we were missing, but it doesn't seem to help - within a few minutes, I was able to hit OOM with a 512MB heap in just a couple of minutes with my test program. Increasing the ActiveMQ heap to 1024MB seems to be OK, but that's not the point - I would expect this case to be stable with a 512MB heap and 256MB limits for memstore and per-destination policy for ">".

Stack trace:

Exception in thread "ActiveMQ Broker[cluster_a] Scheduler" java.lang.OutOfMemoryError: Java heap space
        at org.apache.activemq.protobuf.BaseMessage.mergeFramed(BaseMessage.java:228)
        at org.apache.activemq.store.kahadb.MessageDatabase.load(MessageDatabase.java:825)
        at org.apache.activemq.store.kahadb.KahaDBStore.loadMessage(KahaDBStore.java:955)
        at org.apache.activemq.store.kahadb.KahaDBStore$KahaDBMessageStore$5.execute(KahaDBStore.java:493)
        at org.apache.kahadb.page.Transaction.execute(Transaction.java:728)

Sorry for the disparate scenarios - we are trying to find one configuration that will result in a reliable and stable configuration..., Hey Scott! I am facing the same problem, but the difference is that I just send an byte message (around 100MB), and the "OutOfMemoryError" be thrown, the following situation is just like you said. I was thinking is that really a bug? or we have to tune the configuration for AMQ. Because if we really want to send large messages, blob or stream message can be used. Did you try to send blob message?, Sorry, I don't really know Timothy. At my last job we switched back from ActiveMQ to our previous JMS provider due to issues, and at my current job we'll likely switch to something else soon, as ActiveMQ doesn't do well under high load in large systems. Good luck!, On the OOM, I gave your test case a whirl with trunk, the broker does go steady state at about 200MB but the problem is that it peaks to more than 600MB until GC kicks in.
The vm stack should be 3*the memory usage limit if we are expecting to max it out in normal operation. More aggressive GC would reduce that.
The broker does need resources because it pulls messages from a network, keeps them in memory and stores them to disk. There are a bunch of memory allocations that are gc candidates overtime, but there can be large peaks short term as both the marshalled and unmarshalled state are present in memory at some stages.

The store cursor is best in general. The vmcursor will try and reply messages from the store on restart so if an OOM was the cause of a stop, it will again occur on a restart.
The default store cursor will keep messages in memory up to its configured limit. 


That hang on start is resolved on trunk, recovery now takes out a write lock from the start. see: https://issues.apache.org/jira/browse/AMQ-3357

Scott: were there other load related issues that you encountered?
If you can find them with a 5.6-SNAPSHOT, they will be a priority.
, The test case works on trunk as expected, but yes, the broker does need decent heap resources to deal with spikes.
In the order of 3*the system usage to be safe for this use case with expiry processing etc.

Additional hang issue resolved with:
https://issues.apache.org/jira/browse/AMQ-3357]