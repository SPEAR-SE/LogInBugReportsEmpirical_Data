[[~gtully] and [~tabish121],

I have attached a test that shows the Queue case breaking.  I think it will also break for durables in certain conditions.  One easy solution is to change line 1416 in MessageDatabase (the warning log message) to {{this.updateIndex(tx, command, location);}} and simply add the message if it can't find it.  However, this is probably not desirable in all cases as I'm guessing there are times when the update should be rejected (such as after an ack).  Another solution is to not garbage collect the original journal file that contains the add command, however then that would lead to having more journal files laying around that couldn't be garbage collected., Added a test that shows this in effect using the persistJMSRedelivered policy since that is the place you'd most likely see this happening.  , It should add the message if it cannot be found. It is expected that the original gets gced because it is no longer indexed. The update should aim to add or replace., Thanks for the input Gary, I will create a patch and include Tim's test., Commit b4aa53d806570a4f054dc0af9cb095f13b914153 in activemq's branch refs/heads/master from [~cshannon]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=b4aa53d ]

https://issues.apache.org/jira/browse/AMQ-6133

Fixing the processing of KahaUpdateMessageCommand to add the message to
the store if it doesn't exist, instead of ignoring it.  This will
prevent message loss in certain cases when the KahaDB index has to be
rebuilt.
, Commit adc3ba49c2cfb739ad7619a3aa7c5b518de5c996 in activemq's branch refs/heads/activemq-5.13.x from [~cshannon]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=adc3ba4 ]

https://issues.apache.org/jira/browse/AMQ-6133

Fixing the processing of KahaUpdateMessageCommand to add the message to
the store if it doesn't exist, instead of ignoring it.  This will
prevent message loss in certain cases when the KahaDB index has to be
rebuilt.

(cherry picked from commit b4aa53d806570a4f054dc0af9cb095f13b914153)
, Patch and test submitted by [~tabish121] applied to master and 5.13.x., I'm seeing a race condition issue here where some duplicate messages end up in the store. The issue occurs when persistJmsRedelivered is turned on for a Queue and concurrentStoreAndDispatchQueues is used.

What I'm seeing is that when rapidly producing/consuming, after a consumer gets all of the messages, sometimes the message reappears.  The cause seems to be that sometimes the message has been acked by the consumer and removed after it has been added to the store but before the update command runs (to set the redelivered flag).  So what happens with this fix is that at the end it will try to update a non-existent message so it will end up re-adding it.

In a test on my machine with 1 producer/consumer rapidly producing and consuming 50k messages, at the end of the test I consistently see 10-20 messages left over in the store even though the consumer has already received them all.  

I'm investigating more now to see if there is a good way to fix this without having to completely back out this patch., Actually, I think what is happening is that the update command is running first because it's not done async like the add message command.  So I think the fix might be to do the update command async as well, or maybe modify the original add message command if it hasn't been performed yet., hmm. I think concurrentStoreAndDispatchQueues is not compatible with persistJmsRedelivered. The point of persistJmsRedelivered is that the delivery count is persisted *before* dispatch which is not the case with concurrentStoreAndDispatchQueues.
One attribute is a policyEntry, the other on the PA, so it is not easy to enforce but the combination do not make sense.
Maybe the update is done async but we wait on the future, or we update the inflight write and wait on its future.
Either way, it may not be trivial and it may be more straightforward to document the incompatibility. The two features are working against each other.
To force them to coexist will impact both., Good points, and it may not make sense to change anything other than to document the behavior better as pointed out.  I'm testing out a couple things today to see what a fix would look like.  I was thinking one thing that might work would be to update the message that is part of the async task if the task hasn't started executing yet, else if it has executed then go through the normal update.  Not sure of any side effects of that approach yet though., [~gtully], After some testing, I agree with your assessment to do nothing.  Indeed it doesn't really make any sense to try and make the two features coexist.  One issue of trying to update a message async is then you can't guarantee that it was persisted before dispatch so you negate any benefits. And you already alluded to this when you mentioned the point is to persist before dispatch.  In fact, if anything, I'm seeing slower message rates with added synchronization from trying to do the update.

In the doMessageSend() method inside Queue where asyncAddQueueMessage() is called, do you think it makes sense to check there if the destination has persistJmsRedelivered enabled and if it does call addMessage() instead?  Or just leave it alone and document it?, [~cshannon]
I like that, isPersistJMSRedelivered is likely selectively used. 

In doMessageSend, {code}if (!isPersistJMSRedelivered())  && messages.isCacheEnabled()  {{code} 
guess the order of the checks could go either way :-)

that is safest as it enforces the persistJmsRedelivered semantic. , Sounds good, I'll update that and add a note to the documentation about it., Commit b2327db3b79dffd42fd5c6ba85720a5d9c302052 in activemq's branch refs/heads/master from [~cshannon]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=b2327db ]

https://issues.apache.org/jira/browse/AMQ-6133

Disabling async queue message store when persistJMSRedelivered is turned
on for a destination.  That flag will cause a sync update later on
dispatch which can cause a race condition if the original message add is
processed after the update.  This can cause a duplicate message to be
stored.
, Commit 8393e6b8ea6cb9953f54cec80df46b8c181c7e7f in activemq's branch refs/heads/activemq-5.13.x from [~cshannon]
[ https://git-wip-us.apache.org/repos/asf?p=activemq.git;h=8393e6b ]

https://issues.apache.org/jira/browse/AMQ-6133

Disabling async queue message store when persistJMSRedelivered is turned
on for a destination.  That flag will cause a sync update later on
dispatch which can cause a race condition if the original message add is
processed after the update.  This can cause a duplicate message to be
stored.

(cherry picked from commit b2327db3b79dffd42fd5c6ba85720a5d9c302052)
]