[My guess would be that the message is getting dispatched to two different transports at the same time and the amqp transport code that modifies headers and read the message body causes one to read the message while its in an invalid state.  

I made this change and now I can't reproduce the problem, still requires further investigation though to confirm that this is what's really happening.  

{code}
                    org.apache.activemq.command.Message message = null;
                    if (md.getMessage() != null) {
                        message = md.getMessage().copy();
                        if (!message.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {
                            message.setProperty(MESSAGE_FORMAT_KEY, 0);
                        }
                    }
                    final ActiveMQMessage jms = (ActiveMQMessage) message;
{code}, Hi Tim.  I applied your change, but AMQ4920Test still fails.  Did you change anything else?, It could still fail here since this really isn't synchronized.  I did also have the BytesMessage losing contents patch applied at the time as well.  , Kevin, can you test using the following patch and see if your test still fails.  

{noformat}
diff --git a/activemq-amqp/src/main/java/org/apache/activemq/transport/amqp/AmqpProtocolConverter.java b/activemq-amqp/src/main/java/org/apache/activemq/transport/amqp/AmqpProtocolConverter.java
index 893fa1b..06a4aa9 100644
--- a/activemq-amqp/src/main/java/org/apache/activemq/transport/amqp/AmqpProtocolConverter.java
+++ b/activemq-amqp/src/main/java/org/apache/activemq/transport/amqp/AmqpProtocolConverter.java
@@ -1134,7 +1137,7 @@
             consumerInfo.setNoRangeAcks(true);
             consumerInfo.setDestination(dest);
             consumerInfo.setPrefetchSize(100);
-            consumerInfo.setDispatchAsync(true);
+            consumerInfo.setDispatchAsync(false);
             if (source.getDistributionMode() == COPY && dest.isQueue()) {
                 consumerInfo.setBrowser(true);
             }
{noformat}, Sorry, still failing.  It looks like it's better, as now AMQ4920Test sometimes finishes, but most of the time it still fails.
, Do you have the fix for AMQ-4887 applied to your codebase right now, I've been unable to reproduce this issue after that fix plus changing the async dispatch flag to false.  , I have that installed, and AMQ4920Test is still failing for me.  I'll double check tomorrow and make sure I'm running all of the right code.
, Updated the test to fix a timing issue that could cause it to fail erroneously.  Maybe retry the async dispatch fix again to see if this was the failure you were seeing.  , Sorry, it's still failing for me.  I'll attach a log where I ran the test 50 times and got 16 failures.  After each failure I grepped for error messages, most of which look like:

2013-12-17 09:50:36,657 [pool-1-thread-4] - ERROR AMQ4930ConsumerTask            - consumer Consumer-3 expected 291 got message [topic]
or 
2013-12-17 09:49:32,429 [pool-1-thread-3] - ERROR AMQ4930ConsumerTask            - consumer Consumer-2 expected 646 got message [topic://AMQ4920Test1387270164946]
, Log from 50 iterations of AMQ4920Test
, I've added one fix that ensures that when dispatched to Topic consumers we don't do concurrent writes to the same Message object.  , [~kearls] I believe this is resolved now, can you confirm that and close this if you are satisfied that its fixed. , Is there a workaround for this bug. I am using qpid-java-amqp-1-0-client-jms-0.26 and still hit this error., Unfortunately there's no workaround in 5.9, you'd need to use a 5.10-SNAPSHOT., So essentially multiple topic consumers even running from different instances do not work. This pretty much makes publish-subscribe system unworkable since in any production environment you would have more than 1 subscriber to the same topic. Or is there any other way.?
Btw any idea when 5.10 is coming out.
Also is it the broker or client problem?]