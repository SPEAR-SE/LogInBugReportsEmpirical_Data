[I've noticed that the issue causes 'idle in transaction' problem on database. It happens if failover occurs when activemq attends in distributed transaction with other resources (databases). So some resources/locks are blocked forever on databases and that leads to hang of entire system.
*This bug is blocker for using AMQ in enterprise systems.* My advice is to avoid using of failover transport if AMQ is a part of XA transaction., With 5.14.5 I'm no longer seeing exactly above issue. Failover seems to work better.
Perhaps it's also due to upgrading the Spring framework from 3.2 to 4.3.
But there are some issues that I still need to look into in more detail, such as in-doubt transactions and duplicate messages.
, In my case it also occurs in 5.14.5. I use below configuration:
* JDBC persistence storage 
* master - slave 
* client uses failover protocol
* AMQ is part of XA transaction (2PC)

It leads to hang of entire application, because one of thread owns forever a lock:

java.lang.Thread.State: TIMED_WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        at org.apache.activemq.transport.failover.FailoverTransport.oneway(FailoverTransport.java:623)
        - locked <0x000000073ec21360> (a java.lang.Object)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68)
        at org.apache.activemq.transport.ResponseCorrelator.asyncRequest(ResponseCorrelator.java:81)
        at org.apache.activemq.transport.ResponseCorrelator.request(ResponseCorrelator.java:86)
        at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1388)
        at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1428)
        at org.apache.activemq.TransactionContext.setXid(TransactionContext.java:751)
        at org.apache.activemq.TransactionContext.invokeBeforeEnd(TransactionContext.java:424)
        at org.apache.activemq.TransactionContext.end(TransactionContext.java:408)
        at org.apache.geronimo.transaction.manager.WrapperNamedXAResource.end(WrapperNamedXAResource.java:61)
        at org.apache.geronimo.transaction.manager.TransactionImpl.endResources(TransactionImpl.java:588)
        at org.apache.geronimo.transaction.manager.TransactionImpl.endResources(TransactionImpl.java:567)
        at org.apache.geronimo.transaction.manager.TransactionImpl.beforePrepare(TransactionImpl.java:414)
        at org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:262)
        at org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:252)
        at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1020)
        at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:761)
        at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:730)
        at org.apache.aries.transaction.internal.AriesPlatformTransactionManager.commit(AriesPlatformTransactionManager.java:75)
        at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:245)
        at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1164)
        at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1156)
        at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1053)
        at java.lang.Thread.run(Thread.java:748), I have the similar issue AMQ-6888. I've create a small [application|https://github.com/leofromgroza/amq-failover-issue] that can be used for reproducing it., The sendTimeout is confined to message send commands.

these transaction related commands have a 0 timeout so they will block pending failover connection.

In these cases, the FailoverTransport configuration related to retries should be the answer.
{code:java}
startupMaxReconnectAttempts{code}
 and 
{code:java}
maxReconnectAttempts{code}
These should limit the reconnect thread and combined with the 
{code:java}
maxReconnectDelay, initialReconnectDelay, useExponentialBackOff, backOffMultiplier

 {code}
 let the connection failure bubble up to the application after some period.]