[Fixed with svn commit 1003096, by doing message group operations only if consumer is not full, We ran into this issue with one of our 5.4.1 AMQ instances in production.  We found that once all consumers are full, the remaining messages are all assigned to a single consumer.  When we reproduced this issue in test & stepped through the Queue class in AMQ, we found that this happens because the group logic is done before the full detection.

For example, we had 15 consumers with a prefetch size of 1 and a backlog of 1000 messages.  Each consumer had at least 1 message assigned to it & some had a few more than that (possibly finished processing the first message before all consumers were full).  Once all 15 consumers were full, the remaining 980 or so messages were assigned to the same consumer :(  This lead to a significant performance problem where we had all the work waiting on a single thread and the other 14 threads idle doing nothing.

We were able to work around this problem by setting the pre-fetch to 100 for our 15 consumers.   This allowed the messages to be dispatched in a  round-robin fashion for the first 1500 messages in the queue.

The fix above to only do group operations on non-full consumers should also resolve the effect we observed.]