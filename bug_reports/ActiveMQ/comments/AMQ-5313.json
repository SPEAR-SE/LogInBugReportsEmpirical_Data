[Log file showing a reconnection that does not resume issuing PullMessages., Log showing PullMessages do not return after handling a reconnect., After reading up on this, we have seen a similar problem, possibly?

http://activemq.2283324.n4.nabble.com/JMS-to-JMS-Bridge-Connection-td4684129.html
, I have read through the referenced JMS-to-JMS-Bridge-Conenction article, but I don't think it is related, although what is in common is it is triggered by a broken connection.  In this JIRA scope the reconnection is made successfully and remains connected as expected.  The connection can be explored with JMX on both the consumer and broker sides.  The only problem is the PullMessage command is never issued after the reconnect, so no actual messages are pulled.  The keepAlive=true option is used and the keepAlive commands are sent across the connection with no problem.  The root problem is something is intermittently not happening to establish the issuing of PullMessage commands after a reconnect , Narrowed problem down to the use a LinkedHashMap as a MessageCache in the ConsumerStateTracker class in ActiveMQ.  
The LinkedHashMap has a special method called removeEldestEntry that is called whenever a new entry is put into the HashMap.  In IBM JRE, this is called every time an entry is added to the HashMap, regardless if the key already exists or not.  In Oracle JRE, this method is only invoked if the key value being added is new (which in a polling config is always the same key for polling command).
When the removeEldestEntry is invoked and the external field currentCacheSize exceeds 128K, it would automatically remove the oldest entry in the list.  In ActiveMQ 5.9.0, the field currentCacheSize was being grown by 400 bytes for every polling call to a queue (so 1 per second) regardless of whether adding a new entry to the queue or not.  Once the currentCacheSize exceeded 128K (after about 6 mins), the removeEldestEntry method in the IBM JRE would start to remove the eldest entry which in a polling state was the entry just inserted (so the message cache would be 0 entries in size and when a disconnect occurs, it wouldn't replay the PullCommands that were needed to resume the polling).  In the Oracle JRE, the removeEldestEntry was not being invoked because the pullMessage command was not a new entry.
Regardless of the scenario above, a change was made in ActiveMQ 5.9.1 in that the currentCacheSize only grows by 400 bytes on the first poll, so, now the currentCache size only grows with additional polling consumers instead of after each poll.  Moving the ActiveMQ client to 5.9.1 will longer exhibit the issue with the Polling Consumer not resuming polling, as the removeEldestEntry will not remove the eldest entry until we exceed 320 polling consumers (as opposed to before, where it would remove the entry with just 1 entry in the cache after 6 mins of time)., A change was made in ActiveMQ 5.9.1 in that the currentCacheSize was only being grown by 400 on the first poll, so, now the currentCache size only grows with additional polling consumers instead of after each poll itself.  With this change, we should no longer exhibit the issue with the Polling Consumer not resuming polling, as the removeEldestEntry will not remove the eldest entry until we exceed 320 polling consumers (as opposed to before, where it would remove the entry with just 1 entry in the cache after 6 mins of time).
]