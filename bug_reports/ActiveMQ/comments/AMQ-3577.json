[One more comment, I was able to produce an OOM exception by creating a connection, interrupting the thread and calling the close method in a loop.  

You can see that the connection was never cleaned up properly and eventually the broker slows to a crawl because of the OOM.

With the patch, the broker keeps going without any issues.

The main difference is that the thread count is increasing without the fix and with it the thread count does not.

A simple workaround is that the user calls does the following:

{code}

   // This will clear the interrupted state to allow the connection to cleanup properly
   boolean interrupt = Thread.interrupted();

   connection.close();

   if (interrupted) 
     // This will reset the interrupt state for this thread.
     Thread.currentThread().interrupt();

{code}

, note: internally the broker should not be calling interrupt unless it catches an interrupted exception. But is should be able to handle interrupted exceptions as the occur in normal processing and continue if necessary., Agreed, but this is caused by the client not properly handling an interrupted thread.  The broker does not seem to get the request to close the connection which gives the broker the impression that the connection is still active on the client side when in fact it was closed.

You can see the problem by just doing the following:

  1 - create a connection
  2 - interrupt the thread
  3 - close the connection
  4 - repeat 1-3 over and over

open the jconsole and check the thread count on the broker.  it keeps increasing until you get an oom exception.
, This issue was fixed in trunk by Tim on the 29th of Oct.

The commit is http://svn.apache.org/viewvc/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/ActiveMQConnection.java?r1=1195044&r2=1195045&.

He applied the same scheme that I was using to resolve the issue.

Note that the InvalidClientIDException was a symptom of this.]