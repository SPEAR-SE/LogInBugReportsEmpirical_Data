[not sure about the validity of the test case here. I tried to reproduce using an existing test case and I get an exception because the temp destination is in use till the consumer is closed. so it is not possible to delete before the close; can you concur.
I see an exception in your test case also. In the exception case, the temp destination is not deleted at all!

see the simple code mod to TempQueueMemoryTest:
{code}
Index: activemq-core/src/test/java/org/apache/activemq/advisory/TempQueueMemoryTest.java
===================================================================
--- activemq-core/src/test/java/org/apache/activemq/advisory/TempQueueMemoryTest.java	(revision 704890)
+++ activemq-core/src/test/java/org/apache/activemq/advisory/TempQueueMemoryTest.java	(working copy)
@@ -37,7 +37,7 @@
     protected Connection clientConnection;
     protected Session clientSession;
     protected Destination serverDestination;
-    protected static final int COUNT = 2000;
+    protected static final int COUNT = 1; // 2000
 
     public void testLoadRequestReply() throws Exception {
         MessageConsumer serverConsumer = serverSession.createConsumer(serverDestination);
@@ -63,8 +63,9 @@
             msg.setJMSReplyTo(replyTo);
             producer.send(msg);
             Message reply = consumer.receive();
+            //consumer.close();
+            replyTo.delete();
             consumer.close();
-            replyTo.delete();
         }
         
         clientSession.close();
{code}, exception from your test case:
{code}
2008-10-15 15:16:10,551 [MQ Session Task] ERROR JmsMessageHandler              - Failed to delete reply queue ID:gtullyd810-51430-1224080169714-3:2:1
javax.jms.JMSException: A consumer is consuming from the temporary destination
	at org.apache.activemq.ActiveMQConnection.deleteTempDestination(ActiveMQConnection.java:1869)
	at org.apache.activemq.command.ActiveMQTempDestination.delete(ActiveMQTempDestination.java:51)
	at org.activemq.jms.JmsMessageHandler.forwardToNext(JmsMessageHandler.java:236)
	at org.activemq.jms.JmsMessageHandler.onMessage(JmsMessageHandler.java:167)
	at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1021)
	at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:122)
	at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:192)
	at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)
	at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
	at java.lang.Thread.run(Thread.java:595)
{code}, Maybe it's removed later by some other cleanup method?

The application, where I've found it is running in JBoss and I suppose JBoss keeps the open connection in a pool, so then the temporary destinations are not removed.

Problem is that it causes a difference between the master and the slave: on the master the queue is removed, but on the slave it still exists.
I can reproduce that with this code.

I don't have a problem with this issue anymore, because I've fixed our client code, but I suppose the same error will be made again and will keep causing headaches. (it was worse in our case, because the exception on the failing delete attempt was not logged)


, Remove the "reply.delete()" code entirely. It indeed does not matter.

The issue is that the TemporaryQueue is removed in the Master and not in the Slave.

If it would not be removed in the Master (until the Connection is closed) that would be okay., resolved in 705592.
Slave connection now knows about temp destinations so it can delete on close rather than just on an explicit delete command. It now behaves like the master in the absence of a tempDestination.delete call., These fixes will now make 5.2.0 rc3]