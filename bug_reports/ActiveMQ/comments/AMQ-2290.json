[Attached is a screenshot from our heap dump analysis showing the large number of entries in the LRUCache, does the 80 in that screenshot indicate the number of LRUCache instances? If so, what container are you running. There must be a bunch of classloaders in the mix that can result in multiple instances of that static member.
, Sorry, I should have captured the column headers as well. The 3 columns are: shallow heap (bytes), retained heap (bytes), and percentage. I don't believe there are multiple instances of the LRUCache itself in this case, however there are 650,113 entries in the map. , I believe the issue is due to the use of the non-thread-safe HashMap as the underlying collection. Wrapping it with Collections.synchronizedMap() should fix it. Attached is a patch which we will be testing soon. , ah, that makes some sense. Let us know the outcome of your tests and I will apply your patch. thanks., We've been hitting it with traffic for about 5 hours and it so far looks great. We previously saw memory consumption jump after just an hour or two. , patch applied with thanks, r786451]