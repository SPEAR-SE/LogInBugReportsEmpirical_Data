[I've found a way to reproduce the problem in activemq.  See activemq-ra/src/test/java/org/apache/activemq/ra/JmsXARollback2CxTransactionTest.java

The test testRepeatReceiveTwoThenRollback is currently renamed so it doesnt run.

rev 805881, David, not sure what the best plan of action is here.

I worked through the test case and the problem is that there are two sessions and two XAResources and only one of those sessions is associated with the active connection so only one of those sessions will behave as expected when a transaction is rolled back.
The test holds two connections and two XAResources and alternates the commit/rollback between them. I find that the second iteration of the test always fails.

There is an additional problem in that  the second session/connection has an outstanding transaction when it is closed, as a result of the outstanding transaction, the close is deferred till the transaction commits, which never happens, thus we see the problems with "javax.jms.InvalidClientIDException: Broker: localhost - Client: org.apache.activemq.test.JmsResourceProvider already connected from vm://localhost#4 on subsequent tests. 

My first though was that these connections should be presenting the same XAResource (somethng with isSameRM == true), Essentially an XAResoruce for the Broker. But it looks like the intention is that an XAResource maps to a session. Maybe this is the crux of the problem.

When dealing with the two sessions and XAResources, my thinking was that the test should be driving 2PC, but this does not work because the broker only sees one transaction branch and fails on a second prepare.

So I am thinking that the correct solution is to have a shared XAResource for the ResourceAdapter and have sessions just track the association. Not sure yet what all the ramifications are. What do you think?
, looks like http://svn.apache.org/viewvc/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/TransactionContext.java?view=log#rev581242 is relevant. That static could be the shared state we need., Making ENDED_XA_TRANSACTION_CONTEXTS static in TransactionContext makes the test pass for me.  This variable doesn't make any sense unless it's static, as otherwise the only possible TransactionContext in the list is "this".

I'm not thrilled with introducing a static, in an osgi environment it would be better to have a service, but it seems like the best solution in a non-osgi environment.

Unfortunately I'm seeing a new problem, apparently a race condition between closing a connection and starting a new connection and setting clientId.  Adding a Thread.sleep(10) to JmsTransactionTestSupport reconnect sidesteps this problem...

Tests run: 17, Failures: 0, Errors: 15, Skipped: 0, Time elapsed: 2.022 sec <<< FAILURE!
testReceiveTwoThenCloseConnection(org.apache.activemq.ra.JmsXARollback2CxTransactionTest)  Time elapsed: 1.124 sec  <<< ERROR!
javax.jms.InvalidClientIDException: Broker: localhost - Client: org.apache.activemq.test.JmsResourceProvider already connected from vm://localhost#8
	at org.apache.activemq.broker.region.RegionBroker.addConnection(RegionBroker.java:216)
	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:82)
	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:82)
	at org.apache.activemq.advisory.AdvisoryBroker.addConnection(AdvisoryBroker.java:77)
	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:82)
	at org.apache.activemq.broker.MutableBrokerFilter.addConnection(MutableBrokerFilter.java:89)
	at org.apache.activemq.broker.TransportConnection.processAddConnection(TransportConnection.java:686)
	at org.apache.activemq.command.ConnectionInfo.visit(ConnectionInfo.java:134)
	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:308)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:182)
	at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:109)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)
	at org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:205)
	at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:122)
	at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:43)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:651)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:676)
	at java.lang.Thread.run(Thread.java:613)
, static back in place and made the removeCommand sync in transport connection to kill race condition with starting a new connection with the same clientId.

revision: r811003]