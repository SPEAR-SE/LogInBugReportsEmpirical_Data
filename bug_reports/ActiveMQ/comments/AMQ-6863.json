[The attached test (TestCursors.java) reproduces the problem., As a workaround, with the default cursor,  it will respect the global memory limit for the broker.  broker.systemUsage.memoryUsage.limit and will stop caching messages in memory when it reaches 70% of that limit.

Typically the file cursor is only useful for non persistent messages. For durable subs, the message are already on disk, so there is little point in accepting them and writing them to disk again., Here is why we can only achieve what we want with a file cursor, despite the file cursor saving to disk twice:
We have a group of topics (let's call them LIMITED.TOPIC) with durable subscribers that we want to limit by policies. For example, we set a policy that these topics can only use 70% of storage so that other destinations can still use the broker even if LIMITED.TOPIC fills up storage up to the limit allowed by policy.
We can run into a situation, where a durable consumer disconnect. We are using a hub and spoke topology, so eventually when the consumer is disconnected for long enough the storage for both hub and the sending broker fills up, here is a picture:

spoke_broker(LIMITED.TOPIC:full) -> hub_broker(LIMITED.TOPIC:full)

In this situation, hub_broker has an inactive durable subscription from the disconnected consumer, but spoke_broker has an active subscription from hub_broker. Now spoke_broker will put messages from LIMITED.TOPIC into memory *up to the global limit* (as opposed to policy set high watermark). 
This results in a situation where spoke_broker cannot process any other messages because its memory is full.
The only way we were able to solve this is by using a file cursor which (I guess) respects policy watermarks. But the file cursor has the bug with message expiration., hmm, there is a broker attribute to disable retaining durable subs in memory... that may help.
broker.keepDurableSubsActive=false

also a durable sub has cursorMemoryHighWaterMark=70% by default, that can be reduced. That should limit what memory the durable subscriber uses for cached messages, make it 10% so even if it was the shared limit it would be 10% of that.

Attach your activemq.xml so the policy entries in play are visible., I have attached two tests:
*TestActiveSubscriptions* shows that if we set org.apache.activemq.broker.BrokerService#setKeepDurableSubsActive to false, then messages do not flow on durable topics. The test passes if the setting is back at the default "true".
*TestHighMemoryWatermark* shows how we would expect the highWatermark settings to work, i.e. when one topic hits its own watermark we can still send messages on another topic.

Let me know if there is something we are not setting correctly.

Thanks,
Tomas ]