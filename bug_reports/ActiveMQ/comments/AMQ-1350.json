[We've also expired this behavior on a 4.1.1 master/slave configuration using SQL-Server. The master has somehow lost the lock during a database maintance operation (we suspect some DB-admin killed the lock in order to be able to backup the database) and we ended up with two masters., Patch for this issue. You can now specify a keep-alive/check period for the lock on the database. If the lock is lost then the broker is shut down.
Example configuration:
    <persistenceAdapter>
        <jdbcPersistenceAdapter dataSource="#mysql-ds" lockKeepAlivePeriod="1000"/>
    </persistenceAdapter>

Detail content:
 - Expose the already existing lock (added getter and setter)
 - Fixed the startup of the PersistenceAdapter by the BrokerService. The configureService() method wasn't executed when configured via xml.
 - Fixed some smaller things within JDBCPersistence (mostly error handling stuff in the shutdown case)
 - Better handling of absent database-locking (configuration-flag). Introduced a NoLock-Locker to avoid having to check for the flag all over the place. 
 - Moved the INSERT-row into lock table from the database setup to the lock-aquire. Reason: This statement executed on the slave (db already locked) will block resulting in the missing "Attempting to acquire the exclusive lock to become the Master broker" message. (this fix is not directly related to this issue)

, Note that the patch will not try to reaquire the lock, it'll just check if nobody else holds the lock and shutdown in that case. We could also try to check if we still hold the lock and update it if neccessary. However I fear that doing a SELECT FOR UPDATE every x seconds will kill/slowdown the database because it'll result in 1000s of lock. Or does the database realize that we already have locked this thing and the statement is a no-op lockingwise? Also is there a portable way to check for a existing lock without being blocked in that case?, I did some further research on this topic. Here's what I'm going for:
  a) Lock something (f.e. the lock table) on startup
      + on success: goto b
      + else: try to lock until you succeed (repeat a)
  b) Start the broker and a keep alive thread (executed every x seconds -> c)
  c) Check if we still do hold the lock (and that the db is still there)
      + if we do: wait till next keepalive, then execute c)
      + else: d) 
   d) Shut down the broker because there's another master running

Now the tricky part of this idea is actually set c), because there's no possibility to express "go see if you can lock that row/table/whatever and return immediately if it's already locked" (something like a tryLockNoWait). There isn't even a standard way to express a lock-wait-timeout.
While it's possible to simulate a lock timeout (f.e. terminate the query after 5s and consider the table locked by another party) this is an unclean and IMO risky approach.

I can offer a solution for three database systems:
* MySQL: select get_lock("my_activemq_lock", 0); does exactly what I want to do. I doesn't use the lock-table.
* MS SQL-Server: select * from activemq_lock where id=1 with readpast would skip the row if it's locked without waiting, so we can look at the result count. The same should also be possible with an update statement.
* Oracle: Is supposed to have the same feature as sql-server although with a slightly different syntax. 

My research for a DB2 solution was without success, the others I didn't try yet.

Any feedback on this solution?, How About using DistributedLock from Jgroups to make the master/slave work? or something similar., the fix for https://issues.apache.org/activemq/browse/AMQ-1885 should help a bit here. The slave will retry and the master will fail in the event of a db outage. On db restart, the slave, still being alive, should become the master.
There is a [test case|http://svn.apache.org/viewvc/activemq/trunk/activemq-core/src/test/java/org/apache/activemq/broker/ft/JDBCQueueMasterSlaveTest.java?view=markup] with the change that may provide a template for a test case for this issue.
In your scenario it seems odd that there are two masters, this points to a problem with the lock statements for your test db. 
note the org.apache.activemq.store.jdbc.DefaultDatabaseLocker, which attempts to maintain an acquired lock by updating a table entry, it has a configurable lockKeepAlivePeriod.
Would it be possible to revisit your patch in the light of the current trunk., Yes, the patch for AMQ-1885 helps a lot, I've yet to encounter a situation where it fails to work. My patch was mostly about enabling the lockKeepAlivePeriod.

The only thing that does not work for me is a correct broker shutdown. The broker kinda quits itself but then gives a "failed to stop broker" and leaves the VM running. This is a bit annoying because we could just auto-restart the vm if it did terminate properly. This way we have to go through ugly log parsing and process killing in the shell script. My patch fixed the shutdown for the then-trunk, I was rather trivial to do (just catch&log/ignore some exceptions).

I propose to close this issue and open a new one regarding the failing broker shutdown (5.1) on db-failure [also happens when i.e. the transaction log is full].]