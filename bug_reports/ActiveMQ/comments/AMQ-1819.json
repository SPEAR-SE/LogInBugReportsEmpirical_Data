[made a small change to the TransportConnection.  I'm hoping that by sending the broker info async, we should be able to break this deadlock:

-                   this.processDispatch(connector.getBrokerInfo());
+                   dispatchAsync(connector.getBrokerInfo());


committed in rev 670045, I've seen this same deadlock: (version 5.0.0)

"ActiveMQ Session Task" prio=10 tid=0xa60ef800 nid=0xa0d waiting for monitor entry [0xa64d7000..0xa64d7ea0]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:39)
        - waiting to lock <0x4c8fbcd8> (a java.lang.Object)
        at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:59)
        at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1152)
        at org.apache.activemq.ActiveMQSession.asyncSendPacket(ActiveMQSession.java:1738)
        at org.apache.activemq.ActiveMQMessageConsumer.afterMessageIsConsumed(ActiveMQMessageConsumer.java:749)
        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:948)
        - locked <0x4c8f2960> (a java.lang.Object)
        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:122)
        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:192)
        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:118)
        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:42)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
        at java.lang.Thread.run(Thread.java:619)

Has this fix been tested? which release will this be available?
]