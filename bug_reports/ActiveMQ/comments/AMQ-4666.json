[This simple standalone test case will demonstrate the blocking situation.  Changing prefetch limit "prefetchLimitForAll" will just move the blocking point. Please try setting "patchApplied" to true to see how the workaround works., What's unexpected about this?  You set a limit on how much space messages can take up in a single destination, you send enough messages to reach/pass that limit, and the broker flow controls you until one or more of those messages are consumed.  This is all by design; where's the bug?, Have you read the problem description section at #4 in my original request? In short, why would all "persistent" message publishing are blocked by topic's shared memory limit which is only for non-persistent messages, unnecessarily??  That's the problem. , I overlooked your statement that you're using persistent messages; sorry about that.

Torsten's comment on Christian's post at http://www.christianposta.com/blog/?p=273 gives a detailed description of why you're seeing this, and of two work-arounds available to you (disabling per-destination memory limits and setting cursorMemoryHighWaterMark to a percentage that is less than the ratio of the per-destination memory limit to the entire-broker memory limit.  Hopefully one of those options is workable for you.

Both Christian's blog post and Torsten's comments make it clear that this is known and expected behavior.  That's not to say that that's the best possible way for it to work, or that the change you're requesting shouldn't be implemented; I think that it should, as long as the people who know this code well can assure themselves that it doesn't mess up anything else.  But it makes this an Improvement, not a Bug, so you should change the issue type to Improvement.

If you want it to have the best chance of getting implemented, I'd recommend you reword the title and description to focus on the improvement to be made, not the unwanted behavior that results from not making the change.  It also sounds like you're proposing changing the implementation of AbstractPendingMessageCursor.hasSpace(); is that right?  Since you have an implementation in mind, I'd encourage you to create and attach the patch you're proposing; an already-implemented patch is going to be the most likely to get implemented because it's the least work for whoever might take this on.]