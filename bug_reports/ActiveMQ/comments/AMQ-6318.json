[[~gtully] and [~tabish121],

I have noticed this filtering issue before when I was working on some policy stuff.  For example, I would expect the following code would work but it actually fails as the map returns a value which seems odd as the entry specifies a decendent and the value passed to get() doesn't have a descendent:
{code:java}
DestinationMap map = new DestinationMap();
map.put(new ActiveMQQueue("value.>"), "");
assertTrue(map.get(new ActiveMQQueue("value")) == null);
{code}

There's a comment on line 255 of the DestinationMapNode class which seems to indicate that this is intentional so I left it alone in the past but I wanted to see what you guys thought about this behavior as it doesn't seem right to me in this case., [~cshannon] I agree, it seems wrong but I guess it depends on if ANY_DESCENDENT included none. 
Given how long that code has been there my bet is changing it will cause some head ache for existing users.
Any internal dependency should fall out from the existing tests.

Note: * or ANY_CHILD will not match none, which makes sense.

{code}
        ActiveMQQueue queue = new ActiveMQQueue("value");
        DestinationMap map2 = new DestinationMap();
        map2.put(new ActiveMQQueue("value.>"), v1);
        assertEquals(1, map2.get(queue).size());

        map2 = new DestinationMap();
        map2.put(new ActiveMQQueue("value.*"), v1);
        assertEquals(0, map2.get(queue).size());
{code}, [~gtully], thanks for the input.  [~tabish121] and I discussed this a little bit a week or 2 ago and we came to the same conclusion about the existing user case being an issue.  

The only way I could see changing it would be to do fix it in a major release (like 5.14.0) and then try and document the change in the release notes.  But given how long the behavior has existed I'm not sure it would be worth the headache to change it at this point. ]