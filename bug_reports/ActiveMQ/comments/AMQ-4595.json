[Unit test code and output from a run with 10000 messages., For such a large Queue the destination policy needs to be updated to use a larger maxAuditDepth to avoid spinning as the audit rolls over. , Updated test case showing how to make this work on a 5.9 SNAPSHOT., Since the Queue depth exceeds the maxAuditDepth on the Queue the browse runs into the problem similar to AMQ-4487 which can be resolved by setting maxAuditDepth to some higher value.  Then you must also take into account that the browse will end when the memory limit is reached so you would need to configure a very large limit for this test case to get all 10,000 messages since they have a larger payload.  The updated test case shows how its done. , Hi Tim,

Do you mind explaining a bit more why maxAuditDepth needs to be raised in order to browse a higher number of messages? 
Also, I barely found any documentation on this property. Can we get it added to http://activemq.apache.org/per-destination-policies.html? 

Would the current behavior (when not setting maxAuditDepth) not rather be a bug? From a client's point of view should a queue browser not be used like an ordinary consumer and not require any broker side config changes? 
I am concerned that no ActiveMQ user will think of raising maxAuditDepth in order to browse more than the default 400 messages. This does not seem intuitive.

And finally I want to add that you also need to use version 5.9-SNAPSHOT as even the updated test case does not work with 5.8.0. I presume due to the fix that went in for AMQ-4487?
, The current behavior is definitely still a bug, however there are ways to work around it.  I'm pretty sure you could get around it by setting a lower memory limit in 5.8 so it doesn't page in so many messages but I didn't try that.  The fix in AMQ-4487 allows the audit settings to be set in the destination policy, previously they were being ignored. 

The problem is that the Message Audit that's don't to prevent the messages that are redispatched when not acked by a closed consumer from getting dropped into a browser a second time since they are read from the pending dispatch message list.  Since this list can grow quite long in this test case it exceeds the audit depth so we get into a loop since the messages in the list don't appear to be duplicates.  Its a flaw in the way Queue Browsers are designed currently.  It wasn't really an issue until we made the change to page in messages for browsers instead of limiting them to a single page.  , I think the simplest fix right now short of rewriting the Queue Browser code to have its own message cursor implementation is to just give each QueueBrowserSubscription it's own unbounded duplicate tracker so that we just let them browse until MemoryUsage limits are reached.  , We make extensive use of the QueueBrowser in our application (our app is similar to the activemq web console app where you can view all queues, connections, messages; and move messages between any 2 queues). So having a solution that does not require us to change a queue's configuration is important as we don't know queue names, message size or queue size before hand. 

I'm not all that familiar with the internals of AMQ, but in the old AMQ 4.0 series (we're upgrading from that series, btw), we would not have memory issues unless you browsed a *very* large queue (100000s messages). Upgrading the Queue Browser code would also benefit the activemq web console app, as anyone using that will also be bitten by this bug.
, Fixed on trunk, the QueueBrowser will just track all message Audits since its a transient subscription the overhead will be short lived. , I verified that this works in the latest 5.9-SNAPSHOT.

@Torsten - I don't have rights to comment on support cases at RH anymore since my subscription expired. You can close the support ticket there too.
, @Nicholas - Thx for the update. Will do., We are using 5.8.0 in production and got hit very hard by this bug and AMQ-4487. 

Does any anyone have a patched 5.8.0 with this fixed? Or is there any other workaround? ]