[Patch against 5.7.0 tag with testcase that reproduces the issue and poor fix., Thanks, I'll take a look., Looking at the code a bit I think part of the problem here is that Idle timeout seems to be considered even when there are references to the ConnectionPool which would go against the stated purpose of IdleTimeout which is to close out Connection's that have sat unused.  If a reference is active then the ConnectionPool shouldn't be considered inactive since some Session is open and could be in use.  Only expiry timeout should be considered regardless of reference count if I understand that setting correctly, the doco is a bit vague. , Should be fixed now., A proper workaround for any 5.7 and 5.8 versioned clients seems to be to disable the session idle timeout on the ConnectionFactory using PooledConnectionFactory.setIdleTimeout(0).
, alright, can I assume that when this occurs the message is being rolled back/replayed rather than being lost (assuming AUTO_ACK, non-tx mode)?

any other side-effects of the proposed workaround of setting the idelTimeout to 0 (inefficient connection/session mgmt, etc)?

any plans to backport it to a minor release of 5.7 or 5.8?
, I am not aware of any side effects when applying the workaround and setting idleTimeout=0. 
As a consequence sessions won't be invalidated just because they were idle for a specific period of time. But that should generally not be a problem. 
I had a customer testing this idleTimeout=0 in their integration test env and it did not cause any problems. 

Also, its my understanding that you generally should not loose any messages due to the "The Session is closed" error. 
Typically the session is checked for validity right *before* sending the message. You app code of course needs to handle the error and should not assume that the msg was sent.


, we are using ActiveMQ version 5.10. Is this fix available in 5.10? or should we use the workaround of setting idleTimeout=0. , Yes, 5.10 will include the fix for this bug. , An expired connection is now not closed if used by an other thread but there is nothing preventing the loan of an expiryConnection isn't it ?

The [connectionPool.borrow()|http://grepcode.com/file/repo1.maven.org/maven2/org.apache.activemq/activemq-jms-pool/5.11.0/org/apache/activemq/jms/pool/PooledConnectionFactory.java#236] just call the expiryCheck() throught the [validateObject()|http://grepcode.com/file/repo1.maven.org/maven2/org.apache.activemq/activemq-jms-pool/5.11.0/org/apache/activemq/jms/pool/PooledConnectionFactory.java#135] method but it considers the connection valid (and so reusable) if it has expired but has still some remaining reference...

On my environment my expiryTimeout of 60 seconds is rarely reached (unless I assign a connection for each consumer but I can't do that in production environment).]