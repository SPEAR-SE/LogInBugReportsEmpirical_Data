[it would be great if you could provide a tests case for this so we can see your configuration and setup. Of interest is the maxPageSize for the queue and the distribution of messages across the two selectors., I have created two classes to show this problem:  test.PutMessages and test.ReadMessages that show the problem.  Steps to reproduce

1) Start a 5.3.0 broker

2) Start two messages reader for two different correlations on the same queue
java -cp <yourclasspath> test.ReadMessages tcp://localhost:61616 TestQueue ForReader1
java -cp <yourclasspath> test.ReadMessages tcp://localhost:61616 TestQueue ForReader2

3) Start two messages producers for the two different correlations
java -cp <yourclasspath> tesPutMessages tcp://localhost:61616 TestQueue ForReader1
java -cp <yourclasspath> test.PutMessages tcp://localhost:61616 TestQueue ForReader2

4) Looking at the output of the readers you started on step two, you will both read the messages for the correlation with the time on the broker about 1ms.

5) Stop the reader ForReader1, you will notice that the program ForReader2 is uneffected.  Messages with corrlations "ForReader1" backup on the queue, and the program ForReader2 continues reading normally.

6) stop all classes, and stop 5.3.0 broker.  Start a 5.3.2  broker.

7) Repeat steps 1-5.  Except you'll notice that once you stop ForReader1, ForReader2 is effected which is shouldn't be.  ForReader2 will basically stop being able to read messages until you start ForReader1 again.  ForReader2 will occasionally get messages, but incredibly slowly and performance is ruined.

package test;

import java.net.*;
import javax.jms.*;
import org.apache.activemq.ActiveMQConnectionFactory;

/**
 *
 * @author bwillard
 */
public class PutMessages extends Thread {

    final private MessageProducer producer;
    final private String correlationID;
    final private Session session;

    public PutMessages(URI uri, String queueName, String correlationID) throws Exception {

        this.correlationID = correlationID;

        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(uri);
        Connection connection = factory.createConnection();
        connection.start();

        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(queueName);

        producer = session.createProducer(queue);
        producer.setDeliveryMode(DeliveryMode.PERSISTENT);
    }

    public void run() {

        ObjectMessage message;
        String text;
        long counter = 0;

        while (true) {

            try {

                this.sleep(5);

                counter++;

                message = session.createObjectMessage();
                message.setJMSCorrelationID(correlationID);
                text = "Message " + counter + " for consumer " + correlationID;
                message.setObject(text);

                producer.send(message);

            } catch (Exception exc) {
                System.err.println("Error sending message");
                exc.printStackTrace(System.err);
            }

        }
    }

    public static void main(String[] args) {

        try {

            URI uri = URI.create(args[0]);
            String queueName = args[1];
            String correlationID = args[2];

            new PutMessages(uri, queueName, correlationID).start();

        } catch (Exception exc) {
            exc.printStackTrace();
        }

    }
}







package test;

import java.net.*;
import javax.jms.*;
import org.apache.activemq.ActiveMQConnectionFactory;

/**
 *
 * @author bwillard
 */
public class ReadMessages implements MessageListener {

    final private MessageConsumer consumer;
    final private String correlationID;
    final private Session session;

    public ReadMessages(URI uri, String queueName, String correlationID) throws Exception {

        this.correlationID = correlationID;

        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(uri);
        Connection connection = factory.createConnection();
        connection.start();

        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(queueName);

        consumer = session.createConsumer(queue, "JMSCorrelationID='" + correlationID + "'");
        consumer.setMessageListener(this);
    }

    public void onMessage(Message msg) {
        long inTime, outTime, brokerTime;

        try {

            if (msg instanceof ObjectMessage) {
                ObjectMessage txt = (ObjectMessage) msg;
                inTime = txt.getLongProperty("JMSActiveMQBrokerInTime");
                outTime = txt.getLongProperty("JMSActiveMQBrokerOutTime");

                brokerTime = outTime - inTime;

                System.out.println("Message waited " + brokerTime + "ms : " + txt.getObject().toString());
            }

        } catch (Exception exc) {
            System.err.println("Error reading message");
            exc.printStackTrace();
        }
    }

    public static void main(String[] args) {

        try {

            URI uri = URI.create(args[0]);
            String queueName = args[1];
            String correlationID = args[2];

            new ReadMessages(uri, queueName, correlationID);

        } catch (Exception exc) {
            exc.printStackTrace();
        }

    }
}




, I updated the issue because it's a major performance issue that also exists in 5.3.2 when using messages selectors., This is the config file I used in both brokers to show the problem, Source files instead of pasting into comment, sorry., Has anyone had a chance to verify this is a real problem or if there is something wrong with my config?  I am unable to upgrade past broker 5.3.0 because of it, and really want to be able to upgrade to resolve other issues I've been seeing.  I also want to make sure this isn't also an issue in the 5.4 broker due out., Confirmed this is still an issue in the 5.4 snapshot https://repository.apache.org/content/repositories/snapshots/org/apache/activemq/apache-activemq/5.4-SNAPSHOT/apache-activemq-5.4-SNAPSHOT-bin.tar.gz, I wanted to confirm that this is still an issue in the 5.4 release.  I can do it with the default properties file it ship with as well.  Increasing the maxPageSize in the policyEntry seems to help the issue, but eventually the consumer on a separate correlation will lock up.

Any ideas, this is has prevented up from upgrading since 5.3.0., Modifications to 5.4.0 default config file that still show the problem running the provided sample code., This is another case of https://issues.apache.org/activemq/browse/AMQ-2217 - there are some strategies using named queues or virtual queues that can help as outlined in the comments on AMQ-2217

5.3.0 had a bug in this regard that could lead to an out of memory exception as there was no limit on the size of the in memory dispatch queue, it was as if maxPageSize == MAX_INT. With a very sparse selector, the broker would exhaust available memory.
Set maxPageSize to MAX_INT to replicate., I have confirmed this is still a problem in 5.4.1  I have also confirmed you can reproduce this problem with the default activemq configuration file.  Disabling flow control has no effect, neither does lowering the message pre-fetch.  This is a real performance issues for anyone using message selectors., Relates to the same issue of maxPageSize ]