[http://www.nabble.com/REST-problem-tf4707322s2354.html, Please commit!, Lets assume we want to consume one message from a queue that contains two messages, using ActiveMQ's REST Interface with a HTTP GET request.
Looking at MessageServlet.java in the activemq-web module, the method doGet() calls the method doMessages() :
{noformat}
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doMessages(request, response, -1);
    }
{noformat}

As we are not using AJAX, the variable maxMessages gets the value 1:
{noformat}
protected void doMessages(HttpServletRequest request, HttpServletResponse response, int maxMessages) throws ServletException,  IOException {
    ...
    boolean ajax = isRicoAjax(request);
    if (!ajax) {
        maxMessages = 1;
    }
    ...
}
{noformat}

In the synchronized()-block, we are consuming the first message in the queue:
{noformat}
synchronized(consumer){
    ...
    // Look for any available messages
    message = consumer.receiveNoWait();
    ...
}
{noformat}
Then, as message is not null and maxMessages has the value 1, we are entering the while-block:
{noformat}
               // send a response for each available message (up to max
               // messages)
               while ((maxMessages < 0 || messages < maxMessages) && message != null) {
                        // System.err.println("message["+messages+"]="+message);
                        if (ajax) {
                            writer.print("<response type='object' id='");
                            writer.print(request.getParameter("id"));
                            writer.println("'>");
                        } else {
                            // only ever 1 message for non ajax!
                            setResponseHeaders(response, message);
                        }

                        writeMessageResponse(writer, message);

                        if (ajax) {
                            writer.println("</response>");
                        }

                        // look for next message
                        message = consumer.receiveNoWait();
                        messages++;
                    } 
{noformat}
And here sitts the bug in my opinion. The method consumer.receiveNoWait() is called a second time. That means, our second message gets deleted from the queue.

So I put the receiveNoWait() call in an if(ajax) block:
{noformat}                        
                       if (ajax){
                        	// look for next message
                        	message = consumer.receiveNoWait();
                        }
{noformat}

This works fine for me., This problem looks resolved now]