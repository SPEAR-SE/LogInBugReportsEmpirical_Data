[This can be reproduced easily. Simply construct an ObjectMessage of a non-simple type (i.e. none standard JDK type) and send it to a queue. Then using the web console http://localhost:8161/admin access the message body. The above exception will be displayed instead of a proper page.
, This can be reproduced easily. Simply construct an ObjectMessage of a non-simple type (i.e. none standard JDK type) and send it to a queue. Then using the web console http://localhost:8161/admin access the message body. The above exception will be displayed instead of a proper page. , Attaching a possible fix for this issue. Catching the JMSException in MessageQueue.getBody() and returning it. That case it can be properly displayed in the generated html output in the browser. 
Also changing ActiveMQObjectMessage.getObject() to also propagate the root exception (in my test it was a ClassNotFoundException). , I did some testing around this issue, and I found that adding the serializable object class to the broker's classpath will allow getBody() to return correctly. 
In the suggested test case, adding "com.myclass" to the broker classpath will  likely solve the problem, and would explain the ClassNotFoundException. It would probably be a good idea to return a friendly reminder about the possible cause of the problem along with the exception. , I fully agree with your points Giovani. However I don't think it should be a requirement to add application level classes to the brokers classpath in order to drill into individual messages. I can live with the fact that the message content cannot be displayed but it should not generate a fully blown up error with stack trace in the html page but some meaningful response. After all, the message properties can still be displayed. Hence my motivation for a fix. , I agree with the fix too. I'm just saying that it would be nice to inform users about the reason why the broker can't deserialize the object. , patch applied with thanks, r754973]