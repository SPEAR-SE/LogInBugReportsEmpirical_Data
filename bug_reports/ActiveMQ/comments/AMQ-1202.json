[This is kind of an ugly one, but I traced it down to org/apache/activemq/broker/TransportConnector.java and its usage of the connections list.  The code pathway for setting up a Network connection goes as far as calling TransportConnector.onStarted, which adds to this list.  However, this path gets called prior to discovering that the target is not there, but TransportConnector.onStopped is never called.  Thus, TransportConnection objects are leaked into the connections list.

I did not discover yet what use this list is, other than potentially on Broker shutdown, if TransportConnector.stop is called.  So, as a quick work around, I've commented out usage of the connections list in TransportConnector.onStarted and onStopped., Another data point, we are running in to this issue as well. It seems to be much worse when the number of connections is large. We run embedded brokers in each of our app server processes, with each broker connected to every other broker (fully connected network). When 9 of the 12 app servers were down it ran through 1.5GB of heap on each of the remaining 3 app servers in about an hour.

Any idea if a fix of this can be put out before 4.2 is released? This is a fairly serious issue for us., I've looked in to this a bit more and agree with Kevin. TransportConnector is holding on to TransportConnection instances in the connections list. TransportConnector.onStopped() would remove them from the list, but it never gets called. The reason it never gets called is a bit of a long story:

If there are multiple NetworkConnector entries, DiscoveryNetworkConnector creates a bridge for each one. A bridge has a local and remote transport, one for each end of the connection. The 'local' transport of each of those bridge connections is an in-VM transport obtained from the VMTransportFactory. 
VMTransportFactory caches it VMTransportServer instances by 'host'. Because it caches these by host, and the host portion of the VM-transport is based on the broker name, all of the bridges' local transports share the same VMTransportServer instance.
When the bridge can't connect to the remote broker, DiscoveryNetworkConnector does the right thing and tries to dispose of the local and remote transports it created. This disposal includes calling VMTransportServer.stop(), which usually includes stopping the releated TransportConnections, which would in turn cause TransportConnector.onStopped(TransportConnection) to be called, thus cleaning up the connections list. BUT becuase there are other bridges running that share the same VMTransportServer, it's connectionCount variable is greater than 0 which prevents it from closing the related transport connections. So the TransportConnector lives on and holds on to useless TransportConnections.

I don't know what can be done to fix this, but at least the details may be useful to someone who wants to look at it further., Sorry, Adam.  I should have posted this a little while ago.  I ended up just commenting out the contents of onStarted and onStopped in TransportConnector.  The collections didn't appear to be used for anything - it has been a safe change for us so far.

There's another, similar, leak.  I'll open a new issue for that.  It involves rejected connections *into* the broker (as opposed to this one which is connections *out* being made by this broker).
, Added testcase:  org.apache.activemq.network.NetworkConnectionsCleanedupTest in svn revision 585843
profiled for an hour - memory usage remained below 3mb for the jvm in this time]