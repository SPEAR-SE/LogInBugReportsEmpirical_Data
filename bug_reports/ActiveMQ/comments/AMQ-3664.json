[I suspect you need to explicitly set a cache level (use cacheLevel or cacheLevelName attributes) for the component. It defaults to cache_auto which means cache_consumer when there is no transaction. So the consumer is not actually closed.
If the consumer is closed, any outstanding auto ack will be dispatched., When I switch to another cache than CACHE_AUTO or CACHE CONSUMER, I get a dramatic deterioration of performance. Then I am faster when I do not use ptimizeAcknowledge = true. This cannot be the goal of this setting!
The other problem is I do not want to close the consumer. Yes, I want to close the producer, but the consumer should consume and acknowledge all existing messages in the queue. The consumer should not care about how many producers produce messages to the queue. , How do you stop the consumer? When the consumer is stopped it needs to be shutdown, so if it is cached, it needs to be really closed, because optimizeAcknowledge delays acks (to batch them) for a period or till half of the prefetch is reached or till it is closed. The expectation is that there will be duplicate delivery if the consumer is not closed.
The default auto ack mode, does an immediate ack.

The other alternative is to use transactions to batch your client acks, I think this may be the simplest approach. 
Another option is to use client ack mode and periodically call acknowledge, but with camel, this would require your own processor to get access to the underlying activemq message to call acknowledge.

I think first, validate that the consumer is closed when it is shutdown.

For this case, we may need to introduce a consumer task that does a periodic ack, to catch the case where the consumer is cached, there is a pause in production, and there are pending acks. But in the abortive case, there may still be duplicates., Gary

Yeah maybe a multiplexed background thread could run and acknowledge the messages if the consumer has been inactive for a period.
I wonder if we can use a single thread for all optimized ack consumers, I would assume a thread per consumer would bee too much?, The simplest thing would probably be to add a task to the Schedular instance that's owned by ActiveMQConnection that can check for time since last ack on the consumer and fire an ack if the configured time has elapsed., added option optimizedAckScheduledAckInterval to Connection and MessageConsumer to allow for a configurable async ack of outstanding messages.  By default this option is set to zero, meaning no async acks are sent.  If the user wants to ensure all messages are acked at some point then they can enable this by setting to a value greater than zero.  , fixed in trunk.]