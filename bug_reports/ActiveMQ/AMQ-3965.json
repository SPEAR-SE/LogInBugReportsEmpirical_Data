{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "fields": {
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "aggregatetimeestimate": null,
        "aggregatetimeoriginalestimate": null,
        "aggregatetimespent": null,
        "assignee": {
            "active": true,
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443",
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10443"
            },
            "displayName": "Torsten Mielke",
            "key": "tmielke",
            "name": "tmielke",
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=tmielke",
            "timeZone": "Europe/Berlin"
        },
        "components": [{
            "id": "12313896",
            "name": "JMS client",
            "self": "https://issues.apache.org/jira/rest/api/2/component/12313896"
        }],
        "created": "2012-08-08T15:07:12.000+0000",
        "creator": {
            "active": true,
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443",
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10443"
            },
            "displayName": "Torsten Mielke",
            "key": "tmielke",
            "name": "tmielke",
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=tmielke",
            "timeZone": "Europe/Berlin"
        },
        "customfield_10010": null,
        "customfield_12310041": null,
        "customfield_12310080": null,
        "customfield_12310220": "2012-08-08T21:01:35.428+0000",
        "customfield_12310222": "1_*:*_1_*:*_403330663_*|*_5_*:*_1_*:*_0",
        "customfield_12310250": null,
        "customfield_12310290": null,
        "customfield_12310291": null,
        "customfield_12310300": null,
        "customfield_12310310": "3.0",
        "customfield_12310420": "246257",
        "customfield_12310920": "41900",
        "customfield_12310921": null,
        "customfield_12311020": null,
        "customfield_12311024": null,
        "customfield_12311120": null,
        "customfield_12311820": "0|i07jc7:",
        "customfield_12312022": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "customfield_12312026": null,
        "customfield_12312220": null,
        "customfield_12312320": null,
        "customfield_12312321": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312324": null,
        "customfield_12312325": null,
        "customfield_12312326": null,
        "customfield_12312327": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312330": null,
        "customfield_12312331": null,
        "customfield_12312332": null,
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12312335": null,
        "customfield_12312336": null,
        "customfield_12312337": null,
        "customfield_12312338": null,
        "customfield_12312339": null,
        "customfield_12312340": null,
        "customfield_12312341": null,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Aug 13 07:09:22 UTC 2012",
        "customfield_12312720": null,
        "customfield_12312823": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "customfield_12312923": null,
        "customfield_12313422": "false",
        "customfield_12313520": null,
        "description": "\nIt is possible to get a consumer stalled and not receiving any more messages when using optimizeAcknowledge.\nLet me illustrate in an example (JUnit test attached).\n\nSuppose a consumer with optimizeAcknowledge and a prefetch of 100 msgs.\nThe broker's queue contains 105 msg. The first 45 msgs have a very low expiry time, the remaining don't expiry. \n\nSo the first 100 msgs get dispatched to the consumer (due to prefetch=100). Out of these the first 45 msgs do not get dispatched to consumer code because their expiry has elapsed by the time that are handled in the client. \n\n{code:title=ActiveMQMessageConsumer.java}\npublic void dispatch(MessageDispatch md) {\n        MessageListener listener = this.messageListener.get();\n        try {\n            [...]\n            synchronized (unconsumedMessages.getMutex()) {\n                if (!unconsumedMessages.isClosed()) {\n                    if (this.info.isBrowser() || !session.connection.isDuplicate(this, md.getMessage())) {\n                        if (listener != null && unconsumedMessages.isRunning()) {\n                            ActiveMQMessage message = createActiveMQMessage(md);\n                            beforeMessageIsConsumed(md);\n                            try {\n                                boolean expired = message.isExpired();\n                                if (!expired) {\n                                    listener.onMessage(message);\n                                }\n                                afterMessageIsConsumed(md, expired);\n{code}\n\nlistener.onMessage() above is not called as the msg has expired. \nHowever it will calls into afterMessagesIsConsumed()\n\n{code:title=ActiveMQMessageConsumer.java}\n    private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n      [...]  \n      if (messageExpired) {\n            synchronized (deliveredMessages) {\n                deliveredMessages.remove(md);\n            }\n            stats.getExpiredMessageCount().increment();\n            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n\n{code}\n\nand will remove the expired msg from the deliveredMessages list. It then calls into ackLater(). \nHowever ackLater() only fires an ack back to the broker when the number of unsent acks has reached 50% of the prefetch value.\n\n{code:title=ActiveMQMessageConsumer.java}\n private void ackLater(MessageDispatch md, byte ackType) throws JMSException {\n    [...]\n    if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter - additionalWindowSize)) {\n            session.sendAck(pendingAck);\n{code}        \n\nIn our example it has not reached that mark (only 45 expired msgs, i.e. 45%). \nSo the first 45 msgs, which expired before being dispatched, did not cause an ack being sent to the broker.\n\nNow the next 55 messages get processed. These don't have an expiry so they get dispatched to consumer code. \nAfter dispatching each msg to the registered application code, we call into afterMessageIsConsumed() but this time executing a different branch as the msgs are not expired\n\n{code:title=ActiveMQMessageConsumer.java}\nprivate void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n    [...]\n    else if (isAutoAcknowledgeEach()) {\n                if (deliveryingAcknowledgements.compareAndSet(false, true)) {\n                    synchronized (deliveredMessages) {\n                        if (!deliveredMessages.isEmpty()) {\n                            if (optimizeAcknowledge) {\n                                ackCounter++;\n                                if (ackCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {\n                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                    if (ack != null) {\n                                        deliveredMessages.clear();\n                                        ackCounter = 0;\n                                        session.sendAck(ack);\n                                        optimizeAckTimestamp = System.currentTimeMillis();\n                                    }\n                                }\n{code}\n\nwith optimizeAcknowledge=true we only send an ack back to the broker if either optimizeAcknowledgeTimeOut has elapsed or the ackCounter has reached 65% of the prefetch (100). \nThe timeout will not have kicked in. The ackCounter will be at 55 after processing the last of 100 prefetched messages which is less than 65% of 100. So with the last prefetched msg being processed, it will not generate an ack back to the broker. \nAs a result, the client has processed all prefetched message and will not get any new messages dispatched from the broker. The broker has another 5 msgs on the queue but since it never received an ack from the client, it won't dispatch any further messages. \n\nThe client is stalled. \n\n",
        "duedate": null,
        "environment": null,
        "fixVersions": [{
            "archived": false,
            "description": "Next v5 maintenance release",
            "id": "12321258",
            "name": "5.7.0",
            "releaseDate": "2012-10-08",
            "released": true,
            "self": "https://issues.apache.org/jira/rest/api/2/version/12321258"
        }],
        "issuelinks": [],
        "issuetype": {
            "avatarId": 21133,
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "id": "1",
            "name": "Bug",
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "subtask": false
        },
        "labels": ["optimizeDispatch"],
        "lastViewed": null,
        "priority": {
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "id": "3",
            "name": "Major",
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3"
        },
        "progress": {
            "progress": 0,
            "total": 0
        },
        "project": {
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12311210&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12311210&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12311210&avatarId=10011",
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12311210&avatarId=10011"
            },
            "id": "12311210",
            "key": "AMQ",
            "name": "ActiveMQ",
            "projectCategory": {
                "description": "ActiveMQ",
                "id": "11160",
                "name": "ActiveMQ",
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/11160"
            },
            "self": "https://issues.apache.org/jira/rest/api/2/project/12311210"
        },
        "reporter": {
            "active": true,
            "avatarUrls": {
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443",
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10443"
            },
            "displayName": "Torsten Mielke",
            "key": "tmielke",
            "name": "tmielke",
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=tmielke",
            "timeZone": "Europe/Berlin"
        },
        "resolution": {
            "description": "A fix for this issue is checked into the tree and tested.",
            "id": "1",
            "name": "Fixed",
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1"
        },
        "resolutiondate": "2012-08-13T07:09:22.000+0000",
        "status": {
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "id": "5",
            "name": "Resolved",
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "statusCategory": {
                "colorName": "green",
                "id": 3,
                "key": "done",
                "name": "Done",
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3"
            }
        },
        "subtasks": [],
        "summary": "Expired msgs not getting acked to broker causing consumer to fill up its prefetch and not getting more msgs.",
        "timeestimate": null,
        "timeoriginalestimate": null,
        "timespent": null,
        "updated": "2012-08-13T07:09:22.000+0000",
        "versions": [{
            "archived": false,
            "description": "Next v5 maintenance release",
            "id": "12317974",
            "name": "5.6.0",
            "releaseDate": "2012-05-07",
            "released": true,
            "self": "https://issues.apache.org/jira/rest/api/2/version/12317974"
        }],
        "votes": {
            "hasVoted": false,
            "self": "https://issues.apache.org/jira/rest/api/2/issue/AMQ-3965/votes",
            "votes": 0
        },
        "watches": {
            "isWatching": false,
            "self": "https://issues.apache.org/jira/rest/api/2/issue/AMQ-3965/watchers",
            "watchCount": 3
        },
        "workratio": -1
    },
    "id": "12602250",
    "key": "AMQ-3965",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/12602250"
}