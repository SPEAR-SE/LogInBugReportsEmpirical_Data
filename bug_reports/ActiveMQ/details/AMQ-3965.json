{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12602250","self":"https://issues.apache.org/jira/rest/api/2/issue/12602250","key":"AMQ-3965","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12311210","id":"12311210","key":"AMQ","name":"ActiveMQ","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12311210&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12311210&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12311210&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12311210&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/11160","id":"11160","description":"ActiveMQ","name":"ActiveMQ"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12321258","id":"12321258","description":"Next v5 maintenance release","name":"5.7.0","archived":false,"released":true,"releaseDate":"2012-10-08"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2012-08-08T21:01:35.428+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Aug 13 07:09:22 UTC 2012","customfield_12310420":"246257","customfield_12312320":null,"customfield_12310222":"1_*:*_1_*:*_403330663_*|*_5_*:*_1_*:*_0","customfield_12312321":null,"resolutiondate":"2012-08-13T07:09:22.759+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-3965/watchers","watchCount":3,"isWatching":false},"created":"2012-08-08T15:07:12.137+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":["optimizeDispatch"],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"3.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12317974","id":"12317974","description":"Next v5 maintenance release","name":"5.6.0","archived":false,"released":true,"releaseDate":"2012-05-07"}],"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2012-08-13T07:09:22.787+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12313896","id":"12313896","name":"JMS client"}],"timeoriginalestimate":null,"customfield_12310080":null,"description":"\nIt is possible to get a consumer stalled and not receiving any more messages when using optimizeAcknowledge.\nLet me illustrate in an example (JUnit test attached).\n\nSuppose a consumer with optimizeAcknowledge and a prefetch of 100 msgs.\nThe broker's queue contains 105 msg. The first 45 msgs have a very low expiry time, the remaining don't expiry. \n\nSo the first 100 msgs get dispatched to the consumer (due to prefetch=100). Out of these the first 45 msgs do not get dispatched to consumer code because their expiry has elapsed by the time that are handled in the client. \n\n{code:title=ActiveMQMessageConsumer.java}\npublic void dispatch(MessageDispatch md) {\n        MessageListener listener = this.messageListener.get();\n        try {\n            [...]\n            synchronized (unconsumedMessages.getMutex()) {\n                if (!unconsumedMessages.isClosed()) {\n                    if (this.info.isBrowser() || !session.connection.isDuplicate(this, md.getMessage())) {\n                        if (listener != null && unconsumedMessages.isRunning()) {\n                            ActiveMQMessage message = createActiveMQMessage(md);\n                            beforeMessageIsConsumed(md);\n                            try {\n                                boolean expired = message.isExpired();\n                                if (!expired) {\n                                    listener.onMessage(message);\n                                }\n                                afterMessageIsConsumed(md, expired);\n{code}\n\nlistener.onMessage() above is not called as the msg has expired. \nHowever it will calls into afterMessagesIsConsumed()\n\n{code:title=ActiveMQMessageConsumer.java}\n    private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n      [...]  \n      if (messageExpired) {\n            synchronized (deliveredMessages) {\n                deliveredMessages.remove(md);\n            }\n            stats.getExpiredMessageCount().increment();\n            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n\n{code}\n\nand will remove the expired msg from the deliveredMessages list. It then calls into ackLater(). \nHowever ackLater() only fires an ack back to the broker when the number of unsent acks has reached 50% of the prefetch value.\n\n{code:title=ActiveMQMessageConsumer.java}\n private void ackLater(MessageDispatch md, byte ackType) throws JMSException {\n    [...]\n    if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter - additionalWindowSize)) {\n            session.sendAck(pendingAck);\n{code}        \n\nIn our example it has not reached that mark (only 45 expired msgs, i.e. 45%). \nSo the first 45 msgs, which expired before being dispatched, did not cause an ack being sent to the broker.\n\nNow the next 55 messages get processed. These don't have an expiry so they get dispatched to consumer code. \nAfter dispatching each msg to the registered application code, we call into afterMessageIsConsumed() but this time executing a different branch as the msgs are not expired\n\n{code:title=ActiveMQMessageConsumer.java}\nprivate void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n    [...]\n    else if (isAutoAcknowledgeEach()) {\n                if (deliveryingAcknowledgements.compareAndSet(false, true)) {\n                    synchronized (deliveredMessages) {\n                        if (!deliveredMessages.isEmpty()) {\n                            if (optimizeAcknowledge) {\n                                ackCounter++;\n                                if (ackCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {\n                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                    if (ack != null) {\n                                        deliveredMessages.clear();\n                                        ackCounter = 0;\n                                        session.sendAck(ack);\n                                        optimizeAckTimestamp = System.currentTimeMillis();\n                                    }\n                                }\n{code}\n\nwith optimizeAcknowledge=true we only send an ack back to the broker if either optimizeAcknowledgeTimeOut has elapsed or the ackCounter has reached 65% of the prefetch (100). \nThe timeout will not have kicked in. The ackCounter will be at 55 after processing the last of 100 prefetched messages which is less than 65% of 100. So with the last prefetched msg being processed, it will not generate an ack back to the broker. \nAs a result, the client has processed all prefetched message and will not get any new messages dispatched from the broker. The broker has another 5 msgs on the queue but since it never received an ack from the client, it won't dispatch any further messages. \n\nThe client is stalled. \n\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12540464","id":"12540464","filename":"AMQ-3956.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-10T10:31:22.811+0000","size":11505,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12540464/AMQ-3956.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12539923","id":"12539923","filename":"OptimizeAcknowledgeWithExpiredMsgsTest.java","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-08-08T21:01:35.365+0000","size":8082,"mimeType":"text/x-java","content":"https://issues.apache.org/jira/secure/attachment/12539923/OptimizeAcknowledgeWithExpiredMsgsTest.java"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12539875","id":"12539875","filename":"testcase.tgz","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-08T15:13:37.338+0000","size":4379,"mimeType":"application/x-gzip","content":"https://issues.apache.org/jira/secure/attachment/12539875/testcase.tgz"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310041":null,"customfield_12310921":null,"customfield_12310920":"41900","customfield_12312823":null,"summary":"Expired msgs not getting acked to broker causing consumer to fill up its prefetch and not getting more msgs.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13431146","id":"13431146","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"body":"A possible fix for this may be to no hold back acks for expired messages (as currently done by calling ackLater()) but to ack any expired messages\nstraight away.\nThis however will cause more acks to be written back to the broker, but only in case of expired messages.\n\nPerhaps there is a better solution that has less of an overhead? ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-08T15:07:43.113+0000","updated":"2012-08-08T15:07:43.113+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13431151","id":"13431151","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"body":"Attaching testcase as mvn project. \nThe testclasss can also be copied into activemq-core/src/test/java/org/apache/activemq/bugs ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-08T15:13:37.373+0000","updated":"2012-08-08T15:13:37.373+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13431382","id":"13431382","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"Updated the test so that the async case is more stable on fast hardware, was a bit flaky on my fast Linux box.  Added a sync test case to show that both paths suffer the same problem and also to verify the async case was suffering timing issues. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-08-08T21:01:35.428+0000","updated":"2012-08-08T21:01:35.428+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13431395","id":"13431395","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"it looks like at the very least we need to check the pendingAcks when we go into the optimize ack case as it doesn't use the deliveredCounter like the rest of the code that uses ackLater so unlike ackLater it doesn't see the pending count of expired messages.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-08-08T21:17:22.743+0000","updated":"2012-08-08T21:17:22.743+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13431945","id":"13431945","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"body":"We thought that the following fix could do the job \n{code:title=ActiveMQMessageConsumer.java} \nprivate void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n[...]\n        if (messageExpired) {\n            synchronized (deliveredMessages) {\n                deliveredMessages.remove(md);\n            }\n            stats.getExpiredMessageCount().increment();\n            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n        } else {\n            stats.onMessage();\n            if (session.getTransacted()) {\n                // Do nothing.\n            } else if (isAutoAcknowledgeEach()) {\n                if (deliveryingAcknowledgements.compareAndSet(false, true)) {\n                    synchronized (deliveredMessages) {\n                        if (!deliveredMessages.isEmpty()) {\n                            if (optimizeAcknowledge) {\n                            \tackCounter++;\n                            \t\n                            \t// AMQ-3965 - this alone does not fix it.\n                                float threshold = (float) info.getPrefetchSize() * (float) 0.65;\n                            \tif (pendingAck != null && (ackCounter + deliveredCounter) >= (threshold)) {\n                                    session.sendAck(pendingAck);\n                                    pendingAck = null;\n                                    deliveredCounter = 0;\n                            \t}\n                                if (ackCounter >= (threshold) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {\n                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                    if (ack != null) {\n                                        deliveredMessages.clear();\n                                        ackCounter = 0;\n                                        session.sendAck(ack);\n                                        optimizeAckTimestamp = System.currentTimeMillis();\n                                    }\n                                }\n{code} \n\nbut that extra code \n{code} \n// AMQ-3965 - this alone does not fix it.\nfloat threshold = (float) info.getPrefetchSize() * (float) 0.65;\nif (optimizeAcknowledge && pendingAck != null && (ackCounter + deliveredCounter) >= (threshold)) {\n  session.sendAck(pendingAck);\n  pendingAck = null;\n  deliveredCounter = 0;\n} \n\n{code} alone is not enough. Let me explain why: \n\nSuppose a prefetch of 100. Consumer receives 56 normal msgs. So ackCounter is at 56, no ack sent back to broker yet. It then receives 44 msgs that expire on consumer before dispatch. So deliveredCounter=44 and ackCounter=56. In afterMessageIsConsumed() it does not go into the proposed code for the expired msgs, only for normal msgs. So for the last 44 expired msgs there is no trigger fired to sent an ack to the broker. The result is a hanging consumer that does not receive any more msgs. Problem not fixed. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-09T16:13:45.317+0000","updated":"2012-08-09T16:45:37.563+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13432167","id":"13432167","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"So far I haven't hit on any more elagant solution than to also check use the ackCounter in ackLater like so:\n\n{code}\n        // NOTE: I bumped this to 0.65, its currently 0.5 for some reason.\n        float threshold = 0.65f * info.getPrefetchSize();\n        if (threshold <= ((ackCounter + deliveredCounter) - additionalWindowSize)) {\n            session.sendAck(pendingAck);\n            pendingAck=null;\n            deliveredCounter = 0;\n            additionalWindowSize = 0;\n        }\n{code}\n\nThis of course can lead to the scenario where you start acking every single expired message that arrives if the numbers are right, but without a lot of code changes I haven't seen another way to deal with this.  Eventually when some non-expired messages come in and the ackCounter gets high enough to send ack for the consumed messages things would settle down again.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-08-09T21:25:11.322+0000","updated":"2012-08-09T21:25:11.322+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13432683","id":"13432683","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"body":"Proposing the following fix: \n\n{code:title=ActiveMQMessageConsumer.java}\nprivate void ackLater(MessageDispatch md, byte ackType) throws JMSException {\n[...]\n    if ((0.5 * info.getPrefetchSize()) <= (deliveredCounter + ackCounter - additionalWindowSize)) {\n      session.sendAck(pendingAck);\n      pendingAck=null;\n      deliveredCounter = 0;\n      additionalWindowSize = 0;\n    }\n\n[...]\n\nprivate void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n[...]\nsynchronized (deliveredMessages) {\n                        if (!deliveredMessages.isEmpty()) {\n                            if (optimizeAcknowledge) {\n                                ackCounter++;\n                                \n                                // AMQ-3956 evaluate both expired and normal msgs as \n                                // otherwise consumer may get stalled\n                                if (ackCounter + deliveredCounter >= (info.getPrefetchSize() * .65) || (optimizeAcknowledgeTimeOut > 0 && System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAcknowledgeTimeOut))) {\n                                    MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                \tif (ack != null) {\n                                        deliveredMessages.clear();\n                                        ackCounter = 0;\n                                        session.sendAck(ack);\n                                        optimizeAckTimestamp = System.currentTimeMillis();\n                                    }\n                                \t// AMQ-3956 - as further optimization send \n                                    // ack for expired msgs when there are any.\n                                    // This resets the deliveredCounter to 0 so that\n                                \t// we won't sent standard acks with every msg just\n                                \t// because the deliveredCounter just below \n                                \t// 0.5 * prefetch as used in ackLater()\n                                \tif (pendingAck != null && deliveredCounter > 0) {\n                                    \tsession.sendAck(pendingAck);\n                                        pendingAck = null;\n                                        deliveredCounter = 0;\n                                    }\n                                }\n                            }\n{code}\n\nEssentially, both methods ackLater() and afterMessageIsConsumed() now evaluate ackCounter + deliveredCounter. \nThis will avoid getting a stalled consumer and fixes the bug.\n\nHowever an additional optimization is necessary for the following case:\nSuppose a prefetch=100. \nConsumer receives 49 msgs that expire before being dispatched. So deliveredCounter=49, ackCounter=0. No ack is sent as threshold is below 50. \nNext, consumer only processes non-expired msgs. As deliveredCounter=49, it will dispatch 17 msg and then send a standard ack. Because after\nthe 17th msg, deliveredCounter=49, ackCounter=17, so that exceeds 0.65*prefetch and hence a standard ack is sent. The ack resets the ackCounter but not the deliveredCounter, which remains at 49. \nSo we would process only another 17 non-expired msgs before we would send the next standard ack to the broker. The problem is that the deliveredCounter does not change unless we receive another expired msg. If we only receive non-expired msgs going further, then deliveredCounter never gets reset to 0 and we ack after every 17 msgs instead of after 0.65*prefetch=65 msg.\nTo avoid this situation, I propose to send a deliveredAck right after the standard Ack. This would reset the deliveredCounter to 0 and we can process the next 65 non-expired msgs without having to send back an ack (as opposed to processing only 17 msg before sending an ack).\nIf there is no expired msgs to be acked, then no deliveredAck is being sent. So this should only trigger in the case where some expired msgs have accumulated but have not being acked yet. \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-10T10:18:18.995+0000","updated":"2012-08-10T10:21:33.447+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13432688","id":"13432688","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"body":"Attaching possible patch plus JUnit test. \nWould ask for review and if accepted I can commit the code to trunk. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-10T10:31:22.864+0000","updated":"2012-08-10T10:31:22.864+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13432709","id":"13432709","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"body":"@Torsten that patch[1] looks good to me.\n[1]https://issues.apache.org/jira/secure/attachment/12540464/AMQ-3956.patch\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"created":"2012-08-10T11:52:12.713+0000","updated":"2012-08-10T11:52:12.713+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13432722","id":"13432722","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"Looks good, think you should go ahead and apply it. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-08-10T12:35:36.325+0000","updated":"2012-08-10T12:35:36.325+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12602250/comment/13432963","id":"13432963","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"body":"Resolved by this [commit|https://fisheye6.atlassian.com/changelog/activemq?cs=1371722].","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tmielke","name":"tmielke","key":"tmielke","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10443","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10443","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10443","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10443"},"displayName":"Torsten Mielke","active":true,"timeZone":"Europe/Berlin"},"created":"2012-08-13T07:09:22.784+0000","updated":"2012-08-13T07:09:22.784+0000"}],"maxResults":11,"total":11,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-3965/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i07jc7:"}}