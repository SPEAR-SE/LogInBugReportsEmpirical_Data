{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12655602","self":"https://issues.apache.org/jira/rest/api/2/issue/12655602","key":"AMQ-4611","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12311210","id":"12311210","key":"AMQ","name":"ActiveMQ","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12311210&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12311210&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12311210&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12311210&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/11160","id":"11160","description":"ActiveMQ","name":"ActiveMQ"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12315630","id":"12315630","description":"Issues that need to be reviewed - do we keep 'em or do we kick 'em? ","name":"NEEDS_REVIEW","archived":false,"released":false}],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":null,"customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Jul 01 21:23:47 UTC 2013","customfield_12310420":"335877","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-4611/watchers","watchCount":1,"isWatching":false},"created":"2013-07-01T15:00:23.429+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":["AMQ_EMBEDDED_BROKER_WITH_STATIC_BRIDGE"],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12323282","id":"12323282","description":"Maintenance release with new AMQP support and smaller modules","name":"5.8.0","archived":false,"released":true,"releaseDate":"2013-02-11"}],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-10-30T09:48:44.298+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12313892","id":"12313892","name":"Broker"}],"timeoriginalestimate":null,"customfield_12310080":null,"description":"Hi,\n\nI have an embedded broker connecting to my remote server broker using network connector and setStaticBridge=true and static list of destinations. When producer produces the message connecting to my local embedded broker, it successfully forwards to remote broker and stick it to pending messages. Issue comes during network failure when embedded broker is unable to communicate to remote broker and producer keep on producing messages. Producer messages will be stored in KahaDB as a part of persistence setting. When network comes up, I am not able to see old messages produced by producer in the pending message of the remote broker and it doesn't forward any new messages produced by the producer to remote broker thereafter. Only temporary solution is to restart embedded broker. Please help in this urgent issue. My code are as below -\n\n1. Embedded Broker\n\n    public final class EmbeddedBroker {\n    public static Destination destination;\n    public static String subject = \"TOOL.DEFAULT\";\n    public static boolean topic;\n    public static boolean transacted;\n\n    private EmbeddedBroker() {\n    }\n\n    public static void main(String[] args) throws Exception {\n        BrokerService broker = new BrokerService();\n        broker.setUseJmx(true);\n        broker.setBrokerName(\"storeforward\");\n        broker.addConnector(\"tcp://localhost:61616\");\n        broker.setPersistent(true);\n        NetworkConnector connector1 = broker.addNetworkConnector(\"static:failover:\"+\"tcp://172.16.102.153:61616\");\n        connector1.setDuplex(true);\n        connector1.setStaticBridge(true);\n\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(null, null, \"failover:tcp://172.16.102.153:61616\");\n        Connection connection = connectionFactory.createConnection();\n        System.out.println(\"test\");\n        connection.start();\n        Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);\n        if (topic) {\n            destination = session.createTopic(subject);\n        } else {\n            destination = session.createQueue(subject);\n        }\n        \n        List lst = new ArrayList();\n        lst.add(destination);\n        connector1.setBridgeTempDestinations(true);\n        connector1.setAdvisoryForFailedForward(true);\n        connector1.setStaticallyIncludedDestinations(lst);\n        \n        broker.start();\n\n        // now lets wait forever to avoid the JVM terminating immediately\n        Object lock = new Object();\n        synchronized (lock) {\n            lock.wait();\n        }\n    }\n}\n\n\n2. Producer\n\npublic class ProducerTool extends Thread {\n\n    private Destination destination;\n    private int messageCount = 10;\n    private long sleepTime;\n    private boolean verbose = true;\n    private int messageSize = 255;\n    private static int parallelThreads = 1;\n    private long timeToLive;\n/*    private String user = ActiveMQConnection.DEFAULT_USER;\n    private String password = ActiveMQConnection.DEFAULT_PASSWORD;\n*/    \n    private String user = null;\n    private String password = null;\n    \n    private String url = \"failover:tcp://172.16.102.153:61616\";\n    private String subject = \"TOOL.DEFAULT\";\n    private boolean topic;\n    private boolean transacted;\n    private boolean persistent = true;\n    private static Object lockResults = new Object();\n\n    public static void main(String[] args) throws Exception {\n    \n        ArrayList<ProducerTool> threads = new ArrayList();\n        ProducerTool producerTool = new ProducerTool();\n        String[] unknown = CommandLineSupport.setOptions(producerTool, args);\n        if (unknown.length > 0) {\n            System.out.println(\"Unknown options: \" + Arrays.toString(unknown));\n            System.exit(-1);\n        }\n        producerTool.showParameters();\n        for (int threadCount = 1; threadCount <= parallelThreads; threadCount++) {\n            producerTool = new ProducerTool();\n            CommandLineSupport.setOptions(producerTool, args);\n            producerTool.start();\n            threads.add(producerTool);\n        }\n\n        while (true) {\n            Iterator<ProducerTool> itr = threads.iterator();\n            int running = 0;\n            while (itr.hasNext()) {\n                ProducerTool thread = itr.next();\n                if (thread.isAlive()) {\n                    running++;\n                }\n            }\n            if (running <= 0) {\n                System.out.println(\"All threads completed their work\");\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (Exception e) {\n            }\n        }\n        System.exit(0);\n    }\n\n    public void showParameters() {\n        System.out.println(\"Connecting to URL: \" + url + \" (\" + user + \":\" + password + \")\");\n        System.out.println(\"Publishing a Message with size \" + messageSize + \" to \" + (topic ? \"topic\" : \"queue\") + \": \" + subject);\n        System.out.println(\"Using \" + (persistent ? \"persistent\" : \"non-persistent\") + \" messages\");\n        System.out.println(\"Sleeping between publish \" + sleepTime + \" ms\");\n        System.out.println(\"Running \" + parallelThreads + \" parallel threads\");\n\n        if (timeToLive != 0) {\n            System.out.println(\"Messages time to live \" + timeToLive + \" ms\");\n        }\n    }\n\n    public void run() {\n        Connection connection = null;\n        try {\n            // Create the connection.\n            \n            url = \"tcp://localhost:61616\";\n            \n            ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(user, password, url);\n            connection = connectionFactory.createConnection();\n            connection.start();\n            \n            Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);\n            if (topic) {\n                destination = session.createTopic(subject);\n            } else {\n                destination = session.createQueue(subject);\n            }\n\n            // Create the session\n\n            // Create the producer.\n            MessageProducer producer = session.createProducer(destination);\n            if (persistent) {\n                producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n            } else {\n                producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n            }\n            if (timeToLive != 0) {\n                producer.setTimeToLive(timeToLive);\n            }\n\n            // Start sending messages\n            sendLoop(session, producer);\n\n            System.out.println(\"[\" + this.getName() + \"] Done.\");\n\n            synchronized (lockResults) {\n                ActiveMQConnection c = (ActiveMQConnection) connection;\n                System.out.println(\"[\" + this.getName() + \"] Results:\\n\");\n                c.getConnectionStats().dump(new IndentPrinter());\n            }\n\n        } catch (Exception e) {\n            System.out.println(\"[\" + this.getName() + \"] Caught: \" + e);\n            e.printStackTrace();\n        } finally {\n            try {\n                connection.close();\n            } catch (Throwable ignore) {\n            }\n        }\n    }\n\n    protected void sendLoop(Session session, MessageProducer producer) throws Exception {\n\n        for (int i = 0; i < messageCount || messageCount == 0; i++) {\n\n            TextMessage message = session.createTextMessage(createMessageText(i));\n\n            if (verbose) {\n                String msg = message.getText();\n                if (msg.length() > 50) {\n                    msg = msg.substring(0, 50) + \"...\";\n                }\n                System.out.println(\"[\" + this.getName() + \"] Sending message: '\" + msg + \"'\");\n            }\n\n            producer.send(message);\n\n            if (transacted) {\n                System.out.println(\"[\" + this.getName() + \"] Committing \" + messageCount + \" messages\");\n                session.commit();\n            }\n            Thread.sleep(sleepTime);\n        }\n    }\n\n    private String createMessageText(int index) {\n        StringBuffer buffer = new StringBuffer(messageSize);\n        buffer.append(\"Message: \" + index + \" sent at: \" + new Date());\n        if (buffer.length() > messageSize) {\n            return buffer.substring(0, messageSize);\n        }\n        for (int i = buffer.length(); i < messageSize; i++) {\n            buffer.append(' ');\n        }\n        return buffer.toString();\n    }\n\n    public void setPersistent(boolean durable) {\n        this.persistent = durable;\n    }\n\n    public void setMessageCount(int messageCount) {\n        this.messageCount = messageCount;\n    }\n\n    public void setMessageSize(int messageSize) {\n        this.messageSize = messageSize;\n    }\n\n    public void setPassword(String pwd) {\n        this.password = pwd;\n    }\n\n    public void setSleepTime(long sleepTime) {\n        this.sleepTime = sleepTime;\n    }\n\n    public void setSubject(String subject) {\n        this.subject = subject;\n    }\n\n    public void setTimeToLive(long timeToLive) {\n        this.timeToLive = timeToLive;\n    }\n\n    public void setParallelThreads(int parallelThreads) {\n        if (parallelThreads < 1) {\n            parallelThreads = 1;\n        }\n        this.parallelThreads = parallelThreads;\n    }\n\n    public void setTopic(boolean topic) {\n        this.topic = topic;\n    }\n\n    public void setQueue(boolean queue) {\n        this.topic = !queue;\n    }\n\n    public void setTransacted(boolean transacted) {\n        this.transacted = transacted;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    public void setVerbose(boolean verbose) {\n        this.verbose = verbose;\n    }\n}","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310041":null,"customfield_12310921":null,"customfield_12310920":"336201","customfield_12312823":null,"summary":"Network Failure Issue in Embedded Broker using setStaticBridge=true","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=murtaza.ghodawala","name":"murtaza.ghodawala","key":"murtaza.ghodawala","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Murtaza","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=murtaza.ghodawala","name":"murtaza.ghodawala","key":"murtaza.ghodawala","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Murtaza","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"Production","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12655602/comment/13697203","id":"13697203","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=murtaza.ghodawala","name":"murtaza.ghodawala","key":"murtaza.ghodawala","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Murtaza","active":true,"timeZone":"Etc/UTC"},"body":"Please urgently reply on this very very urgent and critical bug in Active MQ. It has been a blocker for the entire community from using this product. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=murtaza.ghodawala","name":"murtaza.ghodawala","key":"murtaza.ghodawala","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Murtaza","active":true,"timeZone":"Etc/UTC"},"created":"2013-07-01T21:23:47.568+0000","updated":"2013-07-01T21:23:47.568+0000"}],"maxResults":1,"total":1,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-4611/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i1lxpz:"}}