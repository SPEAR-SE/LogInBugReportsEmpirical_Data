{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12684312","self":"https://issues.apache.org/jira/rest/api/2/issue/12684312","key":"AMQ-4935","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12311210","id":"12311210","key":"AMQ","name":"ActiveMQ","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12311210&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12311210&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12311210&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12311210&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/11160","id":"11160","description":"ActiveMQ","name":"ActiveMQ"}},"fixVersions":[],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/8","id":"8","description":"The described issue is not actually a problem - it is as designed.","name":"Not A Problem"},"customfield_12312322":null,"customfield_12310220":"2013-12-13T13:15:14.672+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Jan 06 21:17:31 UTC 2014","customfield_12310420":"363384","customfield_12312320":null,"customfield_12310222":"1_*:*_1_*:*_2172356014_*|*_6_*:*_1_*:*_0","customfield_12312321":null,"resolutiondate":"2014-01-06T21:30:35.616+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-4935/watchers","watchCount":2,"isWatching":false},"created":"2013-12-12T18:04:39.638+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"1.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12323932","id":"12323932","name":"5.9.0","archived":false,"released":true,"releaseDate":"2013-10-21"}],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2014-01-06T21:30:35.648+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12313892","id":"12313892","name":"Broker"}],"timeoriginalestimate":null,"customfield_12310080":null,"description":"We have a distributed application that uses ActiveMQ for communication between nodes. We are currently using ActiveMQ 5.9.0 running with Oracle JRE 1.7.0 update 45. \n\nWe are seeing some strange deadlock behavior in the ActiveMQ ThreadPoolExecutor when trying to serialize instances of ConcurrentHashMap. The thread dump can be seen at the following link:\n\nhttp://pastebin.com/wmNxSF4p\n\nWe can see that there are two threads that are blocked waiting for a lock on some of the segments in a ConcurrentHashMap yet the thread dump does not indicate any threads that currently hold a lock on those objects. This lock does not occur all the time and can take around 5-10 messages before the deadlock occurs. I have been able to recreate this issue on two different physical machines.\n\nOur test environment that generated this thread dump is as follows. Node A is the instance that thread dump was taken from. For testing both nodes are on the same physical machine.\n\nNode A:\n* In its own JVM instance.\n* Runs an embedded ActiveMQ broker.\n* Performs communication via vm transport and sends ObjectMessages via a TopicConnection.\n* Has copyMessageOnSend=false\n* Has ObjectMessageSerializationDefered=true\n\nNode B:\n* In its own JVM instance.\n* Connects to Node A's broker via tcp transport.\n* Sends BytesMessages serialized with Kryo and sent via a TopicConnection.\n* Has copyMessageOnSend=false\n* Has ObjectMessageSerializationDefered=false\n\nBoth nodes are set up to detect the type of incoming messages and deserialize them appropriately with kryo if it receives a BytesMessage or default serialization if it receives an ObjectMessage (handled by ActiveMQ).\n\nThe only thing I have found resembling this issue is the following link. I am no sure if it is related to this exact problem or not.\n\nhttp://appcrawler.com/wordpress/2013/05/06/one-way-to-tell-if-a-thread-pool-is-hung/\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12618635","id":"12618635","filename":"tracelog.txt","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"created":"2013-12-13T17:26:01.603+0000","size":1668117,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12618635/tracelog.txt"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310041":null,"customfield_12310921":null,"customfield_12310920":"363690","customfield_12312823":null,"summary":"Deadlock caused by Re-entrant lock with no locking thread","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"Oracle JRE 1.7.0 update 45","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12684312/comment/13846875","id":"13846875","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"body":"I have discovered that the issue also occurs when only using Node A in a pure vm transport environment with ObjectMessageSerializationDefered=true and copyMessageOnSend=false on all connections. \n\nLooking through the ActiveMQ source it looks as if the object contents are still serialized despite ObjectMessageSerializationDefered=true on a call to ActiveMQObjectMessage.beforeMarshall(WireFormat wireFormat) which ends up calling ActiveMQObjectMessage.storeContent(). This call stack seems to be triggered by calls to the tcp transport methods. I was expecting that my configuration would prevent serialization entirely if not needed. I do not understand why TCP transport methods are still called despite the use of vm transport. I am assuming there is a reason for the calls to the tcp transport methods and serialization to still occur in this situation.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"created":"2013-12-12T23:07:10.328+0000","updated":"2013-12-12T23:07:10.328+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12684312/comment/13847465","id":"13847465","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"body":"you can only avoid serialization if both ends are inVM; Seems like you are producing to a topic over vm transport but you have more than one subscription over tcp and they are contending for access when they want to serialize.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"created":"2013-12-13T13:15:14.672+0000","updated":"2013-12-13T13:15:14.672+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12684312/comment/13847467","id":"13847467","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"body":"It may be worth building a simple test case that you can share.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"created":"2013-12-13T13:16:15.324+0000","updated":"2013-12-13T13:16:15.324+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12684312/comment/13847622","id":"13847622","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"body":"It looks as if the deadlock on the second test was actually not due to calling of the tcp transport methods but the copy method on the Message. It seems as if I did not have copyMessageOnSend=false set on this test. This was my mistake but it still raises more questions as to why this deadlock is happening as this instance does not involve tcp transport at all and only uses pure vm transport. Would multiple vm topic connections and subscriptions from the same running instance cause this issue?\n\nThe thing that is curious to me is that the deadlock summary shows that the threads spawned by the thread pool are blocked due to one of the other pooled threads yet I do not see where the thread acquires a lock on the object. I may be missing something in reading the thread dump when it comes to re-entrant locks.\n\nI will try to come up with a test case but I am not sure I will be able to reproduce the issue with a simple test case.\n\n\nFound one Java-level deadlock:\n=============================\n\"SERVER-com.xmlnamespace.panel.server.event.manager-8\":\n  waiting for ownable synchronizer 0xd6225130, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n  which is held by \"SERVER-com.xmlnamespace.panel.server.mtl.connection-3\"\n\"SERVER-com.xmlnamespace.panel.server.mtl.connection-3\":\n  waiting for ownable synchronizer 0xd74ab970, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n  which is held by \"SERVER-com.xmlnamespace.panel.server.mtl.manager-3\"\n\"SERVER-com.xmlnamespace.panel.server.mtl.manager-3\":\n  waiting for ownable synchronizer 0xd6225130, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n  which is held by \"SERVER-com.xmlnamespace.panel.server.mtl.connection-3\"\n\nJava stack information for the threads listed above:\n===================================================\n\"SERVER-com.xmlnamespace.panel.server.event.manager-8\":\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for  <0xd6225130> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n\tat java.util.concurrent.locks.LockSupport.park(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Unknown Source)\n\tat java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(Unknown Source)\n\tat java.util.concurrent.locks.ReentrantLock.lock(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.storeContent(ActiveMQObjectMessage.java:112)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.copy(ActiveMQObjectMessage.java:83)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.copy(ActiveMQObjectMessage.java:76)\n\tat org.apache.activemq.ActiveMQMessageConsumer.createActiveMQMessage(ActiveMQMessageConsumer.java:547)\n\tat org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1356)\n\t- locked <0xd5d22268> (a java.lang.Object)\n\tat org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)\n\tat org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat java.lang.Thread.run(Unknown Source)\n\"SERVER-com.xmlnamespace.panel.server.mtl.connection-3\":\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for  <0xd74ab970> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n\tat java.util.concurrent.locks.LockSupport.park(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Unknown Source)\n\tat java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(Unknown Source)\n\tat java.util.concurrent.locks.ReentrantLock.lock(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.storeContent(ActiveMQObjectMessage.java:112)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.copy(ActiveMQObjectMessage.java:83)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.copy(ActiveMQObjectMessage.java:76)\n\tat org.apache.activemq.ActiveMQMessageConsumer.createActiveMQMessage(ActiveMQMessageConsumer.java:547)\n\tat org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1356)\n\t- locked <0xd5caa638> (a java.lang.Object)\n\tat org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)\n\tat org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat java.lang.Thread.run(Unknown Source)\n\"SERVER-com.xmlnamespace.panel.server.mtl.manager-3\":\n\tat sun.misc.Unsafe.park(Native Method)\n\t- parking to wait for  <0xd6225130> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)\n\tat java.util.concurrent.locks.LockSupport.park(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Unknown Source)\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Unknown Source)\n\tat java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(Unknown Source)\n\tat java.util.concurrent.locks.ReentrantLock.lock(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat java.util.concurrent.ConcurrentHashMap.writeObject(Unknown Source)\n\tat sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n\tat java.lang.reflect.Method.invoke(Unknown Source)\n\tat java.io.ObjectStreamClass.invokeWriteObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.defaultWriteFields(Unknown Source)\n\tat java.io.ObjectOutputStream.writeSerialData(Unknown Source)\n\tat java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject0(Unknown Source)\n\tat java.io.ObjectOutputStream.writeObject(Unknown Source)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.storeContent(ActiveMQObjectMessage.java:112)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.copy(ActiveMQObjectMessage.java:83)\n\tat org.apache.activemq.command.ActiveMQObjectMessage.copy(ActiveMQObjectMessage.java:76)\n\tat org.apache.activemq.ActiveMQMessageConsumer.createActiveMQMessage(ActiveMQMessageConsumer.java:547)\n\tat org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1356)\n\t- locked <0xd5c89240> (a java.lang.Object)\n\tat org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)\n\tat org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)\n\tat org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129)\n\tat org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat java.lang.Thread.run(Unknown Source)\n\nFound 1 deadlock.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"created":"2013-12-13T16:25:15.077+0000","updated":"2013-12-13T16:25:52.737+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12684312/comment/13847683","id":"13847683","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"body":"Attached trace level log of ActiveMQ when the deadlock occurs.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"created":"2013-12-13T17:26:01.609+0000","updated":"2013-12-13T17:26:01.609+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12684312/comment/13863429","id":"13863429","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"body":"After further investigation the issue does not seem to be related to ActiveMQ. \n\nThe problem is a true deadlock that happens when you have two concurrent hash maps that reference each other and are serialized via two different threads.\n\nExample:\nLets say we have two ConcurrentHashMaps CHM1 and CHM2 which contain references to each other and two serialization threads T1 and T2.\n\n1) T1 locks CHM1\n2) T2 locks CHM2\n3) T1 attempts to serialize CHM2 since CHM1 references it but cannot obtain a lock since T2 already contains a lock on CHM2\n4) T2 attempts to serialize CHM1 since CHM2 references it but cannot obtain a lock since T1 already contains a lock on CHM1\n5) We have deadlock\n\nThis type of situation does not seem to comply with the intended concurrent nature of ConcurrentHashMap. The issues seems to have been resolved in Java 8. Back ports of the ConcurrentHashMap class from Java 8 to Java 7 have resolved the issue.\n\nhttps://bugs.openjdk.java.net/browse/JDK-8030805?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel\n\nIssue can be closed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mwolf9","name":"mwolf9","key":"mwolf9","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michael Yara","active":true,"timeZone":"Etc/UTC"},"created":"2014-01-06T21:17:31.365+0000","updated":"2014-01-06T21:17:31.365+0000"}],"maxResults":6,"total":6,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-4935/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i1qmzb:"}}