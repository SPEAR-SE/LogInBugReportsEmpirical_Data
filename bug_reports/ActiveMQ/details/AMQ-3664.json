{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12538611","self":"https://issues.apache.org/jira/rest/api/2/issue/12538611","key":"AMQ-3664","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12311210","id":"12311210","key":"AMQ","name":"ActiveMQ","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12311210&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12311210&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12311210&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12311210&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/11160","id":"11160","description":"ActiveMQ","name":"ActiveMQ"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12321258","id":"12321258","description":"Next v5 maintenance release","name":"5.7.0","archived":false,"released":true,"releaseDate":"2012-10-08"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2012-01-17T16:00:24.724+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Tue Sep 18 10:16:42 UTC 2012","customfield_12310420":"224115","customfield_12312320":null,"customfield_12310222":"1_*:*_1_*:*_21170300343_*|*_5_*:*_1_*:*_0","customfield_12312321":null,"resolutiondate":"2012-09-18T10:16:42.135+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-3664/watchers","watchCount":2,"isWatching":false},"created":"2012-01-17T09:38:21.805+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/2","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/critical.svg","name":"Critical","id":"2"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12318549","id":"12318549","name":"5.5.1","archived":false,"released":true,"releaseDate":"2011-10-16"}],"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2012-09-18T10:16:42.146+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12313892","id":"12313892","name":"Broker"}],"timeoriginalestimate":null,"customfield_12310080":null,"description":"I make performance test with activemq. When I set optimizeAcknowledge = true I get a dramatic performance improvement, but when I shut down the producer the consumer does not acknowledge all messages! If I stop the consumer and then I start the consumer a second time the consumer recieves messages again and again not all messages will be acknoledged in the queue.\n\nI am using camel 2.9.0 to produce and consume the messages.\nI am using the consumer Template with asyncSendBody.\nThe following route is configured in the camelContext:\n\n{noformat}\n\n    <camel:camelContext id=\"camelContext\">\n    \t<camel:template id=\"producerTemplate\"/>\n    \t<camel:consumerTemplate id=\"consumerTemplate\"/>\n    \t<camel:route>\n    \t\t<camel:from uri=\"jms:queue0?concurrentConsumers=3&amp;maxConcurrentConsumers=10&amp;asyncConsumer=true\"/>\n    \t\t<camel:to uri=\"beanConsumer\"/>\n    \t</camel:route>\n    </camel:camelContext>\n\nThe config for the ActiveMQComponent:\n    <bean id=\"jms\" class=\"org.apache.activemq.camel.component.ActiveMQComponent\">\n\t\t<property name=\"connectionFactory\">\t\t\n\t\t\t<bean class=\"org.apache.activemq.pool.PooledConnectionFactory\">\n   \t\t\t\t<property name=\"connectionFactory\">\n  \t\t\t\t\t<bean class=\"org.apache.activemq.spring.ActiveMQConnectionFactory\">\n   \t\t\t\t\t\t<property name=\"optimizeAcknowledge\" value=\"true\"/>\n   \t\t\t\t\t\t<property name=\"dispatchAsync\" value=\"true\"/>\n  \t\t\t\t\t\t<property name=\"sendAcksAsync\" value=\"true\"/>\n  \t\t\t\t\t\t<property name=\"useAsyncSend\" value=\"true\"/>\n\t\t\t\t \t\t<property name=\"brokerURL\" value=\"nio://138-ham-de:61616\"/>\t\t\t\t \t\t\n\t\t\t\t \t\t<property name=\"useDedicatedTaskRunner\" value=\"false\"/> \n    \t\t\t\t</bean>\t\n      \t\t\t</property>\n      \t\t</bean>\n      \t</property>\n    </bean>\n\n{noformat}\n\nI think, the problem is here:\nClass ActiveMQMessageConsumer:\n\n{noformat}\n\n    private void afterMessageIsConsumed(MessageDispatch md, boolean messageExpired) throws JMSException {\n        if (unconsumedMessages.isClosed()) {\n            return;\n        }\n        if (messageExpired) {\n            synchronized (deliveredMessages) {\n                deliveredMessages.remove(md);\n            }\n            stats.getExpiredMessageCount().increment();\n            ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n        } else {\n            stats.onMessage();\n            if (session.getTransacted()) {\n                // Do nothing.\n            } else if (isAutoAcknowledgeEach()) {\n                if (deliveryingAcknowledgements.compareAndSet(false, true)) {\n                    synchronized (deliveredMessages) {\n                        if (!deliveredMessages.isEmpty()) {\n                            if (optimizeAcknowledge) {\n                                ackCounter++;\n                                if (ackCounter >= (info.getPrefetchSize() * .65) || System.currentTimeMillis() >= (optimizeAckTimestamp + optimizeAckTimeout)) {\n                                \tMessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                \tif (ack != null) {\n                            \t\t    deliveredMessages.clear();\n                            \t\t    ackCounter = 0;\n                            \t\t    session.sendAck(ack);\n                            \t\t    optimizeAckTimestamp = System.currentTimeMillis();\n                                \t}\n                                }\n                            } else {\n                                MessageAck ack = makeAckForAllDeliveredMessages(MessageAck.STANDARD_ACK_TYPE);\n                                if (ack!=null) {\n                                    deliveredMessages.clear();\n                                    session.sendAck(ack);\n                                }\n                            }\n                        }\n                    }\n                    deliveryingAcknowledgements.set(false);\n                }\n            } else if (isAutoAcknowledgeBatch()) {\n                ackLater(md, MessageAck.STANDARD_ACK_TYPE);\n            } else if (session.isClientAcknowledge()||session.isIndividualAcknowledge()) {\n                boolean messageUnackedByConsumer = false;\n                synchronized (deliveredMessages) {\n                    messageUnackedByConsumer = deliveredMessages.contains(md);\n                }\n                if (messageUnackedByConsumer) {\n                    ackLater(md, MessageAck.DELIVERED_ACK_TYPE);\n                }\n            } \n            else {\n                throw new IllegalStateException(\"Invalid session state.\");\n            }\n        }\n    }\n\n{noformat}\n\nWhat will happen when no producer will send a message to this queue so that no message will pass this method? When will the deliveredMessages been acked?\n\n\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310041":null,"customfield_12310921":null,"customfield_12310920":"59246","customfield_12312823":null,"summary":"Not all messages will be acknowledged when optimizeAcknowledge is true","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=matw","name":"matw","key":"matw","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Matthias Wessel","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=matw","name":"matw","key":"matw","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Matthias Wessel","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"Windows 7 and Linux Debian with JRE 1.6.24 or JRE 1.6.27","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13187771","id":"13187771","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"body":"I suspect you need to explicitly set a cache level (use cacheLevel or cacheLevelName attributes) for the component. It defaults to cache_auto which means cache_consumer when there is no transaction. So the consumer is not actually closed.\nIf the consumer is closed, any outstanding auto ack will be dispatched.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"created":"2012-01-17T16:00:24.724+0000","updated":"2012-01-17T16:00:24.724+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13188421","id":"13188421","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=matw","name":"matw","key":"matw","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Matthias Wessel","active":true,"timeZone":"Etc/UTC"},"body":"When I switch to another cache than CACHE_AUTO or CACHE CONSUMER, I get a dramatic deterioration of performance. Then I am faster when I do not use ptimizeAcknowledge = true. This cannot be the goal of this setting!\nThe other problem is I do not want to close the consumer. Yes, I want to close the producer, but the consumer should consume and acknowledge all existing messages in the queue. The consumer should not care about how many producers produce messages to the queue. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=matw","name":"matw","key":"matw","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Matthias Wessel","active":true,"timeZone":"Etc/UTC"},"created":"2012-01-18T12:09:15.241+0000","updated":"2012-01-18T12:17:08.777+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13188430","id":"13188430","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"body":"How do you stop the consumer? When the consumer is stopped it needs to be shutdown, so if it is cached, it needs to be really closed, because optimizeAcknowledge delays acks (to batch them) for a period or till half of the prefetch is reached or till it is closed. The expectation is that there will be duplicate delivery if the consumer is not closed.\nThe default auto ack mode, does an immediate ack.\n\nThe other alternative is to use transactions to batch your client acks, I think this may be the simplest approach. \nAnother option is to use client ack mode and periodically call acknowledge, but with camel, this would require your own processor to get access to the underlying activemq message to call acknowledge.\n\nI think first, validate that the consumer is closed when it is shutdown.\n\nFor this case, we may need to introduce a consumer task that does a periodic ack, to catch the case where the consumer is cached, there is a pause in production, and there are pending acks. But in the abortive case, there may still be duplicates.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gtully","name":"gtully","key":"gtully","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Gary Tully","active":true,"timeZone":"Etc/UTC"},"created":"2012-01-18T12:50:54.988+0000","updated":"2012-01-18T12:50:54.988+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13451306","id":"13451306","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=davsclaus","name":"davsclaus","key":"davsclaus","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=davsclaus&avatarId=15835","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=davsclaus&avatarId=15835","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=davsclaus&avatarId=15835","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=davsclaus&avatarId=15835"},"displayName":"Claus Ibsen","active":true,"timeZone":"Europe/Berlin"},"body":"Gary\n\nYeah maybe a multiplexed background thread could run and acknowledge the messages if the consumer has been inactive for a period.\nI wonder if we can use a single thread for all optimized ack consumers, I would assume a thread per consumer would bee too much?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=davsclaus","name":"davsclaus","key":"davsclaus","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=davsclaus&avatarId=15835","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=davsclaus&avatarId=15835","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=davsclaus&avatarId=15835","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=davsclaus&avatarId=15835"},"displayName":"Claus Ibsen","active":true,"timeZone":"Europe/Berlin"},"created":"2012-09-08T10:20:04.820+0000","updated":"2012-09-08T10:20:04.820+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13453819","id":"13453819","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"The simplest thing would probably be to add a task to the Schedular instance that's owned by ActiveMQConnection that can check for time since last ack on the consumer and fire an ack if the configured time has elapsed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-09-12T08:02:00.917+0000","updated":"2012-09-12T08:02:00.917+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13457723","id":"13457723","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"added option optimizedAckScheduledAckInterval to Connection and MessageConsumer to allow for a configurable async ack of outstanding messages.  By default this option is set to zero, meaning no async acks are sent.  If the user wants to ensure all messages are acked at some point then they can enable this by setting to a value greater than zero.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-09-18T10:16:21.693+0000","updated":"2012-09-18T10:16:21.693+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12538611/comment/13457724","id":"13457724","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"body":"fixed in trunk.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tabish121","name":"tabish121","key":"tabish121","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tabish121&avatarId=25249","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tabish121&avatarId=25249","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tabish121&avatarId=25249","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tabish121&avatarId=25249"},"displayName":"Timothy Bish","active":true,"timeZone":"America/Havana"},"created":"2012-09-18T10:16:42.144+0000","updated":"2012-09-18T10:16:42.144+0000"}],"maxResults":7,"total":7,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/AMQ-3664/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0aicn:"}}