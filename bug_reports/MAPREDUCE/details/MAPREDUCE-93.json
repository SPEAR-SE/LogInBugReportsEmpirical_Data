{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12379954","self":"https://issues.apache.org/jira/rest/api/2/issue/12379954","key":"MAPREDUCE-93","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310941","id":"12310941","key":"MAPREDUCE","name":"Hadoop Map/Reduce","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310941&avatarId=10096","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310941&avatarId=10096","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310941&avatarId=10096","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310941&avatarId=10096"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2008-01-11T22:41:18.110+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Thu Feb 14 19:10:10 UTC 2008","customfield_12310420":"148495","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/MAPREDUCE-93/watchers","watchCount":10,"isWatching":false},"created":"2007-10-09T14:08:10.200+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[],"issuelinks":[{"id":"12318801","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12318801","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12385894","key":"HADOOP-2560","self":"https://issues.apache.org/jira/rest/api/2/issue/12385894","fields":{"summary":"Processing multiple input splits per mapper task","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133}}}},{"id":"12319073","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12319073","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12381400","key":"HADOOP-2119","self":"https://issues.apache.org/jira/rest/api/2/issue/12381400","fields":{"summary":"JobTracker becomes non-responsive if the task trackers finish task too fast","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/2","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/critical.svg","name":"Critical","id":"2"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2009-06-20T07:50:53.155+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":"Currently, when the Job Tracker assigns a mapper task to a task tracker and there is no local split to the task tracker, the\njob tracker will find the first runable task in the mast task list  and assign the task to the task tracker.\nThe split for the task is not local to the task tracker, of course. However, the split may be local to other task trackers.\nAssigning the that task, to that task tracker may decrease the potential number of mapper attempts with data locality.\nThe desired behavior in this situation is to choose a task whose split is not local to any  task tracker. \nResort to the current behavior only if no such task is found.\n\nIn general, it will be useful to know the number of task trackers to which each split is local.\nTo assign a task to a task tracker, the job tracker should first  try to pick a task that is local to the task tracker  and that has minimal number of task trackers to which it is local. If no task is local to the task tracker, the job tracker should  try to pick a task that has minimal number of task trackers to which it is local. \n\nIt is worthwhile to instrument the job tracker code to report the number of splits that are local to some task trackers.\nThat should be the maximum number of tasks with data locality. By comparing that number with the the actual number of \ndata local mappers launched, we can know the effectiveness of the job tracker scheduling.\n\nWhen we introduce rack locality, we should apply the same principle.\n\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"107694","customfield_12312823":null,"summary":"Job Tracker should prefer input-splits from overloaded racks","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=runping","name":"runping","key":"runping","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Runping Qi","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=runping","name":"runping","key":"runping","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Runping Qi","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12558155","id":"12558155","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"body":"An ideal solution would maintain some sort of prioritized list of maps / node / rack so that we execute work first that is unlikely to find another efficient location to execute.\n\nIt would also make sense to place some no local work early, since these tasks run slowly, on nodes that are likely to run out of local work relatively early.\n\nOne could also pay attention to IO load on each source node...\n\nAt a minimum we should track maps that have no local option and schedule them first when a node has no local option.  (As doug cutting suggested in HADOOP-2560)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-01-11T22:41:18.110+0000","updated":"2008-01-11T22:41:37.258+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12566814","id":"12566814","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"body":"I've thought about this one, and I think that after HADOOP-1985, we should do the following:\n\nFor each rack and job:\n  Keep the number of runnable (but not running) input splits that are local to that rack\n  Keep the total number of map slots in each rack\n\nWhen we need to assign a non-rack-local task, we should find the rack that has the highest ratio of runnableSplits / mapSlots and take a task from that rack. Clearly as a special case, any input split on a rack with no task trackers will be preferred, but it will also take input splits from the most overloaded racks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-07T21:58:57.013+0000","updated":"2008-02-07T21:58:57.013+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12566911","id":"12566911","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"body":"of course since blocks are on multiple racks, pulling blocks from overloaded racks may be a bad strategy...  Why not execute them locally on another rack...\n\nAlso in the interest of IO interleaving, you want to do some amount of off rack reading early and not wait until the job is guarantied to be the long pole.\n\nMy bet is that some amount of pre planning is going to prove necessary to get a semi optimal plan.  Maybe generating a sorted list of blocks to choose per spindle on a node and than one per rack and then a final remote list.  That plus some sort of % off rack target might be good.  You could store this very efficiently or on disk...\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-08T04:36:38.791+0000","updated":"2008-02-08T04:36:38.791+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12567015","id":"12567015","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"body":"I assume that this priority is valid across all the tasks, i.e we should also prefer data-local speculation over remote ones if at all there is a cached task that requires speculation else fall back to the current strategy.\n_Scenario_\n{noformat}\nHosts : Cached Tasks\nH1 : T1, T2\nH2 : T2, T3\nH3 : T3, T4\nH4 : T4\n{noformat}\n_Stages_\n{noformat}\n1. H1,H2,H3,H4 ask for task and get T1,T2,T3,T4 respectively.\n2. H2, H4 are slow and require speculation\n3. H3 finished and asks for more, gets T2\n4. H1 finishes and asks for more, gets T4\n{noformat}\nIdeally H3 should get T4 and H1 should get T2, no?\nSo, the algorithm would be\n{code}\n1. Find a Runnable && ~Running task\n    1.1 Scan the cache but maintain the runnable local tasks.\n    1.2 Scan all the tasks to find out a task that has the lowest number of data-local trackers (and also some load/rack/io/map-slots considerations).\n2. Find a task that has failed on all machines // fail early\n3. Find a task for speculation\n    1.1 Check if there is a local task that can be speculated\n    1.2 Scan all the tasks with lowest number of data-local trackers (and also some load/rack/io/map-slots considerations).\n{code} \n\nThoughts?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"created":"2008-02-08T12:22:21.256+0000","updated":"2008-02-08T12:22:21.256+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12567020","id":"12567020","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"body":"bq. In general, it will be useful to know the number of task trackers to which each split is local.\nCant we just have a count of the maximum number of trackers that are having the split in the TIP itself? ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"created":"2008-02-08T12:37:02.447+0000","updated":"2008-02-08T12:37:02.447+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12567453","id":"12567453","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=acmurthy","name":"acmurthy","key":"acmurthy","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arun C Murthy","active":true,"timeZone":"America/Los_Angeles"},"body":"bq.     1.2 Scan all the tasks to find out a task that has the lowest number of data-local trackers (and also some load/rack/io/map-slots considerations).\n\nbq.     1.2 Scan all the tasks with lowest number of data-local trackers (and also some load/rack/io/map-slots considerations).\n\nUh, both are _very_ expensive to do on every heartbeat (i.e. the inner loop) isn't it?!\n\nThe reasoning behind Owen's proposal considering the 'ratio' of {{runnableSplits / mapSlots}} is to get around the case where there are very few task-trackers in a rack. E.g. Lets say there are 200 splits on a rack1 with 10 task-trackers (4 slots each) on it, and 100 splits on rack2 with 2 task-trackers... then the ratio penalizes rack2 rather than rack1, which is the right call to make.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=acmurthy","name":"acmurthy","key":"acmurthy","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arun C Murthy","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-10T17:37:07.983+0000","updated":"2008-02-10T17:37:07.983+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12567548","id":"12567548","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"body":"bq. Uh, both are very expensive to do on every heartbeat (i.e. the inner loop) isn't it?!\nI should have mentioned it earlier. I was trying to link HADOOP-2119 and HADOOP-2014 since HADOOP-2119 deals with {{JobInProgress.findNewTask()}}. The algorithm mentioned above is for {{JobInProgress.findNewTask()}}. I got Owen's point thats why I mentioned\n{quote}\n(and also some load/rack/io/map-slots considerations)\n{quote}\nJust wanted to make sure that we also do the same for _speculation_. From what I followed, the discussion is mainly for {{Runnable && ~Running}}.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"created":"2008-02-11T08:34:37.884+0000","updated":"2008-02-11T08:34:37.884+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12568770","id":"12568770","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"body":"I think that Eric's proposal of making a reasonable guess at the start of execution sounds good. How about, for each rack we calculate:\n\nrack load(R) = min(1000, # splits local to rack R / # map slots in rack R)\n\nwhere higher numbers are more \"overloaded\" racks. Then each split can be given a load score by something like:\n\nsplit load = avg(rack load of each replica)\n\nand at job creation, we sort a list on the split load (highest to lowest) for all of the map tips. When we need a non-local task, we take from the front of the list.\n\nThoughts?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-14T00:32:52.931+0000","updated":"2008-02-14T00:32:52.931+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12568806","id":"12568806","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"body":"Makes sense. I had some similar thoughts but not on task ordering (initially) but on task scheduling after cache miss (at rack level), see HADOOP-2812. \nI opened a new issue since this issue explicitly specifies _rack_. \n\nOn similar lines we can have\n1) machine load = _f_(machine) = _some_function_of_(num-splits-local) ... useful in intra-rack scheduling,\n_f_ should give some indication of the expected time to process all the maps i.e\n_f_(machine) = (num-local-splits - num-processed ) * avg-processing-time / _MAX_\ninitial value of avg-processing-time = _MAX_\n\n2) split-load = _s_(split) = _min_(loads of machine having this split locally)\n\n3) rack-load = _r_(rack) = _max_( load of splits local to the rack)/ num-map-slots .. useful in inter-rack scheduling \nThis gives priority to the rack with the highest loaded split. \n_avg_ can be used instead of _max_ in (3) which will give priority to the rack with highest avg load.\n\nWould this be a better metric? \nThoughts?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=amar_kamat","name":"amar_kamat","key":"amar_kamat","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Amar Kamat","active":true,"timeZone":"Etc/UTC"},"created":"2008-02-14T05:54:25.825+0000","updated":"2008-02-14T05:54:25.825+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12568822","id":"12568822","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"body":"Sorry amar, maybe I don't follow.  Seems complicated.  We can implement and load test a few strategies using gridmix.\n\nOwen, we should pick tasks on each node and each rack using the same metric (split load) as well.  All lists should be sorted by it?\n\nRather than having another list to maintain, we could perhaps just keep the rack lists (and the node lists recursively) in heaps perhaps?  The heap is ordered by split load and allows you to quickly choose the rack with the task with the highest split load.  Less to maintain that way perhaps.\n\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-14T07:07:13.409+0000","updated":"2008-02-14T07:07:13.409+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12568831","id":"12568831","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"body":"Amar, the reason to focus on racks instead of nodes is that the read time for rack local is just a bit slower than node local. Since there are a bunch of nodes in each rack, the decisions are more stable and more efficient.\n\nEric, it isn't clear to me that split load is more important than split size when we are choosing between local tasks. I guess in the typical case, split load *is* better, because almost all of the splits are the block size. By prioritizing on split load, we should substantially increase the locality of most jobs.\n\nWhen I was talking about the list, I assume it is really just part of the data structure in from HADOOP-2119.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-14T08:43:42.785+0000","updated":"2008-02-14T08:43:42.785+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12379954/comment/12569048","id":"12569048","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"body":"At some point we'll need to put a lot more work into this!  How to trade off rack vs local vs size is very interesting.\n\nThat said, when you look at our current execution profiles, we have long tails because maps are not running locally.  Anything we can do to reduce that should lead to speedups.\n\nWe should run some experiments.  We should not neglect the one rack case, where size should probably dominate.  Maybe we can express rack load as the probability that a block will execute locally and then weight that by the cost to ship bytes?  This varies of course based on your network...  We could choose some constants for on and off rack to get started.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"created":"2008-02-14T19:10:10.987+0000","updated":"2008-02-14T19:10:10.987+0000"}],"maxResults":12,"total":12,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/MAPREDUCE-93/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0ise7:"}}