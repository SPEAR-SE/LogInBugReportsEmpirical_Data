[Uploading latest addendum patch from MAPREDUCE-5364., Addressing Sid's comments from MAPREDUCE-5364,

bq. The previous patch is likely better. One concern with the current patch - 'cancelled' is associated with the current RenewalTimerTask. If removeDelegationTokenRenewalForJob tries to cancel() while a token renewal is in progress - it effectively has no affect, since a new RenewalTimerTask would be scheduled.

Indeed this is an issue. We should definitely fix that here, but this has always been the case and is not a regression introduced by MAPREDUCE-4860 or MAPREDUCE-5364.

, Uploading a patch that refactors {{DelegationTokenRenewal}} to address the races and improves readability.

Following are the major changes:
# {{RenewalTimerTask}} along with scheduling/cancelling logic is moved to {{DelegationTokenToRenew}}
# {{DelegationTokenToRenew#timerTask}} is used to capture the cancellation of both token/{{TimerTask}}., {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12592115/mr-5384-1.patch
  against trunk revision .

    {color:red}-1 patch{color}.  The patch command could not apply the patch.

Console output: https://builds.apache.org/job/PreCommit-MAPREDUCE-Build/3848//console

This message is automatically generated., We're in final stage of producing 1.2.1-rc.  Moving this new issue to targetVersion 1.3.0., [~sseth], given you reviewed MAPREDUCE-5364, can you please take a look at this too when you get a chance. , We should avoid any rpc operations (token renewal) inside of a synchronized block. Currently it looks like a cancel operation could end up synchronizing on such an operation which can take time., [~sseth], good point. I thought about it, and think it should be okay for the following reasons. Please advise if you think otherwise:
# The patch moves all the renewal/cancellation to DelegationTokenToRenew. So, any synchronization is only on operations on one token.
# To address the issue in MAPREDUCE-4860, we should serialize the renew() and cancel() calls for a DTTR.
# The token cancellation (RPC) is not synchronized, only the renewal is., Isn't it possible for removeDelegationTokenRenewalForJob (during the cancel call) to synchronize on a token which may be stuck in a renewal RPC call ?, [~sseth], very good point. In my testing, I noticed the renewal RPC takes about 5 ms and could take longer.

Uploading a patch that addresses this issue
# Call token.renew() outside of a synchronized block
# To address the potential race with cancel(), cancel() now returns a boolean - true if it successfully cancels all renewals and false if there is a renewal currently in progress. Renewing once after the cancel() is called is benign, but the user can be intimated about this renewal in progress.
# TestDelegationTokenRenewal uses this intimation to allow for an extra renewal.

Testing: Ran the new TestDelegationTokenRenewal in a loop 10 times and it passed., {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12596421/mr-5384-2.patch
  against trunk revision .

    {color:red}-1 patch{color}.  The patch command could not apply the patch.

Console output: https://builds.apache.org/job/PreCommit-MAPREDUCE-Build/3934//console

This message is automatically generated., [~sseth], can you take a look at the updated patch when you get a chance. Thanks., Karthik, apologies, I haven't been able to get to this earlier.

With the latest patch, I'm not sure which race is being fixed. It looks like a cancel while a RenewalTimer is running, will still lead to an additional Renewal being scheduled for the same token, which is the same behaviour without the patch. Have some concerns with synchronization / thread safety in the patch as well - leaving those out.

Instead of the relatively large changes in the patch, I think it'll be a lot simpler to just associate a 'cancel'/'intentToCancel' flag with the token to prevent renewal attempts after a cancel is called. The in-process renew can check these till the last moment before invoking the actual renew, and subsequent renewals will not attempt a renew (maybe even not schedule a renew). The changes to the unit test will likely still be required - to allow the one extra in-flight renew.

Do you know if this problem exists in the 2.x renewer as well ?, Thanks much, Sid. Sorry for the delay, have been busy with RM HA work and haven't had a chance to look at this. 

It will probably be a while before I can spend sometime on this.]