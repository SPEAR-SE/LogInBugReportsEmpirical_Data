[GitHub user javeme opened a pull request:

    https://github.com/apache/hadoop/pull/177

    MAPREDUCE-6827. Failed to traverse Iterable values the second time in…

    … reduce() method
    
    The following code is a reduce() method (of WordCount):
    
    
    	public static class WcReducer extends Reducer<Text, IntWritable, Text, IntWritable> {
    
    		@Override
    		protected void reduce(Text key, Iterable<IntWritable> values, Context context)
    				throws IOException, InterruptedException {
    
    			// print some logs
    			List<String> vals = new LinkedList<>();
    			for(IntWritable i : values) {
    				vals.add(i.toString());
    			}
    			System.out.println(String.format(">>>> reduce(%s, [%s])",
    					key, String.join(", ", vals)));
    
    			// sum of values
    			int sum = 0;
    			for(IntWritable i : values) {
    				sum += i.get();
    			}
    			System.out.println(String.format(">>>> reduced(%s, %s)",
    					key, sum));
    
    			context.write(key, new IntWritable(sum));
    		}
    	}
    
    After running it, we got the result that all sums were zero!
    
    After debugging, it was found that the second foreach-loop was not executed, and the root cause was the returned value of Iterable.iterator(), it returned the same instance in the two calls by foreach-loop. In general, Iterable.iterator() should return a new instance in each call, such as ArrayList.iterator(). This patch fixed the bug.
    
    Signed-off-by: Javeme <javaloveme@gmail.com>

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/javeme/hadoop foreach-bug-of-ValueIterable

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/hadoop/pull/177.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #177
    
----
commit 6c323fdc1a0013938d09b09b2e16061910a92c97
Author: Javeme <javaloveme@gmail.com>
Date:   2016-12-30T11:39:20Z

    MAPREDUCE-6827. Failed to traverse Iterable values the second time in reduce() method
    
    The following code is a reduce() method (of WordCount):
    
    	public static class WcReducer extends Reducer<Text, IntWritable, Text, IntWritable> {
    
    		@Override
    		protected void reduce(Text key, Iterable<IntWritable> values, Context context)
    				throws IOException, InterruptedException {
    
    			// print some logs
    			List<String> vals = new LinkedList<>();
    			for(IntWritable i : values) {
    				vals.add(i.toString());
    			}
    			System.out.println(String.format(">>>> reduce(%s, [%s])",
    					key, String.join(", ", vals)));
    
    			// sum of values
    			int sum = 0;
    			for(IntWritable i : values) {
    				sum += i.get();
    			}
    			System.out.println(String.format(">>>> reduced(%s, %s)",
    					key, sum));
    
    			context.write(key, new IntWritable(sum));
    		}
    	}
    
    After running it, we got the result that all sums were zero!
    
    After debugging, it was found that the second foreach-loop was not executed, and the root cause was the returned value of Iterable.iterator(), it returned the same instance in the two calls by foreach-loop. In general, Iterable.iterator() should return a new instance in each call, such as ArrayList.iterator(). This patch fixed the bug.
    
    Signed-off-by: Javeme <javaloveme@gmail.com>

----
, Github user javeme commented on the issue:

    https://github.com/apache/hadoop/pull/177
  
    NOTE: The following is a test about foreach with int[]/ArrayList, and the test results are expected(the second for-loop is also executed correctly):
    
    	import java.util.ArrayList;
    	
    	public class TestForeach {
    	
    		public static void main(String[] args) {
    			
    			// test foreach twice with int[]
    			int list1[] = new int[]{1, 2};
    			
    			System.out.println("==== int[] 1");
    			for(int i : list1) {
    				System.out.println(i);
    			}
    			
    			System.out.println("===int[] 2");
    			for(int i : list1) {
    				System.out.println(i);
    			}
    			
    			// test foreach twice with ArrayList
    			ArrayList<String> list = new ArrayList<String>();
    			list.add("1");
    			list.add("2");
    			Iterable<String> list2 = list;
    	
    			System.out.println();
    			System.out.println("===ArrayList 1");
    			for(String i : list2) {
    				System.out.println(i);
    			}
    			
    			System.out.println("===ArrayList 2");
    			for(String i : list2) {
    				System.out.println(i);
    			}
    		}
    	
    	}

, That is known, documented, and intended behavior.  The {{ValueIterator}}'s {{hasNext()}} and {{next()}} methods defer defer to the {{ReduceContextImpl}}'s {{BackupStore}} instance, so creating a new iterator won't help.  The reason we only go through the values once is to allow the data to be efficiently streamed., Github user javeme commented on the issue:

    https://github.com/apache/hadoop/pull/177
  
    According to [Daniel Templeton](https://issues.apache.org/jira/browse/MAPREDUCE-6827?focusedCommentId=15795763&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15795763), we think it is expected.
, Github user javeme closed the pull request at:

    https://github.com/apache/hadoop/pull/177
]