[Just attaching two of the jcarder graphs. There are 12 cycles, but they're all essentially the same issue.

This was fixed by MAPREDUCE-870 in branch-21 and trunk., Attaching a patch to solve this problem. This locks the JT and then the taskScheduler in that order before calls that will lock the JobInProgress, per the discussion on MAPREDUCE-1436. 

No new unit tests added because it's a deadlock issue.

Instead I tested manually by running two jobs in a row on a pseudo-distributed cluster and inspecting the JobTracker state with JCarder. I did this with both FIFO and fair scheduler. The issue reproduces without this patch; adding this patch makes JCarder return "no cycles detected."

, You may want to consider applying this on 0.20.3., All the methods in jcarder graphs : assignTasks(), finalizeJob(), getSetupCleanupTasks() are in a heartbeat which is under JobTracker lock. Since, everything is under JobTracker lock, there is no deadlock. Am I missing any thing, here?
MAPREDUCE-805 fixes a deadlock to do with initJob() and finalizeJob() in branch 0.20.1. , The JobTracker lock is not the issue. finalizeJob locks the JobTracker's TaskScheduler instance after taking the lock on the JobTracker itself. Per MAPREDUCE-1436, the lock order is JT -> TS -> JIP. Locking JT -> JIP -> TS is a deadlock. This patch adds locks on the TaskScheduler instance to ensure the correct order is held., Aaron,
JT->TS->JIP and JT->JIP->TS is not a deadlock.  What Amareshwari is trying to say is that if the parent level lock is same (JT in this case) then the child locking order doesnt really matter. Also the code which you have fixed is in RecoveryManager which runs before the JobTracker becomes RUNNING and the tasktracker connects to the jobtracker. I dont think MAPREDUCE-1436 is a duplicate of MAPREDUCE-1499., I agree with Amar that if the inversion is gated by the JT lock then there is no deadlock potential. JCarder, in theory, is supposed to detect the gating lock and ignore the cycle. Let me look into the jcarder side of this a bit more and see if it's a bug there or if we are missing something., Amar,

Thanks for the clarification. I believed there were other instances where there was a lock ordering of TS-> JIP without the JT gate, but it seems now that this is only in the fair scheduler. I went back and ran tests again and the deadlock cycle did not reproduce in the FIFO scheduler with or without the patch. (We can't get jcarder to regenerate the attached graphs with the FIFO scheduler, so it seems as though this issue is a false alarm.)

I'm going to close this as Cant-Reproduce.
, The problem in MAPREDUCE-1436 only happened with a backport of the trunk fair scheduler to 0.20. It probably won't happen with the 0.20 fair scheduler. However, anyone packaging a distribution that includes a backport of the fair scheduler should look into it. As I mentioned in MAPREDUCE-1436, the fix (adding a lock around the TaskTrackerManager in update() is simple and is unlikely to have a major impact on performance.]