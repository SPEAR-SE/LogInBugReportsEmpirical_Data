[This patch executes the token file writing to DFS as the logged in job tracker user.  I don't know if there is a better approach, but this resolves the issue for me., I'm not familiar with the fair scheduler.  However it would seem to me that instead of flipping the user back to the JT, that perhaps the {{UGI.doAs()}} the remote user should be pushed down further in the callstack?
, Patch that ported FairScheduler from trunk into 0.20-security branch seems to be the cause of this., I'm not sure pushing down the remote user UGI.doAs() is really possible.  As I understand it, the current problem is the UGI.doAs() wrapping the entire RPC call invocation up in org.apache.hadoop.ipc.Server$Handler.run():
{code}
CurCall.set(call);
try {
  // Make the call as the user via Subject.doAs, thus associating
  // the call with the Subject
  if (call.connection.user == null) {
    value = call(call.connection.protocol, call.param, 
                 call.timestamp);
  } else {
    value = 
        call.connection.user.doAs
            (new PrivilegedExceptionAction<Writable>() {
               @Override
               public Writable run() throws Exception {
                 // make the call
                 return call(call.connection.protocol, 
                             call.param, call.timestamp);

               }
             }
            );
  }
{code}

Prior to MAPREDUCE-2981, as I understand it, JobTracker.initJob() was being invoked in a separate thread by the scheduler, not under the RPC handler thread.  So it was picking up the JobTracker login user since it wasn't running under a UGI.doAs() block.

I haven't checked the FairScheduler code in 0.23 or trunk to see how it's handled there.  Maybe that would provide another alternative.  Or changing FairScheduler$JobInitializer to run in a separate thread and pull jobs to initialize from a queue might work as well.  Maybe that's more along the lines of what you were thinking?  I just tried the least intrusive approach., That begs the question: was MAPREDUCE-2981 ported incorrectly?  Otherwise why doesn't 23/trunk have this issue?  If there is just a fundamental difference in 23 vs 205, the minimalist approach is probably best for 205., From looking at the current code in branch-0.23, it seems that version of the fair scheduler code has the same problem.  But, according to MAPREDUCE-2736, the fair scheduler contrib is slated for removal in 0.23.  So I don't know if there is any point in attempting a more extensive refactoring of the fair scheduler code to avoid the problem, as opposed to the simpler fix that I posted.]