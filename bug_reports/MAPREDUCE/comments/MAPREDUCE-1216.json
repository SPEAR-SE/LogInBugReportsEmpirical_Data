[I'm not sure I follow your logic. The values associated with a key do not have a well-defined sort order. Therefore, neither should MRUnit. However, the keys associated with a reducer are sorted. 

In MRUnit a ReduceDriver can only handle a single input key, but the MapReduceDriver will allow you to pass an arbitrary set of key-value pairs (bounded by memory) from the mapper to the reducer. The keys forwarded from the mapper to the reducer via this driver will be sorted.

If you want to test Hadoop's sorting semantics yourself, create two files. Put the letters 'a' through 'z' in one file, one-per-line, in ascending order. In the other file, put the same lines in descending order ('z' down to 'a').

Then run this program:

{code}
public class Foo {
  public static void main(String [] args) throws Exception {
    Job job = new Job();
    job.setJarByClass(Foo.class);
    FileInputFormat.addInputPath(job, new Path("in"));
    FileOutputFormat.setOutputPath(job, new Path("out"));
    job.setNumReduceTasks(1);
    job.waitForCompletion(true);
  }
}
{code}

This will use the identity mapper and reducer.

A fragment of the output I get is:
{code}
44	d
44	w
46	x
46	c
{code}

.. demonstrating that the values are not necessarily sorted within a key.

I think that MRUnit has helped you catch a bug in your deduplication reducer :)
]