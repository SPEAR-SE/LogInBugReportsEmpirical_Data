[Thanks for the change Bikas!

A few questions/suggestions:
1. In {{WindowsResourceCalculatorPlugin#getProcResourceValues()}} you mention that some tests use JVM_PID. Do you happen to have a list of these tests?
2. Can you please refactor {{ResourceCalculatorPlugin#getResourceCalculatorPlugin()}} to accept processPid, and update call sites to pass the appropriate value (I see only 3 call sites). The cause of this bug in the first place is not having all call sites set the processPid accordingly. And then, if the passed-in processPid is null, you can fallback to {{System.getenv().get("JVM_PID")}}. Make sense? If I'm seeing things correctly, this way you might be able to clean up some of the newly introduced code.
, Let me look at that. I was thinking about revisiting that too., Actually, the cause of this bug was a null JVMContext and not an invalid ProcessPid. I should have kept the other process pid changes separate from this bug fix., bq. Actually, the cause of this bug was a null JVMContext and not an invalid ProcessPid. I should have kept the other process pid changes separate from this bug fix.
Right, there are two fixes in your change. I still believe that it would be useful to refactor {{ResourceCalculatorPlugin#getResourceCalculatorPlugin()}} to accept processPid and explicitly pass it on the call site.

On a related note, I'm not a fan of the fallback to {{System.getenv().get("JVM_PID")}} on Windows, that's why I asked for the list of tests :) Might be fine at this point, but it is something we should take a look at later., Removing the implicit JVM_PID usage and explicitly calling Plugin.setProcessId() at call sites., Thanks Bikas, change looks much better.

I have two additional questions:
1. I see that you still kept the setProcessPid() separate. Is there a reason for going with this model instead of passing it as part of {{ResourceCalculatorPlugin.getResourceCalculatorPlugin()}}?
2. In Task.java, you now initialize {{resourceCalculator}} to {{null}} if {{jvmContext}} is {{null}}. Before your original change for MAPREDUCE-4203, we would have the {{resourceCalculator}} with {{System.getenv("JVM_PID")}} as the {{processPid}}. Is there a scenario where the old behavior is desired?, 1) Thats because ResourceCalculatorPlugin.getResourceCalculatorPlugin() is called multiple times and it makes to initialize it once. Also, the process id is not available at all call sites. Ideally I would like to replace use of ResourceCalculatorPlugin with ResourceCalculatorProcessTree in all these places but I dont want to do cross file refactoring in a branch.

2) Thats because in the normal case the JVM_PID is defined and used. In the local runner case, there is no JVM_PID defined and hence I chose to leave resourceCalculator null in that case. The code knows how to deal with null resourceCalculator but I am wary of leaving a poorly initialized resource calculator. Until now we were lucky that the poorly initialized resourceCalculator did not behave badly and safely ignored the null pid. However, it would return incorrect resource values. I think its better to null it and be explicit that it is not present vs use an invalid plugin. Also, I have changed direct use of JVM_PID env with using the jvmContext. That leaves the dependence of initializing task pid at 1 place(initialization of jvmContext)., Thanks Bikas, that makes sense.

+1, change looks good., I just committed this. Thanks Bikas!]