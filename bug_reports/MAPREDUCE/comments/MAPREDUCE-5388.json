[from the logs the TaskTracker produced when it war reinitializing,  the stack of method is that:
{code}
+org.apache.hadoop.mapred.TaskTracker$TaskLauncher.run
  -org.apache.hadoop.mapred.TaskTracker.startNewTask
   -org.apache.hadoop.mapred.TaskTracker.localizeJob   -org.apache.hadoop.mapred.TaskTracker.launchTaskForJob
   -org.apache.hadoop.mapred.TaskTracker.TaskInProgress.kill
   -org.apache.hadoop.mapred.TaskTracker.TaskInProgress.cleanup    -org.apache.hadoop.mapred.TaskTracker.TaskInProgress.removeTaskFiles
     -org.apache.hadoop.mapred.CleanupQueue.addToQueue
      -org.apache.hadoop.mapred.CleanupQueue$PathCleanupThread.addToQueue
{code} 
the source code is:
{code}
private static class PathCleanupThread extends Thread {

    // cleanup queue which deletes files/directories of the paths queued up.
    private LinkedBlockingQueue<PathDeletionContext> queue =
      new LinkedBlockingQueue<PathDeletionContext>();

    public PathCleanupThread() {
      setName("Directory/File cleanup thread");
      setDaemon(true);
      start();
    }

    void addToQueue(PathDeletionContext[] contexts) {
      for (PathDeletionContext context : contexts) {
        try {
          queue.put(context);
        } catch(InterruptedException ie) {}
      }
    }

    public void run() {
      if (LOG.isDebugEnabled()) {
        LOG.debug(getName() + " started.");
      }
      PathDeletionContext context = null;
      while (true) {
        try {
          context = queue.take();
          context.deletePath();
          // delete the path.
          if (LOG.isDebugEnabled()) {
            LOG.debug("DELETED " + context);
          }
        } catch (InterruptedException t) {
          LOG.warn("Interrupted deletion of " + context);
          return;
        } catch (Throwable e) {
          LOG.warn("Error deleting path " + context, e);
        } 
      }
    }
  }
{code}
Maybeï¼Œ the map TaskLauncher thread was interrupted when it was invoking the method-addToQueue, so that the interruption was processed and the TaskLauncher could keep running., We fix that:
{code}
private static class PathCleanupThread extends Thread {

    // cleanup queue which deletes files/directories of the paths queued up.
    private LinkedBlockingQueue<PathDeletionContext> queue =
      new LinkedBlockingQueue<PathDeletionContext>();

    public PathCleanupThread() {
      setName("Directory/File cleanup thread");
      setDaemon(true);
      start();
    }

    void addToQueue(PathDeletionContext[] contexts) {
+     boolean interrupted = false;
      for (PathDeletionContext context : contexts) {
        try {
          queue.put(context);
        } catch(InterruptedException ie) {
+         interrupted = true;
        }
      }

+     if(interrupted){
+         Thread.currentThread().interrupt();
+     }
    }

    public void run() {
      if (LOG.isDebugEnabled()) {
        LOG.debug(getName() + " started.");
      }
      PathDeletionContext context = null;
      while (true) {
        try {
          context = queue.take();
          // delete the path.
          if (!deletePath(context)) {
            LOG.warn("CleanupThread:Unable to delete path " + context.fullPath);
          }
          else if (LOG.isDebugEnabled()) {
            LOG.debug("DELETED " + context.fullPath);
          }
        } catch (InterruptedException t) {
          LOG.warn("Interrupted deletion of " + context.fullPath);
          return;
        } catch (Exception e) {
          LOG.warn("Error deleting path " + context.fullPath + ": " + e);
        }
      }
    }
  }
{code}]