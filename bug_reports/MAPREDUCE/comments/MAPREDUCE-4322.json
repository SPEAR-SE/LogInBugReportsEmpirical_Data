[Attaching the patch.

The fix is to separate the classpath into an environment variable instead of passing it via "java -classpath".

In some test cases we've seen command line length go slightly above 8192 characters what is the Windows command line limit. ~4k goes into the classpath, and the rest goes on other command line arguments. By separating out the classpath we now have plenty of room for other args. 

The patch also introduces checks on the command length before it is executed, and surfaces a nice error message if the length exceeds the limit. Otherwise, we would only see that the child task exited with non 0 code, and we would not have any context on the reason for a failure., Has this been run on a Linux/Unix platform to make sure things are not broken?, bq. Has this been run on a Linux/Unix platform to make sure things are not broken?
Thanks for reviewing the patch Bikas. Yes, I've done a test run on Linux before posting a patch., Sorry. I forgot the review comments themselves.
1) TaskLog.java - Any special reasons to perform the command line length check multiple times instead of once at the end of buildCommandLine()?
2) the advantage with the -classpath argument was isolation of the classpath to the specific spawned JVM. But by changing the classpath env var we risk changing it for every spawned process too. Maybe thats not much of a problem.
3) What if CLASSPATH is already set on the machine? Will this append to it or override it? From the code it looks like generating the classpath list will pick up the parent classpath. So if CLASSPATH env var is already set then it will be part of classpath list via the parent jvm (TaskTracket jvm). So even if the taskjvm.cmd sets the CLASSPATH it will be a superset of any existing CLASSPATH env var. Can you please verify this by having a pre-existing CLASSPATH set?
, bq. TaskLog.java - Any special reasons to perform the command line length check multiple times instead of once at the end of buildCommandLine()?
There are multiple lines that we want to execute as part of the taskjvm.cmd, and I am checking the length of every line. Example taskjvm.cmd is the following:
{code}
set HADOOP_CLIENT_OPTS=...
set SHELL="cmd"...
...
set CLASSPATH=...
C:\...\jre\bin\java ...
{code}

bq. the advantage with the -classpath argument was isolation of the classpath to the specific spawned JVM. But by changing the classpath env var we risk changing it for every spawned process too. Maybe thats not much of a problem.
I thought of this as well. As we are starting a separate bash/cmd for every task, this will only apply to that task.

bq. What if CLASSPATH is already set on the machine? Will this append to it or override it? From the code it looks like generating the classpath list will pick up the parent classpath. So if CLASSPATH env var is already set then it will be part of classpath list via the parent jvm (TaskTracket jvm). So even if the taskjvm.cmd sets the CLASSPATH it will be a superset of any existing CLASSPATH env var. Can you please verify this by having a pre-existing CLASSPATH set?
Thanks, I just checked, and we do not include the system level CLASSPATH. However, the setting itself seems to be exclusive, if you pass classpath via {{-classpath}}, the CLASSPATH environment variable is ignored. Just tested this out with a sample app that prints {{System.getProperty("java.class.path")}}. It generally makes sense to be specific in this case, and not to include the system setting as this can generally cause problems with resolution. Also, there are ways Hadoop users can specify custom classpaths if needed. Agree?, Sounds good. LGTM., Could you please add a test that verifies long command lines and the other checks you have added?, Attaching updated patch with unittests., 1)TaskLog.java
{code}
if (s.length() > MAX_CMD_LINE_LENGTH) {
   throw new IOException("Command line length exceeds the OS limit " +
                         MAX_CMD_LINE_LENGTH);
}
{code}
Can you add something to the exception message about the actual command that is bad. It will help in debugging which command is bad and also help in the next comment.

2)TestTaskLog.java
In the test, on the face of it, there seems to be no difference in the 2 times that captureOutAndError is called. Verifying that setup failed in the first case and cmd failed in the second case will help differentiate.

3)TestTaskLog.java
Would be good to actually use TaskLog.MAX_CMD_LINE_LENGTH so that if we change it then the test captures that.

4)TestTaskLog.java
Why not directly call buildCommandLine() - the function we are actually testing instead of captureOutAndError()? buildCommandLine() should be visible in the test because it would be in the same package.

5)Would it be possible to refactor TaskLog.buildCommandLine() to reduce the number of Shell.WINDOWS forks? It is getting hard to understand and error prone. e.g. the following code adds a new command line (exec setsid) to the script but its length would get included with the length of the actual cmd in the last check for MAX_CMD_LINE_LENGTH. Thats happens in Linux and it does not matter but it makes the code readability hard and incorrect.
{code}
    if (tailLength > 0) {
      mergedCmd.append("(");
    } else if (ProcessTree.isSetsidAvailable && useSetSid 
        && !Shell.WINDOWS) {
      mergedCmd.append("exec setsid "); // <=== this is a new command line
    } else {
      if (!Shell.WINDOWS)
        mergedCmd.append("exec ");
    }
    // ...
    // add real cmd line
    // ...
    if (mergedCmd.length() - prevLength > MAX_CMD_LINE_LENGTH) {
      throw new IOException("Command line length exceeds the OS limit "
                            + MAX_CMD_LINE_LENGTH);
    }
{code}
, Thanks for your feedback Bikas!

1. Fixed
2. I added a check to verify that the problematic command is in the output exception message
3. Fixed
4. Fixed
5. I did some work to remove many of Shell.WINDOWS forks. We might be able to further improve on this by exposing some of this functionality from Shell.java. Although, this is would be a separate patch. Thoughts?, Attaching updated patch., +1 this fixed a lot of downstream tests in pig and hive on Windows., 1) TaskLog.java
Wouldnt renaming these from bash* to shell* be better. Since these are private members the renaming would not cause much grief upon merging the code.
{code}
  private static final String bashCommand = (Shell.WINDOWS)? "cmd": "bash";
  private static final String bashCommandSufix = (Shell.WINDOWS) ? "/c" : "-c";
  private static final String bashCommandNullOutput = 
      (Shell.WINDOWS) ? "< nul" : "< /dev/null";
{code}
2) TestTaskLog.java
Could you please replace 8192 with TaskLog.MAX_CMD_LINE_LENGTH
{code}
for (int i = 0; i < 8192; ++i) {
{code}
3) TestTaskLog.java
For the 2 places you really mean "setup.toString()" and "cmd.toString()" instead of sb.toString() right?
{code}
assertTrue(ex.getMessage().contains(sb.toString()));
{code}

The current refactoring makes it cleaner. Agree on separate jira for a better implementation., Thanks Bikas!

1. Agree, fixed
2. Actually, we cannot do that, as {{TaskLog.MAX_CMD_LINE_LENGTH}} is {{MAX_INT}} on non-Windows platforms.
3. Hmm, I want sb.toString(). Basically, I want to verify that the long command is part of the exception message. {{setup.toString()}} wouldn't work as there would be multiple lines in the command, and the exception message only contains the first problematic one. Make sense?, Attaching updated patch., 3. My main concern is that we are not differentiating that the first failure is due to a bad setup string while the second one is due to a bad cmd string. Since the code is adding the exact failed command into the exception we could look for "setup" in the first case and "command" in the second case in addition to sb.toString(). I should have been more clear. I didn't literally mean "setup.toString()" because its a list :), 3. Oh, thanks for clarifying. My thinking was, from the user's perspective, we are outputting the actual command that exceeded the limit. Whether it is setup or command, it is not as relevant. In unit tests, since I know the code, I want to cover all cases, so I'm testing both. I am leaning toward keeping the code as is, given that I wouldn't want to have a hardcoded dependency on what is in the exception message. Let me know if you feel strong about this., Thats exactly what I am saying too :) The test is trying to cover both cases, but the result is kind of implicit right now because we know both paths are being covered. However, in the test itself by checking for only sb.toString() we are not making that explicit. There is nothing to hardcode. Unless I am reading the test code incorrectly, we have already defined List<string> setup and List<string> cmd. In the exception message, along with checking for sb.toString(), we could also check for setup[0] and cmd[0]. That way its explicit that 2 different paths are being covered., Attaching updated patch. Adding explicit checks that the correct exception string is returned back. Also removing some of if WINDOWS forks in the test code., Thanks for including all comments! +1. lgtm., FYI, I opened MAPREDUCE-4386 for better abstractions around different shells., +1, lgtm.

I just committed this. Thanks Ivan for the patch and Bikas for the detailed reviews.]