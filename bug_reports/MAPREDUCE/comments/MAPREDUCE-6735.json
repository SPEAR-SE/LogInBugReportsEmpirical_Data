[Thanks for the report, Alexandr!

MAPREDUCE-5465 would be expected to make things slightly slower, since the whole point of that JIRA is to let tasks finish on their own rather than proactively killing them.  Before that change the AM was trying to kill tasks as soon as they said they were done, and that was causing problems when the task had things to do afterwards like dumping JVM stats for performance or profiling.  Letting the tasks complete on their own means it will take a little longer sometimes for the container to complete, and that prevents another task from using the cluster resources associated with that container.  Essentially the change was a tradeoff of performance for correctness -- we were running "too fast" sometimes. ;-)

Do you have any details on how HADOOP-12107 is impacting things?  If you just put that one in on its own, do you see a similar impact?  Also note that HADOOP-12107 has a very important followup fix at HADOOP-12706.  It would be interesting to know if HADOOP-12107 really does impact on its own whether adding HADOOP-12706 changes that in any way., Unfortunately, I don't know how HADOOP-12107 is impacting things, but there is ~1min increase coming from commit HADOOP-12107., What happens when HADOOP-12107 and HADOOP_12706 are pulled in together?  We did see some cases where the former without the latter was causing some extra GC overhead, although I'd be a bit surprised it would be significant in a terasort test., Oops I apologize, I'm referencing the wrong JIRA.  HADOOP-12958 is the one that fixed the phantom references in HADOOP-12107, not HADOOP-12706.  So everywhere above that I've been calling out HADOOP-12706 I really meant HADOOP-12958.  That's the JIRA that changed the PhantomReferences introduced in HADOOP-12107 into weak references, and that ended up being a significant fix for container reuse in Tez., Yes, but when applying HADOOP-12107 and tickets that are broken by HADOOP-12107 (i.e. HADOOP-12706, HADOOP-12958) the performance degradation happens too in the same ratio. So even when HADOOP-12958 is applied it does not fix performance degradation., It is certainly surprising that HADOOP-12107 is making a difference on terasort. What version of hadoop are you using for your test? Java version? Is it repeatable (i.e. the gap shows up consistently)?

FYI, the nature of HADOOP-12107 has to do with *when* to clean up a certain data ( {{allData}} ) inside the {{FileSystem.Statistics}} objects. Before this change, it would get cleaned up when the owner thread gets garbage collected *and* a read operation is done on the {{Statistics}} object. By read operations I mean methods such as {{getBytesRead()}} and so on.

After this change, the timing of this clean-up no longer depends on the read operations, and it will be done promptly when the thread is garbage collected. So in a sense, the change first ensures there is clean-up no matter what, and also moves up the timing of the clean-up.

The worst-case scenario in which this can have a negative impact on performance is if the use case *never* reads the statistics. Prior to the change, as long as the heap can contain these objects, no clean-up will be done. With the change now we do perform additional clean-up on threads garbage collection.

A subsequent observation is that the impact of the clean-up is greater if there is a *high degree of thread churn* within the JVM. If we're talking about only a handful of threads or long-lived threads, there should really be no difference.

I would greatly appreciate it if you could dig a little deeper via logging or low overhead profiling to pinpoint the correlation. Thanks., It would also be good to know more details on the baseline being used when these commits are added/removed so we know what other changes are present/absent.  Is this a 2.8 baseline with reverts on these two commits or something else?]