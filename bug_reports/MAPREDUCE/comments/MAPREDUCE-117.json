[Preliminary patch while I continue testing..., Looks good to me., Actually, I think there is a problem with the patch in MapOutputCopier.run(). The affected code is -
{code}  
synchronized (scheduledCopies) {
   while (scheduledCopies.isEmpty()) {
      scheduledCopies.wait();
   }
}
loc = scheduledCopies.remove(0);
{code}
The line {noformat}scheduledCopies.remove(0){noformat} should be inside the {noformat}synchronized(scheduledCopies){noformat} block. Otherwise there is a race condition (assume an object got inserted in the scheduledCopies list and two copier threads got notified) - thread T1 gets a notification, wakes up, but just before it does scheduledCopies.remove(0), there is a context switch to thread T2. Thread T2 also finds the scheduledCopies to be non-empty and goes ahead and makes a successful call to scheduledCopies.remove(0). Now when T1 gets to run again, it would get a null for the remove(0) call. I think we should prevent this from happening.., Good catch Devaraj! I actually saw the NPE... *smile*]