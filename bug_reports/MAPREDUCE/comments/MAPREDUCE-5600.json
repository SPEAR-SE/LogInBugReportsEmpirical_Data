[Hi Benoit,
Can you reproduce that?, It's a race condition, so it's not deterministic.  But it's fairly easy to reproduce on any moderately busy TaskTracer will run into this exception if you keep requesting {{/tasktracker.jsp}}., I think branch-1 has the same issue.

When TaskTracker#getTasksFromRunningJobs is called, we'll get a iterator of "runningJobs"

{code}
  /**
   * Get the list of tasks from running jobs on this task tracker.
   * @return a copy of the list of TaskStatus objects
   */
  synchronized List<TaskStatus> getTasksFromRunningJobs() {
    List<TaskStatus> result = new ArrayList<TaskStatus>(tasks.size());
    for (Map.Entry <JobID, RunningJob> item : runningJobs.entrySet()) {
          ...
      }
    }
    return result;
  }
{code}

On the other hand, TaskTracker#addTaskToJob can be called during iteration.
addTaskToJob method modifies "runningJob" so it can cause ConcurrentModificationException.


{code}
  private RunningJob addTaskToJob(JobID jobId,
                                  TaskInProgress tip) {
    synchronized (runningJobs) {
       ...
        runningJobs.put(jobId, rJob);
       ...
    }     
  }
{code}

When we call getTasksFromRunningJobs, we get a synchronized monitor for the instance of TaskTracker, but, when we call addTaskToJob,
we get a synchronized monitor for "runningJob". So, we may need to modify TaskTracker to get an appropriate monitor when calling getTasksFromRunningJobs. ]