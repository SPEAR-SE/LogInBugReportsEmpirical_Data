[Attaching a patch that removes completed/failed job from default scheduler. , Since initTasks() is called by each scheduler, and it can result in a state change for the job without any evenst being raised, this issue potentially affects every scheduler. I can see the following ways of fixing the problem: 

# JobInProgress.initTasks() should notify all listeners via JobInProgressListener.jobUpdated(). This seems clean and the right way to do things. Only problem is, multi-threaded schedulers need to be careful of synchronization issues. The scheduler calls initTasks(), which calls the scheduler back through the JobInProgressListener interface. Another issue, minor, is that JT needs to expose the listeners to JobInProgress, which, I think, is inevitable, given JobInProgress code has a whole lot of state changes. 
# Amar/Sreekanth suggested another, slightly different, approach which limits any state change notifications to be raised by the JT. Either JobInProgress.initTasks() lets the JT knwo of a state change in the job and the JT propagates that to the listeners, or initTasks() does not set the job to completed; rather, the JT, when looking at jobs in PREP state to detect running of a setup job, detects that a job has 0 maps, causes it to change state, and propagates that change to the listeners. This is not very different from the prviosu approach - we're still making the JT/JobInProgress responsible for propagating job state changes, but you do allow the JT to keep its listeners private. 
# Another approach is for the Schedulers to know that initTasks() can change the state of a job without raising an event, and deal with that. Amar's patch for the default scheduler does just that. As he points out, the Fair Scheduler doesn't really care. But the Capacity Scheduler will need to deal with this. You could argue that this is less clean since the schedulers are aware of what goes on in initTasks(), but it all depends on who you think 'owns' initTasks() - the schedulers or the framework. 

Personally, I think #1 is the best option as it ensures that any job state changes are propagated to the Schedulers through the listeners, but it does have its drawbacks too. , I agree with Vivek. I think that changing the state of the job should always generate the jobUpdated method.

That said, I think that we should not short-circuit maps with 0 jobs. Especially, now that we have job initialization and clean up, it isn't the case that jobs with maps = 0 will have no impact., Owen, with 0 maps we never initialize the setup/cleanup tasks and hence there is not setup/cleanup done for the jobs with 0 maps. So as of today jobs with 0 maps dont have any impact, right? Also we need to take care of the case where _jip.initTasks()_ throws an exception. I think both the cases are similar. Can we have a common/generic solution to both the problems?, No, I'm saying that the correct behavior should be to run the init, reduce, and cleanup tasks, even when there are 0 maps. Think of a system that wants to run every 5 minutes to do roll ups. I think it makes more sense to have a directory with empty output files than a missing one if there was no input data.

In terms of the fix to the immediate problem, I think that all changes to the job state should be set to the listeners. Doesn't that solve the original problem?, Duplicated by?, MAPREDUCE-805]