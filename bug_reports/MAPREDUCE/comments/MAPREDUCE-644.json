[No one should use distcp to copy a single file anymore!  Just kidding ... we have to fix this.  :), >hadoop distcp -update srcfilename destfilename
>
>it seems to be comparing checksums of srcfilename and destfilename/srcfilename and so skip is not done. It should compare checksums of srcfilename and destfilename.

Actually, this is the correct behavior according to the [doc|http://hadoop.apache.org/core/docs/r0.20.0/distcp.html].  Quoted -update description below:
{quote}
As noted in the preceding, this is not a "sync" operation. The only criterion examined is the source and destination file sizes; if they differ, the source file replaces the destination file. As discussed in the [following|http://hadoop.apache.org/core/docs/r0.20.0/distcp.html#uo], it also changes the semantics for generating destination paths, so users should use this carefully.
{quote}, Only file sizes were checked earlier. But now in trunk, checksums are also checked after checking filesizes.
In any case, if I run the following command multiple times

hadoop distcp -update srcfile destfile

and if destfile doesn't exist, -update should allow the file to be copied only once and from 2nd run onwards it should not copy as the filesizes(and 
checksums are same).
But the problem here seems to be it is not comparing the filesizes and checksums of srcfile and destfile. distcp seems to be comparing srcfile with  
the path destfile/srcfile(i.e. srcfile in destfile directory), which is wrong., > But the problem here seems to be it is not comparing the filesizes and checksums of srcfile and destfile. distcp seems to be comparing srcfile with the path destfile/srcfile(i.e. srcfile in destfile directory), which is wrong.

According to to doc, "hadoop distcp -update foo bar" means copying foo to bar/foo, but not copying foo to bar.  Could you check it?, Currently -update writes to bar only and I think that is correct.
It copies to bar/foo only if bar is a dir and existing(similar to what happens without -update). If "bar" doesn't exist at destination, then foo is copied to bar. If "bar" exists at destination and is a file, it is overwritten if different from the source(this is the case overwriting is happening again and again, though it should not).
I don't see any path difference with -update when compared to without -update in any case(whether the destination exists or not). Am I missing any case where -update writes to a different path when compared to without -update option ?, I just saw that the doc says something different from what I understood. But distcp -update works as I mentioned only. I rechecked now after looking at the doc.
For the case of               distcp -update foo/a foo/b bar      mentioned in the doc, the effect of the command is  creating   bar/a/aa   bar/a/ab   bar/b/ba abd bar/b/bb.

I guess we need to change the doc. OR Do we really need to change the behaviour of distcp ?, > I guess we need to change the doc. OR Do we really need to change the behaviour of distcp ?

Thanks for checking this Ravi.  The doc actually is not clear about copying a single file, which, as always, is a not-so-useful special case.  We have freedom to do either way.  It is probably better to minimize the code complexity since distcp is already complicated enough., With -update, the path to which it copies a single file is correct. The issue is just that it copies again and again even with -update, which it should not be doing. Will upload a patch soon. Also will try to update the doc to reflect the correct behaviour., Attaching patch that fixes the path (used for checking checksums for -update) issue for single file update.

Please review and provide your comments., -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12411201/d_singlefile_update.patch
  against trunk revision 808082.

    +1 @author.  The patch does not contain any @author tags.

    -1 tests included.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: http://hudson.zones.apache.org/hudson/job/Mapreduce-Patch-vesta.apache.org/524/testReport/
Findbugs warnings: http://hudson.zones.apache.org/hudson/job/Mapreduce-Patch-vesta.apache.org/524/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Checkstyle results: http://hudson.zones.apache.org/hudson/job/Mapreduce-Patch-vesta.apache.org/524/artifact/trunk/build/test/checkstyle-errors.html
Console output: http://hudson.zones.apache.org/hudson/job/Mapreduce-Patch-vesta.apache.org/524/console

This message is automatically generated., Patch looks good.  Could you provide a unit test?, I tested it manually and I see that the single file's copy is skipped only with the patch.

Am wondering if we can verify the count of files copied(there is a counter 'COPY' in distcp for this) from testcase after running distcp for a single file with -update option and the destination contains the file already.
Thoughts ?, Hi Ravi, you may check whether fileCount + dirCount > 0 in DistCp.setup(..) for unit tests.

If you have already done manual tests, could you "Also please list what manual steps were performed to verify this patch"?, Attaching new patch with testcase added.
Testcase checks if setup() returns false as expected for the case of 'single file update  with destination containing the file already'(Also had to make class Arguments and setup() method as package private --- to be accessed from testcase). This testcase works only with the fix of MAPREDUCE-648. So marking that as a blocker for this JIRA.

This patch applies only after MAPREDUCE-649, MAPREDUCE-654, MAPREDUCE-645, MAPREDUCE-664, MAPREDUCE-661, MAPREDUCE-650, MAPREDUCE-648, MAPREDUCE-564 and MAPREDUCE-653(as these patches are all created in that order, I want this patch to go in after them --- otherwise many of those patches will have to be recreated for applying)., The code changes needed for this are included in the patch of MAPREDUCE-648.]