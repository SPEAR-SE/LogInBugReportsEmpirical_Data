[> ...  But in many cases those components are separate from core hadoop.  This means any changes to them will break backwards compatibility with those, ...

This part I don't agree.  When changing a LimitedPrivate API, we should aware that the depended components, which may sit outside core, should still work with the change.  In some cases, we may also make change to the depended components.  LimitedPrivate does not imply backwards compatibility since the LimitedPrivate APIs could be Unstable.  It just means that the depended components are using the API.

> Note that many of the annotation are also not marked properly, or have fallen out of date. I see Public Interfaces that use LimitedPrivate classes in the api. (TokenCache using Credentials is an example).

Okay, there is an ambiguity -- When a  Public API method using LimitedPrivate classes, does it mean that the Public API method automatically become a LimitedPrivate method (this is similar to the Java private methods in a Public classes; they are not Public APIs)?  Or Public APIs are not allowed using LimitedPrivate.  (Then, it is a bug as you mentioned but it does not mean LimitedPrivate annotation not useful.)

Anyway, I do agree that we do not define LimitedPrivate very carefully so that there are confusions in these special cases., bq.  LimitedPrivate does not imply backwards compatibility since the LimitedPrivate APIs could be Unstable. It just means that the depended components are using the API.

The problem is if we ignore backwards compatibility when changing classes marked LimitedPrivate used by downstream components then we are creating a knife-switch type of upgrade, where upgrading the Hadoop core requires a simultaneous corresponding update of hive/pig/hbase/pick-your-favorite-LimitedPrivate-user.  That becomes particularly problematic when supporting a rolling upgrade of the cluster, as tasks launched by the downstream component on new nodes may suddenly fail to find a LimitedPrivate method/class they relied upon.  IMHO that means we need to preserve backwards compatibility for LimitedPrivate APIs otherwise we can't do rolling upgrades when those APIs break., I did not say that LimitedPrivate could not have backwards compatibility.  I just say that LimitedPrivate APIs could also be @Stable, @Evolving or @Unstable., So you are sayings it purely informational and if I'm a "closely related product" I can use it and should update the annotation? Backwards compatibility guarantees are by the InterfaceStability tag but in the LimitedPrivate we will contact/negotiate with the components listed before making any changes. 

So I guess the question is what is a "closely related product".  Do all apache products fall into that category?

One example of this that seems a bit ridiculous is UserGroupInformation:
 @InterfaceAudience.LimitedPrivate({"HDFS", "MapReduce", "HBase", "Hive", "Oozie"})
, bq. The problem is if we ignore backwards compatibility when changing classes marked LimitedPrivate used by downstream components then we are creating a knife-switch type of upgrade, where upgrading the Hadoop core requires a simultaneous corresponding update of hive/pig/hbase/pick-your-favorite-LimitedPrivate-user.

Note that {{LimitedPrivate}} is a workaround of the lack of a strong concept of  symbol visibility in Java. It is a contract that is enforced voluntarily, but not by the compiler. What it means is that classes with this annotation are not supposed to be visible to the dependent projects. This is a contract between hadoop-core and dependent projects.

Please consider the following scenarios:

# My code uses Java reflection to get an instance of {{BlockReaderLocal}}, which is a class only visible in the same package. The Java compiler will check for that.
# My code uses {{RemoteBlockReader2}}, which is annotated with {{InterfaceAudience.Private}}. The compiler won't check whether the code violates the contract of visibility.

Note that in both cases they break the exact same contract of visibility. The only difference is that whether the Java compiler can check for it. If you agree that I probably should fix for (1), because "I'm doing it with my own risks", how come I can dodge the responsibility of fixing for (2), which is almost identical to the scenario described in this jira?

I understand that hadoop-core might not have the cleanest separation of public / private APIs, and it is important to be compatible. Having the options of being incompatible, however, is critical to move forward in projects like hadoop-core. I think a more reasonable approach is to drive some of the APIs to be public and to clarify the contracts of compatibility between hadoop-core and dependent projects, but not removing the contract and losing the option of being incompatible in minor releases., Also to clarify,  I do understand that the limitedprivate was probably added for historical reasons (the api's weren't properly categorized before) so components used them.  We have made great improvements to get them categorized for the official 2.2 release and we couldn't get everything fixed up due to timing.

So perhaps the title of the jira isn't correct and should be updated.  Personally I think the following should be done:

1) clarify documentation what limitedPrivate is. This means us internally agreeing on what it really means. 
2) No new classes/interfaces should use this tag. They should be properly classified as either public or private. If there was a bug and class not properly tagged its fine to use there.
3) All existing classes with this tag should be eventually be deprecated and we should work towards that.  I realize this isn't going to happen immediately as everyone has to balance this with features and other bug fixes.

If one component is using the interface more then likely its useful for other components and more then likely other components are already using it.   Thus in my opinion the documentation of listing the component its private to isn't very useful. 

The longer we wait with this the more applications (in the case of yarn) and components will use these api's and it will be harder to change them.  Yes we can say it was marked a certain way and the other components shouldn't have used it but when its ambiguous like this and we don't provide an equivalent Public api I don't see how we can defend that.  Also as more and more components are created it gets harder and harder to upgrade/deploy them all at once.  Hence why all the push for HA and rolling upgrades. Customers don't want downtime.

I do agree we need to have the option for moving forward.  But I think this can be done with a proper set of Public apis.

The reason I ran into this was because I am writing an application to run on yarn and also another one to just read HDFS files.  Its almost impossible (if not impossible) to do that properly (with security) without using classes marked LimitedPrivate right now.  If it is possible it would require copying lots of code. We should be making writing applications as easy as possible., bq. The reason I ran into this was because I am writing an application to run on yarn and also another one to just read HDFS files. Its almost impossible (if not impossible) to do that properly (with security) without using classes marked LimitedPrivate right now. If it is possible it would require copying lots of code. We should be making writing applications as easy as possible.

Can you elaborate on this and create jiras? Let's fix them in HDFS., Sorry for my delay, I somehow missed your comment go by. 

One of the main ones is UserGroupInformation.  As I mentioned above, you can tell just by how many components are listed in the LimitedPrivate clause. 

I've filed separate jira in YARN land for a few there also.  Vinod nicely bundled them under https://issues.apache.org/jira/browse/YARN-1953.

I've been distracted by other things recently though and haven't finished trying to convert everything to public interfaces so there are likely a few more. 

Since there haven't been any other disagreements with this perhaps I will file a jira to atleast update the docs about LimitedPrivate for the 2 bullets I mention above:

1) clarify documentation what limitedPrivate is. This means us internally agreeing on what it really means. 
2) No new classes/interfaces should use this tag. They should be properly classified as either public or private. If there was a bug and class not properly tagged its fine to use there., Moving bugs out of previously closed releases into the next minor release 2.8.0.]