[The problem here is that the deprecation registration declares that mapping from old to new. We cannot expect a property registered with the deprecated key to be retrievable with the new key until then. 

It should still be retrievable with the old key, just like any other key.

Are you seeing something different?

Or is the issue here that the act of registration of a deprecated key changing what/whether you can get stuff back?


patch wise: nice to see a test, especially with the assertEquals() parameters in the right order. But...SLF4J must be the log API, not stdout. thanks., {quote} We cannot expect a property registered with the deprecated key to be retrievable with the new key until then. {quote}
Yes, I understand this. What I tried to describe is not this case.
The problem here is if you get some value from the conf then register the deprecation mappings, you are unable to read the conf value with the old key, which is not a desired behavior.
If you check the code + logs, I try to get the values with the old and new keys, but the output says:

{code:java}
Looked up property value with name hadoop.zk.address: null
Looked up property value with name hadoop.zk.address: null
{code}

So even if you use the old key, it tries to fetch values with the new key and it's null.

I just meant this patch to be a proof of concept, so please disregard the stdouts, as the final patch will be more production ready.
Thanks!, {{So to reproduce the problem:}}
{{Works:}}

{{1. load properties from xml}}
{{2. add deprecation mapping}}
{{3. read either new or old key {color:#8eb021}works{color}}}

{{Does now work:}}
{{1. load properties from xml}}
{{{color:#59afe1}1,5. Get any completely not related property{color}Â }}
{{2. add deprecation mapping}}
{{3. read either new or old key {color:#d04437}fails{color}}}, Hi [~zsiegl]!
Thanks for your patch!
LGTM in overall, I would just rename the {{names}} array to {{newKeys}} and the corresponding loop variable {{n}} to {{newKey}}.

{noformat}
private void updatePropertiesWIthDeprecatedKeys(
      DeprecationContext deprecations, String[] names) {
    for (String n : names) {
      String deprecatedKey = deprecations.getReverseDeprecatedKeyMap().get(n);
      if (deprecatedKey != null && !getProps().containsKey(n)) {
        String deprecatedValue = getProps().getProperty(deprecatedKey);
        if (deprecatedValue != null) {
          getProps().setProperty(n, deprecatedValue);
        }
      }
    }
  }
{noformat}

Thanks!, [~snemeth] thanks for the review, items fixed.

[~stevel@apache.org] could you review the current patch? Please let me know if you would need any further help understanding the context of the issue., Thanks [~zsiegl] for the updated patch!
LGTM, +1 (non-binding), I'm going to wait to see what others say, which given its a long weekend in the US, unlikely until next week

Configuration is such as ubiquitous class that its on the list of things to be very careful about changing, even when the changes seem low risk, which is why we need that extra oversight

looking @ code; 

* I'd like to see a patch which doesn't add IDE-helped changes, as that complicates merging and cherry-picking, so fixes to unused imports, line endings, spacing need to be left out. Sorry.
* in TestConfigurationDeprecation, use try-with-resources for writing the file.

, [~stevel@apache.org] Thank you for the review. Changes done, new patch on the way. Try-with-resources in the test would require a larger refactor of the test case, I suggest a different commit for that.]