[Hi [~bibinchundatt], if you have a patch for this, please upload so that we can cross verify how many failures and evaluate the risk with this change., Attaching patch for the handling the state change of after serviceStart init and stopped., | (x) *{color:red}-1 overall{color}* |
\\
\\
|| Vote || Subsystem || Runtime || Comment ||
| {color:blue}0{color} | {color:blue} reexec {color} | {color:blue} 0m 12s {color} | {color:blue} Docker mode activated. {color} |
| {color:green}+1{color} | {color:green} @author {color} | {color:green} 0m 0s {color} | {color:green} The patch does not contain any @author tags. {color} |
| {color:green}+1{color} | {color:green} test4tests {color} | {color:green} 0m 0s {color} | {color:green} The patch appears to include 1 new or modified test files. {color} |
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 7m 9s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 12s {color} | {color:green} trunk passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 53s {color} | {color:green} trunk passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} checkstyle {color} | {color:green} 0m 21s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green} 0m 59s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvneclipse {color} | {color:green} 0m 15s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green} 1m 42s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 0m 55s {color} | {color:green} trunk passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 4s {color} | {color:green} trunk passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 0m 41s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 5m 58s {color} | {color:green} the patch passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 5m 58s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 46s {color} | {color:green} the patch passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 6m 46s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} checkstyle {color} | {color:green} 0m 21s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green} 0m 57s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} mvneclipse {color} | {color:green} 0m 13s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} whitespace {color} | {color:green} 0m 0s {color} | {color:green} Patch has no whitespace issues. {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green} 1m 54s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 0m 53s {color} | {color:green} the patch passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 4s {color} | {color:green} the patch passed with JDK v1.7.0_95 {color} |
| {color:red}-1{color} | {color:red} unit {color} | {color:red} 7m 10s {color} | {color:red} hadoop-common in the patch failed with JDK v1.8.0_77. {color} |
| {color:red}-1{color} | {color:red} unit {color} | {color:red} 7m 23s {color} | {color:red} hadoop-common in the patch failed with JDK v1.7.0_95. {color} |
| {color:green}+1{color} | {color:green} asflicense {color} | {color:green} 0m 22s {color} | {color:green} Patch does not generate ASF License warnings. {color} |
| {color:black}{color} | {color:black} {color} | {color:black} 60m 35s {color} | {color:black} {color} |
\\
\\
|| Reason || Tests ||
| JDK v1.8.0_77 Failed junit tests | hadoop.service.TestServiceLifecycle |
| JDK v1.7.0_95 Failed junit tests | hadoop.service.TestServiceLifecycle |
\\
\\
|| Subsystem || Report/Notes ||
| Docker |  Image:yetus/hadoop:fbe3e86 |
| JIRA Patch URL | https://issues.apache.org/jira/secure/attachment/12799419/0001-HADOOP-13035.patch |
| JIRA Issue | HADOOP-13035 |
| Optional Tests |  asflicense  compile  javac  javadoc  mvninstall  mvnsite  unit  findbugs  checkstyle  |
| uname | Linux 9c6cb87dd971 3.13.0-36-lowlatency #63-Ubuntu SMP PREEMPT Wed Sep 3 21:56:12 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux |
| Build tool | maven |
| Personality | /testptch/hadoop/patchprocess/precommit/personality/provided.sh |
| git revision | trunk / 90d1af1 |
| Default Java | 1.7.0_95 |
| Multi-JDK versions |  /usr/lib/jvm/java-8-oracle:1.8.0_77 /usr/lib/jvm/java-7-openjdk-amd64:1.7.0_95 |
| findbugs | v3.0.0 |
| unit | https://builds.apache.org/job/PreCommit-HADOOP-Build/9115/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.8.0_77.txt |
| unit | https://builds.apache.org/job/PreCommit-HADOOP-Build/9115/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.7.0_95.txt |
| unit test logs |  https://builds.apache.org/job/PreCommit-HADOOP-Build/9115/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.8.0_77.txt https://builds.apache.org/job/PreCommit-HADOOP-Build/9115/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.7.0_95.txt |
| JDK v1.7.0_95  Test Results | https://builds.apache.org/job/PreCommit-HADOOP-Build/9115/testReport/ |
| modules | C: hadoop-common-project/hadoop-common U: hadoop-common-project/hadoop-common |
| Console output | https://builds.apache.org/job/PreCommit-HADOOP-Build/9115/console |
| Powered by | Apache Yetus 0.2.0   http://yetus.apache.org |


This message was automatically generated.

, Thanks [~bibinchundatt], could you take a look at failed tests to see if they're real issues of just a false alarm?

We need to run Maven test for all projects, currently it only runs for Hadoop-common.

I think we need to run Maven tests for all sub-projects down to leaf which depends on the changes to reduce risks. For example, for changes of Hadoop-common, we should run YARN/HDFS/MR tests, and for changes of YARN-common, we should run YARN-client/YARN-server tests.

[~aw] could you share your thoughts here? , Can't happen.

YARN has two modules that take 1 hour each (hadoop-yarn-server-resourcemanager and hadoop-yarn-server-resourcemanager).  MR has one module that takes two hours (hadoop-mapreduce-client-jobclient).... and that's for a single JVM.  It simply isn't realistic to run the full gamut of unit tests as part of precommit. Either someone needs to spend time working on MAPREDUCE-6674 and YARN-4950 and probably follow-ons to at least cut the times for all these modules in half or someone needs to double the amount of build resources available at Apache so that we can have longer run times.
, Thanks for confirmation, [~aw].

First option looks like doable to me. 

For YARN-4950, most address-in-use exception should be addressed by YARN-4909 already, retriggered Jenkins.
For MAPREDUCE-6674, it may need some efforts to figure out why it happens., [~leftnoteasy]
Thank you for looking into patch

Corrected cases for TestServiceLifecycle as mentioned below and have query for two cases

# {{TestServiceLifecycle#testStartInInitService}} services is trying to start in Init.Since the state is not yet set as INITED start will not be allowed. Please advice 
# {{TestServiceLifecycle#testStopFailingInitAndStop}} when init Is failing testcase checks for state to be INITED as per earlier implementation.
changed state to NOTINITED in Assertion.
# Notify listener shouldnt happen once the state is STOPPED added condition in {{start and init}} to handle the case.
# {{TestCompositeService}} testclass {{maybeAddSibling()}} changed to pass the state expected.
, [~leftnoteasy]/[~aw]
TestNodeLabelContainerAllocation,TestRMWebServicesNodes,TestCapacitySchedulerPreemption are tracked as part of YARN-4846,YARN-4947,YARN-4890 once those are closed hoping to get stable report., | (x) *{color:red}-1 overall{color}* |
\\
\\
|| Vote || Subsystem || Runtime || Comment ||
| {color:blue}0{color} | {color:blue} reexec {color} | {color:blue} 0m 11s {color} | {color:blue} Docker mode activated. {color} |
| {color:green}+1{color} | {color:green} @author {color} | {color:green} 0m 0s {color} | {color:green} The patch does not contain any @author tags. {color} |
| {color:green}+1{color} | {color:green} test4tests {color} | {color:green} 0m 0s {color} | {color:green} The patch appears to include 2 new or modified test files. {color} |
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 7m 39s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 45s {color} | {color:green} trunk passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 7m 26s {color} | {color:green} trunk passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} checkstyle {color} | {color:green} 0m 23s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green} 1m 1s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvneclipse {color} | {color:green} 0m 15s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green} 1m 45s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 1s {color} | {color:green} trunk passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 10s {color} | {color:green} trunk passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 0m 43s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 52s {color} | {color:green} the patch passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 6m 52s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 8m 0s {color} | {color:green} the patch passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 8m 0s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} checkstyle {color} | {color:green} 0m 21s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green} 0m 56s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} mvneclipse {color} | {color:green} 0m 14s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} whitespace {color} | {color:green} 0m 0s {color} | {color:green} Patch has no whitespace issues. {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green} 1m 49s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 0m 51s {color} | {color:green} the patch passed with JDK v1.8.0_77 {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 3s {color} | {color:green} the patch passed with JDK v1.7.0_95 {color} |
| {color:red}-1{color} | {color:red} unit {color} | {color:red} 7m 3s {color} | {color:red} hadoop-common in the patch failed with JDK v1.8.0_77. {color} |
| {color:red}-1{color} | {color:red} unit {color} | {color:red} 7m 18s {color} | {color:red} hadoop-common in the patch failed with JDK v1.7.0_95. {color} |
| {color:green}+1{color} | {color:green} asflicense {color} | {color:green} 0m 23s {color} | {color:green} Patch does not generate ASF License warnings. {color} |
| {color:black}{color} | {color:black} {color} | {color:black} 64m 20s {color} | {color:black} {color} |
\\
\\
|| Reason || Tests ||
| JDK v1.8.0_77 Failed junit tests | hadoop.service.TestServiceLifecycle |
| JDK v1.7.0_95 Failed junit tests | hadoop.service.TestServiceLifecycle |
\\
\\
|| Subsystem || Report/Notes ||
| Docker |  Image:yetus/hadoop:fbe3e86 |
| JIRA Patch URL | https://issues.apache.org/jira/secure/attachment/12799576/0002-HADOOP-13035.patch |
| JIRA Issue | HADOOP-13035 |
| Optional Tests |  asflicense  compile  javac  javadoc  mvninstall  mvnsite  unit  findbugs  checkstyle  |
| uname | Linux a51b765b8f86 3.13.0-36-lowlatency #63-Ubuntu SMP PREEMPT Wed Sep 3 21:56:12 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux |
| Build tool | maven |
| Personality | /testptch/hadoop/patchprocess/precommit/personality/provided.sh |
| git revision | trunk / af9bdbe |
| Default Java | 1.7.0_95 |
| Multi-JDK versions |  /usr/lib/jvm/java-8-oracle:1.8.0_77 /usr/lib/jvm/java-7-openjdk-amd64:1.7.0_95 |
| findbugs | v3.0.0 |
| unit | https://builds.apache.org/job/PreCommit-HADOOP-Build/9122/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.8.0_77.txt |
| unit | https://builds.apache.org/job/PreCommit-HADOOP-Build/9122/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.7.0_95.txt |
| unit test logs |  https://builds.apache.org/job/PreCommit-HADOOP-Build/9122/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.8.0_77.txt https://builds.apache.org/job/PreCommit-HADOOP-Build/9122/artifact/patchprocess/patch-unit-hadoop-common-project_hadoop-common-jdk1.7.0_95.txt |
| JDK v1.7.0_95  Test Results | https://builds.apache.org/job/PreCommit-HADOOP-Build/9122/testReport/ |
| modules | C: hadoop-common-project/hadoop-common U: hadoop-common-project/hadoop-common |
| Console output | https://builds.apache.org/job/PreCommit-HADOOP-Build/9122/console |
| Powered by | Apache Yetus 0.2.0   http://yetus.apache.org |


This message was automatically generated.

, [~leftnoteasy]
Could  you please review the same., Tried different approach.Added new state INITING and STARTING, | (x) *{color:red}-1 overall{color}* |
\\
\\
|| Vote || Subsystem || Runtime || Comment ||
| {color:blue}0{color} | {color:blue} reexec {color} | {color:blue} 0m 8s {color} | {color:blue} Docker mode activated. {color} |
| {color:green}+1{color} | {color:green} @author {color} | {color:green} 0m 0s {color} | {color:green} The patch does not contain any @author tags. {color} |
| {color:green}+1{color} | {color:green} test4tests {color} | {color:green} 0m 0s {color} | {color:green} The patch appears to include 3 new or modified test files. {color} |
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 6m 36s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 39s {color} | {color:green} trunk passed with JDK v1.8.0_92 {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 39s {color} | {color:green} trunk passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} checkstyle {color} | {color:green} 0m 21s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green} 0m 59s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvneclipse {color} | {color:green} 0m 14s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green} 1m 34s {color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 0m 50s {color} | {color:green} trunk passed with JDK v1.8.0_92 {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 4s {color} | {color:green} trunk passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 0m 40s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 5m 32s {color} | {color:green} the patch passed with JDK v1.8.0_92 {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 5m 32s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 6m 34s {color} | {color:green} the patch passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 6m 34s {color} | {color:green} the patch passed {color} |
| {color:red}-1{color} | {color:red} checkstyle {color} | {color:red} 0m 21s {color} | {color:red} hadoop-common-project/hadoop-common: The patch generated 8 new + 41 unchanged - 0 fixed = 49 total (was 41) {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green} 0m 55s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} mvneclipse {color} | {color:green} 0m 14s {color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} whitespace {color} | {color:green} 0m 0s {color} | {color:green} The patch has no whitespace issues. {color} |
| {color:red}-1{color} | {color:red} findbugs {color} | {color:red} 1m 51s {color} | {color:red} hadoop-common-project/hadoop-common generated 1 new + 0 unchanged - 0 fixed = 1 total (was 0) {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 0m 54s {color} | {color:green} the patch passed with JDK v1.8.0_92 {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green} 1m 4s {color} | {color:green} the patch passed with JDK v1.7.0_95 {color} |
| {color:green}+1{color} | {color:green} unit {color} | {color:green} 7m 45s {color} | {color:green} hadoop-common in the patch passed with JDK v1.8.0_92. {color} |
| {color:green}+1{color} | {color:green} unit {color} | {color:green} 8m 1s {color} | {color:green} hadoop-common in the patch passed with JDK v1.7.0_95. {color} |
| {color:green}+1{color} | {color:green} asflicense {color} | {color:green} 0m 24s {color} | {color:green} The patch does not generate ASF License warnings. {color} |
| {color:black}{color} | {color:black} {color} | {color:black} 60m 31s {color} | {color:black} {color} |
\\
\\
|| Reason || Tests ||
| FindBugs | module:hadoop-common-project/hadoop-common |
|  |  org.apache.hadoop.service.ServiceStateModel.getState() is unsynchronized, org.apache.hadoop.service.ServiceStateModel.setState(Service$STATE) is synchronized  At ServiceStateModel.java:synchronized  At ServiceStateModel.java:[line 78] |
\\
\\
|| Subsystem || Report/Notes ||
| Docker |  Image:yetus/hadoop:cf2ee45 |
| JIRA Patch URL | https://issues.apache.org/jira/secure/attachment/12801645/0003-HADOOP-13035.patch |
| JIRA Issue | HADOOP-13035 |
| Optional Tests |  asflicense  compile  javac  javadoc  mvninstall  mvnsite  unit  findbugs  checkstyle  |
| uname | Linux b1791f60659a 3.13.0-36-lowlatency #63-Ubuntu SMP PREEMPT Wed Sep 3 21:56:12 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux |
| Build tool | maven |
| Personality | /testptch/hadoop/patchprocess/precommit/personality/provided.sh |
| git revision | trunk / 971af60 |
| Default Java | 1.7.0_95 |
| Multi-JDK versions |  /usr/lib/jvm/java-8-oracle:1.8.0_92 /usr/lib/jvm/java-7-openjdk-amd64:1.7.0_95 |
| findbugs | v3.0.0 |
| checkstyle | https://builds.apache.org/job/PreCommit-HADOOP-Build/9242/artifact/patchprocess/diff-checkstyle-hadoop-common-project_hadoop-common.txt |
| findbugs | https://builds.apache.org/job/PreCommit-HADOOP-Build/9242/artifact/patchprocess/new-findbugs-hadoop-common-project_hadoop-common.html |
| JDK v1.7.0_95  Test Results | https://builds.apache.org/job/PreCommit-HADOOP-Build/9242/testReport/ |
| modules | C: hadoop-common-project/hadoop-common U: hadoop-common-project/hadoop-common |
| Console output | https://builds.apache.org/job/PreCommit-HADOOP-Build/9242/console |
| Powered by | Apache Yetus 0.3.0-SNAPSHOT   http://yetus.apache.org |


This message was automatically generated.

, -1, as it


This is a pretty fundamental change. I would have also really liked to have been pinged on this earlier, given my hands are all over the code as it stands. While I acknowledge it isn't perfect, it does include experience on other systems, and I did go through every single YARN service, repeatedly, until things were stable.

This whole discrepancy between state-> starting and service->live is a recurrent problem, but as you can see from things like web and IPC servers starting in the background, service start() is inherently async; what code really needs to wait upon is not the state change complete, but to await for the started state to go live, which *may happen at some indeterminate state in the future*

Without picking into this patch in detail, here are the places which have caused most trouble over time, which any patch at what is a fundamental bit of how the YARN services are constructed is going to have to look at

* subclasses of {{CompositeService}} adding new services in service start, having to push them through their lifecycle enough to attach them to their parent, then rely on the remaining of the serviceStart lifecycle to walk themselves through.
* things going wrong in composite start and having to unroll the stack
* things trying to call stop() during start.
* the fact that calling start() on a service which is started *or in the process of starting* is required to be a no-op.
* the issue as to when is serviceStop() invoked on a service when stop() is called? Currently: not until you init(). it had better be after initing() now.

Can i also note that the ubquity of YarnClient means this class gets used a lot downstream. Admittedly, I use it most of all, but you can essentially build yarn based apps by aggregating their service lifecycles together. Which means there is a risk that things may change. Before a descendant of this patch goes in, someone is going to have to have built and tested slider's functional test suite against a version of Hadoop with this turned on. I think they'll be able to dodge doing the same in Hive, as Hive 1.2.x still uses a cut-and-paste of the the 2.0 service model before the YARN-117 patch went in; which, if you've ever seen how Spark Thriftserver abuses introspection to subclass (SPARK-8064, SPARK-10793) you'll be grateful there.

I also to know what happens to YARN-679 and YARN-1564 with this. I propose adding them first, as that will expand the codebase, and, as much of this is code which I can migrate slider to, will make it easier for slider to adapt to a change this fundamental.

Accordingly, I'll tag this as a depends-on there, rebase those two batches with trunk and await reviews., Linking to the outstanding patches which make significant uses of YARN services: an entry point to start any service and some basic lifecycle services alongside the CompositeService. , Thinking about this more, it is possible to make the fact that a service is in a transition state without changing {{Service.STATE}}, which is the incompatibility barrier.


What is needed is to retain that state model to all existing code, while either making the state-transition-in-progress condition visible to code
which is aware of the fact that the intermediate states are visible. 

This can be done in a number of ways

h3. a {{transitionInProgress}} variable and accessor

When state is entered, the (atomicBoolean) state is set, cleared on exit. The state of a service can be queried with something like {{isInState(STATE.STARTED) && !transitionInProgress}}. 

Troubespots here are that such a probe is not in itself atomic except if executed in a {{synchronized block}}, which will also be needed when entering the state. The extra fun happens when stop() is called during a change, or, say {{start() in init()}}. There are some other corners too: what if the flag is set, but the service is in state {{NOTINITED}}?

h3. Implement the extended state as a new enum, translate down to the existing state for existing code in the getters and state probes.


Here there'd be a new interface

{code}

interface ExtendedService extends Service {

enum ExtendedState{ ... = Service.state + transitions}

boolean getExtendedState();

boolean isInExtendedState(ExtendedState es);

boolean canEnterExtendedState(ExtendedState es)

}
{code}

The state model would be the extended one, what would change is the old state queries

{code}
boolean isInState(Service.State s) {
   ExtendedState es = getExtendedState();
   return mapExtendedToSimpleState(es) == s
}

public State mapExtendedToSimpleState(ExtendedState es) {
switch(es) {
  case NOTINITED: return State.NOTINITED;
  case INITED: return State.INITED;
  case INITING: return State.INITED;
  ...
}
 
}

{code}

Actually, you could do the map in the enum itself, with every ExtendedState instance declaring is simple state in the constructor.


I *believe* this could work, the troublespot would be managing state entry calls, including {{enterState(State.STARTED)}}, and the addition of child services within a composite service during the {{serviceInit()}} and {{serviceStart()}} operations.

If this can be shown to implement the extended state model desired and retain backwards compatibility with subclasses of {{AbstractService}} inside and outside the Hadoop codebase then I'm prepared to withdraw my -1. I do still require the linked JIRAs to go in first, as they push the boundaries of the state model further, and, being derivative of the slider workflow services and service launcher, something we could migrate that code to. That is: if the YARN-679 and YARN-1564 handle this, then testing slider becomes a lot easier., Hi [~stevel@apache.org],

Thanks for sharing background and thoughts about this issue.

Given this looks like a fundamental change. And could possibly cause other issues for example:
bq. the fact that calling start() on a service which is started or in the process of starting is required to be a no-op.

I think adding:
bq. a transitionInProgress variable and accessor
Sounds like a good plan if we add it to AbstractService, add the transitionInProgress to following blocks:
{code}
    synchronized (stateChangeLock) {
      if (enterState(STATE.INITED) != STATE.INITED) {
         // set in-progress-flag
         // other logics
         // unset in-progress-flag
      }
    ...
{code}

Since every state transition needs to acquire stateChangeLock, it seems safe to me when stop() is called when start() is invoking or call start() when init() is invoking, etc.

Adding an ExtendedService is a more comprehensive fix, and I agree that it is doable, but we have to fix all existing subclasses of AbstractService to use that.

I think a simpler but incompatible fix is rename existing STARTED/INITED to STARTING/INITING, and adding a new STARTED/INITED to Service. Probably we can do that on trunk before Hadoop-3 get released. Could you please share your thoughts?

Thanks,, One thing to bear in mind about that state change lock is that as the {{serviceInit}} and {{serviceStart}} methods are called holding the lock, code of these methods can enter a new state while it's in progress. This is why the {{init()}} and {{start()}} methods have checks for whether they are still in the required state on exit. This is important because it allows {{serviceInit}} and {{serviceStart}} to invoke stop() and not block.

Anything playing with a new state change field would have to handle similar cases, especially {{serviceInit}} and calling {{start()}} . ( I don't know of anything which does that; I'm not sure if we should allow it, but it's there. stop can/may happen, which really complicates things if something like a contained service ever directly/indirectly called it's parent {{stop()}} call. There's also some unwinding in {{CompositeService.serviceStop()}} which only calls {{stop()}} on children which are explicitly in the {{STARTED}} state...we'd have to make sure that includes in-transition conditions (probably) or explicitly decided to ignoring the starting stuff.

The more I think about this, an expanded state model, with the existing accessor/enum retained as is, is probably the way to manage this. Users of the old API would get the STARTED state when the service was in STARTING/STARTED; users of the new API would get the detailed value. This would allow the inner state model to be complete, covering the logic of the various state transitions without having to also rely on some transitionary states. 


There's also some fun when we consider that today, INIT and STARTED are idempotent
{code}
if (enterState(STATE.INITED) != STATE.INITED) { ...}
{code}

That would actually get more complex with the extra states; perhaps {{enterState()}} would be changed to return a bool if a state change has *really* occurred, and both INITED/INITING and STARTED/STARTING treated as equivalent from the perspective of idempotent transitions. That is, STARTED.enterState(STARTING) => STARTED, STARTING.enterState(STARTED) => STARTED is needed, because it's how the start() operation would transit to its final state. Whatever patch gets in, making sure it is fully idempotent here will have to be looked at carefully
, Thanks for the additional note, [~stevel@apache.org]!

It seems to me that existing code implementation will be hard to add new in-transition state such as RUNNING/STARTING and keeps all existing properties (such as idempotent as you mentioned above).

A theoretically possible solution to me is using YARN's state machine implementation, so we can easier separate events from states, and better defining transitions and events. However, considering AbstractService is building block of all YARN services and many other applications, it's better to not make such a big change to it.

For this JIRA, I would prefer to let service implementations to manage their own in-transition state, and add a javadoc note to add more details about what "STARTED" means.

Thoughts?
, If we only care about a service saying whether it considers itself "live', then extening the Service interface with a ServiceWithLiveness one would let services set a bit when they considered themselves live. We could also have a standard "wait until live" mechanism (busy wait? Block on an object?) so that one thread could wait until another one felt that it was fully up and running...]