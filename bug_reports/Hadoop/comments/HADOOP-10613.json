[> ... If every time i use a new UGI object to invoke FileSystem.get(conf) and never invoke FileSystem's close method,this issue will raise.
 ...

Is it similar to if an application open a lot of (local) files but not closing them, or open a lot of sockets but not closing them?  I think the application is responsible to call close() for releasing the resource in such cases., Yes,application is responsable to release FileSystem object int the case i described above for now.
But i think FileSystem can do better(easier to use).
There are differences between hadoop's FileSystem and java's File.
For java File object,user need to close it very time after open it.
For hadoop FileSystem object ,user don't need to close it after call FileSystem.get(conf).Because the FileSystem object is cached
and can be reused next time when user's code invoke FileSystem.get(conf) again.It's life cycle is higher than java's File object. 
The perpose to call FileSystem's close method is removing it from cache ,and making delete-on-exit featrue work.
If user' code never call FileSystem's close method,it's still ok.Because there is a shut down hook for each FileSystem object,the close method will be called
when application stops.The only problem is the memory leak.So,a LRU cache or something similar will be better than the no size limited hashmap based cache. ]