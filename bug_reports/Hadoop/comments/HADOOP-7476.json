[While working on porting task-controller, I ran into getline():

{code}
size_read = getline(&line,&linesize,conf_file);
    //feof returns true only after we read past EOF.
    //so a file with no new line, at last can reach this place
    //if size_read returns negative check for eof condition
    if (size_read == -1) {
      if(!feof(conf_file)){
        fprintf(LOGFILE, "getline returned error.\n");
        exit(INVALID_CONFIG_FILE);
      }else {
        free(line);
        break;
      }
    }
    //trim the ending new line
    line[strlen(line)-1] = '\0';
    //comment line
{code}

My read of this code says that we always remove the last character of the buffer prior to the null termination.  In the vast majority of cases, this should be \N.  However, getline() doesn't appear to guarantee this:

"The buffer is null-terminated and includes the newline character, if one was found."

If the configuration file was built in such a way that it does not end with a newline, it will chop off the last character. , Is this not a dupe of MAPREDUCE-2377 ?, sure is, missed that one.  thanks., No problem.

Out of curiosity, to what are you porting {{task-controller}}?, OS X and Solaris.  As usual, this typically means removing the GNU-only crud*.  At this point, my task-controller uses fgetln() instead of getline().  Since I'm lazy, it is easier to find code we can import that implements fgetln() in a portable fashion than getline(). (Altho if getline() is present w/out fgetln(), I've got a wrapper that implements fgetln() with getline()).

* Technically, getline() was added to super-recent POSIX, but none of the platforms that I have access to have that other than glibc-based machines.  So it isn't that portable yet. :(]