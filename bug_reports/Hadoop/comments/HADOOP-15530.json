[{quote}Given that we support rpcTimeOut, we could chose the second method of Future below:
{quote}
That would just mask the root cause.
{quote}In theory, since the RPC at client is serialized, we could just use the main thread to do the execution, instead of using a threadpool to create new thread.
{quote}
No, the client uses a different thread for a very specific reason.  If an interrupted thread attempts nio operations on a channel then the channel is closed.  See the jira from the annotation:

HADOOP-6762. Exception while doing RPC I/O closes channel.

 

 , Thanks a lot for the feedback and good info [~daryn]. 

About the root cause, I'm still digging as reported in HADOOP-15538.
, I've been giving this issue a lot of thoughts recently. For cases like HADOOP-15359, time out in Future.get() will not help, because the threads are still blocked by the same object monitors.]