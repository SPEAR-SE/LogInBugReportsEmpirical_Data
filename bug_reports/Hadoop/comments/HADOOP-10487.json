[I missed Todd's comment.  I might be wrong, but I believe the DCL in this case is ok.  The normal problem is when simple assignment to the DCL object occurs in the sync block.  The full construction of the object may be reordered to be outside the sync block.  In this case, full construction is guaranteed because the {{initialize}} method repeatedly accesses the {{Configuration}} object prior to assignment.  The synch block's happens-before semantics I believe negate the need for a final., s/need for a final/need for a volatile/, +1 for the proposal to change this.  I've not heard before that repeated access of the object prior to assignment can serve as an adequate protection.  I'd think it's still possible for a non-synchronized method to observe a non-null {{conf}} containing partial state if writes were reordered.  Even if it does work now, that might just be an implementation detail.

One challenge may be {{UserGroupInformation#reset}}, a testing method which wants to change {{conf}} back to null.]