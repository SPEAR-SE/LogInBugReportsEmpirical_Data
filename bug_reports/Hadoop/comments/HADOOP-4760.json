[The problem is in the {{Configuration.loadResource(...)}} method at:

{code}
      } else if (name instanceof InputStream) {
        try {
          doc = builder.parse((InputStream)name);
        } finally {
          ((InputStream)name).close();
        }
      }
{code}

the {{DocumentBuilder}} (the {builder} variable) {{parse(...)}} method closes the stream, making the {{close()}} in {{finally}} to fail.

Note that the failure does not happen with all stream classes, only with those that check that the stream is not closed before closing it (HDFS stream does that)
, We should fix HDFS to not complain about twice-closed streams, to be compatible with other InputStream implementations., Doug, you are correct, according to the {{Closeable}} API: Closes this stream and releases any system resources associated with it. If the stream is already closed then invoking this method has no effect. 
, bq. We should fix HDFS to not complain about twice-closed streams, to be compatible with other InputStream implementations.
+1, I have come across several cases, where this was the problem. , Here is a patch, which checks for the {input|output}streams to be closed and returns w/o throwing IOException. Test case ensures that HDFS and S3 file systems meet the contract. , +1. This should have been fixed a long time back. 

regd the patch : 

# If both the file and DFSclient are closed, it would still throw an exception, checkopen() should probably called only if the stream is not closed.
# it has a lot of meta, formatting changes, are those intentional? I know {{@override}} is useful, but these changes are spread all over.. one big disadvantage is that it conflicts patches coming from other active branches. , Incorporated Raghu's comments, now checkOpen() is called if closed is false. Also fixed the DFSClient.close() method to not throw exception. 

The @Override's are pretty useful (espcecially when refactoring) and they are introduced intentionally by my eclipse save actions. I am in favor of keeping them.

import statements are reordered and * are converted to actual classes again by save actions. According to our guidelines, the import statements should only contain actual class references. As in this case here, the import statements are constantly switched between actual class names or * between patches. Maybe we should add checking for this to test-patch script.   , ant test-patch results : 

     [exec] +1 overall.
     [exec]
     [exec]     +1 @author.  The patch does not contain any @author tags.
     [exec]
     [exec]     +1 tests included.  The patch appears to include 6 new or modified tests.
     [exec]
     [exec]     +1 javadoc.  The javadoc tool did not generate any warning messages.
     [exec]
     [exec]     +1 javac.  The applied patch does not increase the total number of javac compiler warnings.
     [exec]
     [exec]     +1 findbugs.  The patch does not introduce any new Findbugs warnings.
     [exec]
     [exec]     +1 Eclipse classpath. The patch retains Eclipse classpath integrity.
     [exec]
     [exec]     +1 release audit.  The applied patch does not increase the total number of release audit warnings.


All tests pass except TestSetupAndCleanupFailure, which seems unrelated. 

, bq. import statements are reordered and * are converted to actual classes again by save actions. As in this case here, the import statements are constantly switched between actual class names or * between patches.

hmm.. I am pretty sure eclipse can be configured not to do that (in fact, by default it may not do that). If every patch includes a lot of corrections like this, it would be pretty hard to track and maintain. There might even be constants flips committed due to minor variations in different eclipse configurations or JDKs used by eclipse environments. Pretty error prone as well.

I am -0.5 on these. I might be biased in this since I make sure my patch is not polluted even by minor white space changes. At least two separate patches would be much better. Note that it should be ok to fix the code just around the actual code changes.

, Yes my eclipse configuration is intentionally this way, since I believe we should have the @Override's and imports corrected for ALL of the code.  Doing these in a separate issue is a logical option, however I cannot imagine anyone doing this for all the java classes, so I tend to be practical and fix the ones I change for a patch. 

I can remove the [import,@Override] changes, but I'm afraid I could not find time to prepare a patch for them. 

On a related issue I guess the eclipse configurations about import statements should be fixed for everybody who develops code for Hadoop, so that the statements will be correct in the first place. 
, Removed import and annotation changes as per discussion. , Thanks. +1 for v3. 

If you and/or others feel v2 is better, please go ahead, I would not -1 it.
, I committed this to 0.19.1 and on. The fix for 0.18.4 is not straightforward, so I left that out, we can fix it in a new issue if need be. , Is this an incompatible change?  Hope that there is no codes depend on the old behavior., Integrated in Hadoop-trunk #756 (See [http://hudson.zones.apache.org/hudson/job/Hadoop-trunk/756/])
    , bq. Is this an incompatible change? Hope that there is no codes depend on the old behavior. 
I don't think so, Closeable.close() explicitly states that closing more than once should have no effect. ]