[Why not have clients and/or datanodes report corrupt replicas to the Namenode? Is this not already done?

The Namenode should remove and replace corrupt replicas when they are reported by clients/datanodes, probably on read to start off with. This can be subsequently enhanced to to periodic block scanning., > The Namenode should remove and replace corrupt replicas when they are reported by clients/datanodes, probably on read to start off with.

That's already done.  When a checksum error is encountered, and there's more than one replica, the offending replica is removed., The bug is that when a setReplication() command is sent to the NameNode, no data blocks are being read by the client and/or datanode. A block that was corrupt on the datanode is not known to the namenode at that time., > when a setReplication() command is sent to the NameNode, no data blocks are being read

Right.  But a setReplication() triggers replications, and, when those replications happen, the data is read.  If, when writing the replica, the checksum of the received data does not match the checksum sent with that data, the receiving datanode should report to the namenode that the data was corrupt and abort the replication.  This would cause the source block to be removed (provided there are more replicas) and the namenode to initiate new replications from a different source.

After HADOOP-1134, datanodes should always validate checksums as blocks are written.  Whenever there's a mismatch, the write should be aborted.  If the write is a replication (as opposed to an initial write) the mismatch should be reported to the namenode.  Does that sound like the right policy to you?, That sounds like a good policy. However, the bug I was pointing to occurs when setReplication() is called to *decrease* the number of replicas. In this case, no data blocks are read., > the bug I was pointing to occurs when setReplication() is called to decrease the number of replicas

Sorry it's taken me so long to understand this!  Yes, I see the issue now.  I'm not sure I yet have great sympathy for it.  In general, as one decreases the number of replicas, the chances that all of them may be corrupt increases.  After HADOOP-1134 we should primarily only see corruptions due to disk errors.  A disk can start failing at any time.  Validating some replicas before others are removed would somewhat reduce the chances that all replicas are corrupt, but not dramatically, so I'm not convinced it's worth the expense.

Disk errors are not entirely random.  When we see a single error from a disk, we're likely to see more from that disk.  So keeping statistics of the number of corruptions identified per datanode would be very valuable.  And automatically taking datanodes offline when corruptions exceed some threshold might go farther towards addressing this issue than explicitly checking blocks as replication thresholds are reduced, since this would remove replicas from failing drives *before* they're read, replicated, de-replicated, etc., I agree. There is not much point in validating replicas just before a setReplication call is issued. Instead, a periodic disk block validation by the Datanode might be handy in detecting these types of problems., > a periodic disk block validation by the Datanode might be handy in detecting these types of problems

Yes, it would, especially if the filesystem has been idle or offline for a time.  But for an actively used filesystem, normal use might identify failing drives as effectively.  Scanning the research on disk failures, it looks like they more frequently return a read error rather than corrupt data.  Currently, it looks like a datanode shuts down when it encounters a read error, which is probably sufficient.  The OS shouldn't return a read error unless it has retried several times, the drives ECC has failed, etc., Periodic block verification and handling-corrupt replicas are now part of the Hadoop code base. No additional work is necessary for this one.]