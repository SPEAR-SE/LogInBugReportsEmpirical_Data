[This patch is closer to what we did for the routine above it last week. (Sorry about not fixing this one too at the same time. It wasn't biting us, but that was no reason not to fix the obviously parallel code.)  Is there some reason that you need the synchronized block around the mkdirs? File.mkdirs does a File.exists internally, so you don't need to call it yourself., By the way, if there is a need for the sync block around the mkdirs, we should go ahead and change the function above it so that next week we don't get a third bug. *smile*, If we take out the sync block, the code would look like:

if (fs.exists(dir)) {
  return file;
}
fs.mkdirs(dir);
if (fs.exists(dir)) {
  return file;
}

we added the sync block around the mkdirs because we were not sure exactly how mkdirs() handles race cases. for example if one thread is creating the directory hierarchy, can the other thread return error while the first thread is still creating the hierarchy? if so when the second thread executes fs.exists(), it would return false since the directories are still be created. 

but perhaps this isn't the behavior mkdirs() exhibits. it could return false only if it can't create the final leaf directory in the directory hierarchy (because the other thread just created the leaf). if that's the case then the sync would not be needed. the sun java api doc isn't clear on this., The File.mkdirs (based on what I see in eclipse) looks like:

    public boolean mkdirs() {
        if (exists()) {
            return false;
        }
        if (mkdir()) {
            return true;
        }
        ... <handle recursive mkdirs>...
    }

in any case, the final mkdir would need to be the last thing done. Without the sync block, I believe your code is functionally identical to my proposal of:

if (fs.mkdirs(dir) || fs.exists(dir)) {
   return file;
}

Or am I missing something? If we need to synchronize, we really need to do it everywhere and do it consistently.

On a side note, the Configuration's getFile roll-over between local directories is problematic. The problem is that readers need to find the file regardless of where it was written. So if the writer can spill over to other directories, there should be a findFile(?) that looks in all of the directories (in the right order) until it finds it. That way readers can find the file regardless of which directory the writer was spilled in to., Not sure I understand that, a sync block would still not  protect againt multiple processes trying to create the same hierarchy, and the races would still bite you...

Maybe the safest thing to do is to traverse the hierarchy in getLocalPath(), creating each directory and checking
for it's existence.
  

, 
Sameer -> I think you're right. Ultimately, the synchronize is not good enough, and it seems that you've got the right solution.

Owen ->  here's the case Naveen described: lets say five directory levels are created by the call to mkdirs(), and there are two threads entering mkrdirs() at about the same time. Will one of the two threads exit before the fifth directory is created? I dont have the source code, but it seems to me that it could. If that would happen, that thread will step ahead to the next directory because when it does the exists() check, the directory will not exist. Which leads to Sameer's point that even the synchronize is not good enough.



, Below is what mkdirs looks like according to the jad decompiler (File.class from is from Sun JDK 1.5).

It looks like to me if two processes/threads are trying to create "/a/b/c/d/e/" and nothing yet exists, they both try to create "/a". One will fail, while the other succeeds. The failing process will return failure early, while the other process continues to create "b/c/d/e/". If the failing process after returning from mkdirs() now calls exists("/a/b/c/d/e"), exists() could  return false because the other process is still creating the directories along the path.

So probably Sameer's suggestion of traversing in getLocalPath() is the best solution.

public boolean mkdirs()
    {
        if(exists())
            return false;
        if(mkdir())
            return true;
        File file = null;
        try
        {
            file = getCanonicalFile();
        }
        catch(IOException ioexception)
        {
            return false;
        }
        String s = file.getParent();
        return s != null && (new File(s, fs.prefixLength(s))).mkdirs() && file.mkdir();
    }
, Ok, I see your point. 

Let's go with the traversing, but I think it should be done in the FileSystem.mkdirs rather than in Configuration., FileSystem.mkdirs is an abstract method. It would have been nice to put the traversal logic there. FSDirectory.mkdirs() already does a traversal like we need, so perhaps that code can be copied and modified for LocalFileSystem.mkdirs() ?, Sameer is working on a fix for this in LocalFileSystem.mkdirs(), Attached patch for mkdir issue. LocalFileSystem.mkdirs() now traverses the hierarchy creating each directory along the way. This patch changes the semantics of  'mkdirs' in the FileSystem interface. The semantics are now those of 'mkdir -p', in that existence of the specified directory or any ancestor of it is no longer an error.

Also updates mkdirs in dfs.FSDirectory so that it has the same behavior., This patch conflicts with HADOOP-240, which I just committed.  Can you please resolve this?  Thanks., Attached new patch., I just committed this.  Thanks, Sameer!]