[For example Records.newRecords() (in YARN project) always dynamically creates an implementation class name and eventually calls this logic. And then VM always tries to drop its class cache as soon as possible, and ironically this overhead may become larger than just calling Class.forName()  especially in well optimized VM., Sorry, I mistook about Records.newRecords(), which also uses own cache.]