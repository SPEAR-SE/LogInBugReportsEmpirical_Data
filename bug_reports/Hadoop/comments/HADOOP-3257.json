[
I think Hadoop need to make a clear and deliberate decision as to which chars are allowed/disallowed as a part of dfs paths
and provide tool (sych as url encode/decode) to help deal with those disallowed chars.
Personally, I don't see why it is wrong to exclude ":" if doing so simplifies a lot of things.
I don't think it is worthwhile to invest a lot of efforts to support all chars in paths.
, > Currently Path is limited by URI semantics in the sense that one cannot create files whose names include characters such as ":" etc.

Path is a convenience class that wraps a URI.  URIs are the underlying mechanism Hadoop uses to name files.  Hadoop only supports a subset of possible URIs (hierarchical URIs, normalized to remove double-slashes and so that non-root paths don't end in a slash).  Path enforces this subset.  Path also handles some compatibility issues, mostly to make it easier to include Windows drive letters in "file:" URIs when running on Windows.

So a path is not limited by "URI semantics", it is implemented with URI syntax.  URIs permit escapes, so that one can include arbitrary unicode characters in a URI.  One *can* create URIs that include colons.  However our Windows-compatibility code may make it awkward to get colons through the Path wrapper into a URI and perhaps we can improve that.

> It would be nice if Path handled all characters correctly...

What does "correctly" mean?  I think we need more specific issues before we can have a real discussion.  Escaping here is tricky, since we have code that takes files from different filesystems that require different escapes and uses these to form paths.  I've commented on this previously:

https://issues.apache.org/jira/browse/HADOOP-2066?focusedCommentId=12558701#action_12558701

Two approaches are possible:
 - limit Paths to an interoperability subset, a common-denominator.  That's where we are today.
 - permit simpler and more automated escaping of certain characters.  That's a laudable goal.

I don't think we should simply say that Path must accept any string verbatim as a file name.  I think it is reasonable to permit syntax errors for clearly malformed paths.  It is also reasonable to permit colons in directory and file names.  If colons are unescaped in a relative path, then they can be confused for the URI scheme, and I think that interpretation trumps., Barring any lower-level checks, the FsShell copy failure with a colon (and probably other chars) should already be fixed on trunk.  FsShell tries to use a more robust parsing of the path, which should probably be moved into the Path class., Per the bug that got dupped to this one, : could be handled correctly if the RFC for URI syntax is more closely followed for scheme & authority.
* Path looks for a : and / and checks that the colon occurs before the /.  It really should be colon_index = slash_index - 1.  
* There's a limited number of chars valid in a scheme.  Path should stop looking for a : if a non-valid scheme char is encountered.

That would take care of most cases.  Now let's say someone _really_ does want a relative path that looks like a URI, ex. {{foo:/bar}}.  They can use {{./foo:/bar}} to disambiguate.

I have a heap of un-submitted patches littering my home/work laptop, and one that implements this behavior is lying around somewhere...]