[Writes and reads of volatile longs or doubles are very much atomic: http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7, really? I guess I was mistaken. Even so, what isn't atomic is any addition ++, +=, etc. The code has to be reviewed to make sure that isn't happening at least, Non-volatile assignments of longs and doubles *may* lead to seeing half-writes (i.e. completely different value) unlike ints (where you see either the old value or the new value but never any other value). But volatile longs and doubles are always atomic per Java Memory Model.

I agree that volatiles and compound operators (++, +=, etc.) don't mix as volatiles are for giving you visibility for single assignments. That is true for any types (int, long, double, short, etc.)., In https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java:

{code:Java}
     * There is only a single writer to thread-local StatisticsData objects.
     * Hence, volatile is adequate here-- we do not need AtomicLong or similar
     * to prevent lost updates.
     * The Java specification guarantees that updates to volatile longs will
     * be perceived as atomic with respect to other threads, which is all we
     * need.

      volatile long bytesRead;
      volatile long bytesWritten;

      this.bytesRead += other.bytesRead;
      this.bytesWritten += other.bytesWritten;
{code}

Could this above cause a race condition?

PS ZK also worked these with https://issues.apache.org/jira/browse/ZOOKEEPER-1972, I don't think that's a real issue. The key assumption here is that there is only a single writer thread (these are basically thread-local data structures). With volatile declarations and a single writer thread, even if a reader comes in during the "+=" operation it's not going to be a problem.

I'd be the first to admit that the way it is written is not very clear or intentional, but t appears correct. The only exception to the single-writer rule is Statistics.rootData. However, that is also currently protected by the Statistics instance lock. Again, that could be made more explicit (e.g. sometimes synchronization is done in a couple of layers above in the call chain).

Hope this helps., [~gliptak], as the comment you pasted states, "there is only a single writer to thread-local StatisticsData objects."  A single writer cannot race with itself, as [~sjlee0] commented.

[~sjlee0] wrote:
bq. I'd be the first to admit that the way it is written is not very clear or intentional, but t appears correct. The only exception to the single-writer rule is Statistics.rootData. However, that is also currently protected by the Statistics instance lock. Again, that could be made more explicit (e.g. sometimes synchronization is done in a couple of layers above in the call chain).

Hmm.  The declaration of {{rootData}} has a comment saying that it is protected by the Statistics lock.  There's also a comment near {{reset}} talking about the locking, commenting that "Both reads and writes to rootData are done under the lock, so we're free to modify rootData from any thread that holds the lock".  Are other places we could add comments to make it clearer?  To be honest, I think the locking here is better documented than most places in our code base.

I did a quick scan of our uses of {{volatile long}}, and the only place I can find that might be a problem is here:
{{hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/NNThroughputBenchmark.java}} might have a "lost update" here:
{code}
    void benchmarkOne() throws IOException {
      for(int idx = 0; idx < opsPerThread; idx++) {
        if((localNumOpsExecuted+1) % statsOp.ugcRefreshCount == 0)
          refreshUserMappingsProto.refreshUserToGroupsMappings();
        long stat = statsOp.executeOp(daemonId, idx, arg1);
        localNumOpsExecuted++;
        localCumulativeTime += stat;  <=== should be using AtomicLong
      }
    }
{code}

{{localCumulativeTime}} should be an AtomicLong to prevent lost updates.

Perhaps we should change this JIRA to be about fixing this issue.  Or maybe we should close this and file the {{localCumulativeTime}} issue as a follow-on, to make it less confusing.  [~steve_l], what do you think?, {quote}
Hmm. The declaration of rootData has a comment saying that it is protected by the Statistics lock. There's also a comment near reset talking about the locking, commenting that "Both reads and writes to rootData are done under the lock, so we're free to modify rootData from any thread that holds the lock". Are other places we could add comments to make it clearer? To be honest, I think the locking here is better documented than most places in our code base.
{quote}

I totally agree that it is better documented than other places in our code base (and the code is correct). It is about a couple of places we can touch up to make it crystal clear. The only minor nits I had were
- the single-writer assumption has one exception, which is Statistics.rootData: this could have been documented in StatisticsData so that one can connect the dots between the single-writer assumption and rootData quickly
- The access to rootData in Statistics.reset() is safe because visitAll() is synchronized, but it may be easy to miss (I did when I went over it quickly). As you mentioned, there is the javadoc comment there mentioning the lock, but a quick mention to visitAll() would have been even better., I knew some were tagged, and others not. I think my main concern was whether writes to a 64 bit value were atomic at all â€”but roman corrected me there. Which leaves the issue of: are there any operations which cause problems, with ++, += and the equivalents being it.

I think we should just review them, and for all that we deem safe, add that in big comments.

Life would be easier if java had an {{atomic}} type alongside {{volatile}}, atomic add/subtract operations are only a couple of cycles on a modern part, plus the same impact on OoO scheduling that volatile r/w ops have., +1 on what [~stevel@apache.org] suggested. How about using this to review all unsafe uses of volatiles, mainly in the context of using compound operations (++, +=, etc.)? [~cmccabe] already flagged one. Volatile int/short/byte/double/float are no different in this regard, so they should be reviewed too.]