[The failing test suites are:

org.apache.hadoop.fs.TestLocalFSFileContextSymlink
org.apache.hadoop.fs.TestLocal_S3FileContextURI
org.apache.hadoop.fs.TestS3_LocalFileContextURI
org.apache.hadoop.fs.viewfs.TestChRootedFs
org.apache.hadoop.fs.viewfs.TestViewFsLocalFs
org.apache.hadoop.fs.viewfs.TestViewFsWithAuthorityLocalFs

{code}
java.io.IOException: mkdir of file:/C:/hdc/hadoop-common-project/hadoop-common/C:/hdc/hadoop-common-project/hadoop-common/target/test/data/test/test1 failed
	at org.apache.hadoop.fs.FileSystem.primitiveMkdir(FileSystem.java:1008)
	at org.apache.hadoop.fs.DelegateToFileSystem.mkdir(DelegateToFileSystem.java:145)
	at org.apache.hadoop.fs.FilterFs.mkdir(FilterFs.java:187)
	at org.apache.hadoop.fs.FileContext$4.next(FileContext.java:712)
	at org.apache.hadoop.fs.FileContext$4.next(FileContext.java:708)
	at org.apache.hadoop.fs.FileContext$FSLinkResolver.resolve(FileContext.java:2361)
	at org.apache.hadoop.fs.FileContext.mkdir(FileContext.java:708)
	at org.apache.hadoop.fs.FileContextSymlinkBaseTest.setUp(FileContextSymlinkBaseTest.java:84)
	at org.apache.hadoop.fs.TestLocalFSFileContextSymlink.setUp(TestLocalFSFileContextSymlink.java:66)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:27)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)
{code}
, The attached patch fixes the mkdir errors in these tests.  TestLocal_S3FileContextURI and TestS3_LocalFileContextURI now pass.  The other test suites mentioned now fail for different reasons, which I will group into other existing jiras.

There were 3 problems that this patch fixed:

# RawLocalFs had a hard-coded call to ln, which I switched to using Shell to get the right platform-specific command.
# FileContextTestHelper was mangling the root directory for test data, and I needed to change it to properly handle a Windows path that starts with a drive specification.
# FileContextURIBase test cases used a few edge cases that cannot be valid paths on Windows.  I didn't want to delete these from the tests, because they were probably important to someone on Unix.  Instead, I added logic to skip them if running on Windows.
, There appears to be a similar problem with a test trying to cover a path that isn't valid on Windows in org.apache.hadoop.fs.TestPath.

{code}
Running org.apache.hadoop.fs.TestPath
Tests run: 16, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.609 sec <<< FAILURE!
testGlobEscapeStatus(org.apache.hadoop.fs.TestPath)  Time elapsed: 0 sec  <<< ERROR!
java.io.IOException: Mkdirs failed to create file:/C:/hdc/hadoop-common-project/hadoop-common/target/test/data/testPathGlob/*
	at org.apache.hadoop.fs.ChecksumFileSystem.create(ChecksumFileSystem.java:443)
	at org.apache.hadoop.fs.ChecksumFileSystem.create(ChecksumFileSystem.java:429)
	at org.apache.hadoop.fs.FileSystem.create(FileSystem.java:853)
	at org.apache.hadoop.fs.FileSystem.create(FileSystem.java:834)
	at org.apache.hadoop.fs.FileSystem.create(FileSystem.java:733)
	at org.apache.hadoop.fs.FileSystem.create(FileSystem.java:722)
	at org.apache.hadoop.fs.TestPath.testGlobEscapeStatus(TestPath.java:288)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:168)
	at junit.framework.TestCase.runBare(TestCase.java:134)
	at junit.framework.TestResult$1.protect(TestResult.java:110)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at junit.framework.TestResult.run(TestResult.java:113)
	at junit.framework.TestCase.run(TestCase.java:124)
	at junit.framework.TestSuite.runTest(TestSuite.java:243)
	at junit.framework.TestSuite.run(TestSuite.java:238)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)
{code}
, Additionally, I discovered that the following test suites have failures that are likely to have a similar root cause:

org.apache.hadoop.fs.viewfs.TestChRootedFileSystem
org.apache.hadoop.fs.viewfs.TestViewFileSystemLocalFileSystem
org.apache.hadoop.fs.viewfs.TestViewFileSystemWithAuthorityLocalFileSystem

I'll investigate putting together an updated patch that covers all of this comprehensively.
, I've uploaded a new patch that addresses all of the test failures mentioned here.  In a few cases, this fix then exposed additional problems in the tests, which I have documented in other jiras.

Regarding TestPath, there was a single failing test that was trying to cover edge cases for globStatus related to a file name containing a '*'.  Since '*" is not a valid character in a Windows file name, this patch skips the test when running on Windows.
, The patch looks good. Some minor comments: 
1. isValidFileNameOnPlatform() only does check for Windows and always returns true for non-windows platform. Though it's good enough for this tests, it's better update this method's javadoc or name to reflect its real functionality (since on Linux, at least '/' and '\0' are not valid file name). 
2. it takes some mental effort to understand the WIN_INVALID_FILE_NAME_PATTERN. :-) 
Searching online, I found a similar pattern with comments which makes it easier to understand. http://stackoverflow.com/a/6804755
{noformat}
    Pattern pattern = Pattern.compile(
        "# Match a valid Windows filename (unspecified file system).          \n" +
        "^                                # Anchor to start of string.        \n" +
        "(?!                              # Assert filename is not: CON, PRN, \n" +
        "  (?:                            # AUX, NUL, COM1, COM2, COM3, COM4, \n" +
        "    CON|PRN|AUX|NUL|             # COM5, COM6, COM7, COM8, COM9,     \n" +
        "    COM[1-9]|LPT[1-9]            # LPT1, LPT2, LPT3, LPT4, LPT5,     \n" +
        "  )                              # LPT6, LPT7, LPT8, and LPT9...     \n" +
        "  (?:\\.[^.]*)?                  # followed by optional extension    \n" +
        "  $                              # and end of string                 \n" +
        ")                                # End negative lookahead assertion. \n" +
        "[^<>:\"/\\\\|?*\\x00-\\x1F]*     # Zero or more valid filename chars.\n" +
        "[^<>:\"/\\\\|?*\\x00-\\x1F\\ .]  # Last char is not a space or dot.  \n" +
        "$                                # Anchor to end of string.            ", 
        Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.COMMENTS);
{noformat}, Thanks, Brandon.  I've uploaded a new patch with the following changes based on your feedback:

# I added comments to the regex to help clarify.  I tried that regex that you mentioned, but unfortunately it didn't actually work.  :-)
# I changed the method name to isTestableFileNameOnPlatform to indicate that it's not a full validity check, but just a sufficient check to see if the test should proceed.
# I added comments to isTestableFileNameOnPlatform specifically explaining that the current implementation filters out file names that aren't compatible with Windows.

How does this look?
, +1, the new patch looks good., +1. I committed it branch-trunk-win.

Thank you Chris. Thank you Brandon for the review., Chris, apologies for the late review. I have a few comments on this patch.

1. RawLocalFs#createSymlink
I think we want to align this with some of our long term goals. The problem with the current code is that you’ll pass a path with forward slashes to Shell.WINUTILS. This does not work in all the cases (one example is path longer than 255 chars). The right thing to do here is to first convert a Path to a File, and let File#getCanonicalPath() do the right conversion for you.

To fix this I would propose we do the following:
 - Expose Path#toFile() API on the Path object
 - Convert Path to File within createSymlink and use File(s) going forward

This aligns well with our long term plans and would be a great thing to do! Daryn had a similar proposal on some of branch-1 Jiras.

2. FileContextURIBase
Currently, isTestableFileNameOnPlatform() will disable testing of some paths on Windows. However, I think the right thing to do is disable these tests only for the LocalFileSystem on Windows. Other FileSystems, like HDFS and S3 will continue to support the complete character set, and we should run the full test suit. Am I right? Might be that I’m just reading the change incorrectly. One way to fix this is to ask for fileNames/dirNamas and allow inherited classes to override the default set. We did something similar in HADOOP-8487.

3. TestPath#testGlobEscapeStatus()
I see that you disabled this test on Windows. It would be good to enable the test “somehow” but I cannot think of a good way. If we could spin up a MiniDFSCluster we could test this, but if I’m reading the trunk code correctly, this would break layering so it’s not an option. In lack of a better option, I’m fine with this.

I believe it should be fine to prepare a patch that goes on top of what is currently in the branch.
, Chris, please check out HADOOP-8868, it fixes similar problem to #1 from above.]