[c10398_20140310.patch: checks if token.isSet()., {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12633759/c10398_20140310.patch
  against trunk revision .

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:red}-1 tests included{color}.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    {color:green}+1 javac{color}.  The applied patch does not increase the total number of javac compiler warnings.

    {color:green}+1 javadoc{color}.  There were no new javadoc warning messages.

    {color:green}+1 eclipse:eclipse{color}.  The patch built with eclipse:eclipse.

    {color:green}+1 findbugs{color}.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 core tests{color}.  The patch passed unit tests in hadoop-common-project/hadoop-auth.

    {color:green}+1 contrib tests{color}.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-HADOOP-Build/3653//testReport/
Console output: https://builds.apache.org/job/PreCommit-HADOOP-Build/3653//console

This message is automatically generated., This solved the problem., +1 patch looks good., how can you get a 200 from a kerberos protected endpoint if you did't complete the spengo sequence?, {quote}how can you get a 200 from a kerberos protected endpoint if you did't complete the spengo sequence?{quote}
IIRC, there is a bug in the JVM which can cause it to do the SPNEGO sequence for us sometimes (which is what the code comment implies).  , [~rkanter], thanks for helping out here.  I actually not sure why HTTP_OK does not implies authentication completed.

[~tucu00], any more comment on the patch?  Otherwise, I will commit it shortly., the jvm, on the client side, if within a kerberos login context, sets the authenticated header proactively, this is not a bug but part of the spnegio spec. 

in that case, the authfilter with kerberos handler will complete the auth sequence without an unauthorized response, you'll get a 200 with the cookie. what i dont get is how you can get a 200 if the auth seq was not done, In oozie in an unsecured cluster, if you specify "-Doozie.auth.token.cache=false" to do a kill or suspend command, AuthOozieClient.java will call "new AuthenticatedURL(authenticator).openConnection(url, currentToken);" under createTokenBasedAuthConnection method. In KerberosAuthenticator.java, this line seems to be always returning true "if (conn.getResponseCode() == HttpURLConnection.HTTP_OK)" even before the bug was introduced., In summary, if AuthenticatedURL with KerberosAuthenticator (or KerberosUgiAuthenticator) is used to connect to an unsecured cluster, HttpURLConnection.getResponseCode() may return HTTP_OK (since the cluster is unsecured.)  In such case, it should fall back to PseudoAuthenticator.

[~tucu00], any more question?, still is not clear to me, please wait till tomorrow morning so i can try to understand what is going on , Looking at the code, if a 200 response arrives there should be a token (cookie). 

If the cluster is configured as unsecure, there are 2 options, the PseudoAuthenticationHandler in the server side is configured to allow ANONYMOUS users or not,  by default is NOT. 

If ANONYMOUS is disabled, then there is no token (no cookie) and the response code is 401. This will trigger the fallback.

If ANONYMOUS is enabled, then there is a token (cookie) and the respose is 200. This does not  trigger a fallback.

It would help seeing the full request/response of the authentication sequence to understand what is going on., Hi [~tucu00], HADOOP-8883 added the condition "conn.getRequestProperty(AUTHORIZATION) != null" to the if-statement.  You have +1'ed and committed the patch.  However, HADOOP-8883 did not work since JDK hided the AUTHORIZATION header.

In the patch here, we check if the token is set in order to determine if authorization is already done.  Would you agree that two approaches are similar?

> Looking at the code, if a 200 response arrives there should be a token (cookie). ...

Which code are you taking about?  If the above statement is true, that part of the code may have a bug., They look similar, correct, and HADOOP-8883 did not fix the problem because we didn't fully understand it. I'm trying to avoid making the same mistake this time. Having a full HTTP trace of a complete interaction would really help to see what is going on., This patch is wrong.  Please don't commit anything w/o me commenting.  I've had to do a lot of internal work on webhdfs related to authentication, and I can tell you AuthenticatedUrl is riddled with bugs and this doesn't appear to be a solution.

If you get a 200 OK, that _always_ means you are authenticated.  The JDK is going to spnego authenticate you automatically.  If you get a 200, there is no need to use a fallback authenticator.  The only time a fallback is necessary is if you receive a 401 with WWW-Authenticate != negotiate.  If it's negotiate, then it means you don't have kerberos credentials., > If you get a 200 OK, that always means you are authenticated. ...

Okay, then it seems that bug is in the server side but not in KerberosAuthenticator., [~szetszwo], could you get the HTTP traffic both ways of the interactions?, Hi Alejandro, [~bowenzhangusa] is working on it.  I tried to change TestKerberosAuthenticator but it was not able to reproduce the problem., I attached the tcp dump when issuing "bin/oozie -Doozie.auth.token.cache=false job -oozie http://localhost:11000/oozie -kill 0000000-140314142500148-oozie-bzha-W" command., {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12634843/a.txt
  against trunk revision .

    {color:red}-1 patch{color}.  The patch command could not apply the patch.

Console output: https://builds.apache.org/job/PreCommit-HADOOP-Build/3675//console

This message is automatically generated., It's unfortunate that AuthenticatedURL didn't use Basic auth so the fallback authenticator would only trigger on 401 basic.  We've internally removed AuthenticatedURL from webhdfs in 0.23 because server errors would trigger the fallback which tacks the username into the query string and tries the request again, the jdk transparently attempted spnego again, which often triggered kerberos replay attacks and caused the jdk to NPE., [~tucu00], have you checked the tcp dump?

[~daryn], could you post a patch?, I'll try to chat with Alejandro today to determine the best approach to the issue., Any update?

This bug blocks Oozie tests for quite a few days.  How about we commit the current patch (which is a work around of the bug) and the fix the bug in a separated JIRA?, Alejandro has personal matters to deal with today.  We plan to talk tomorrow morning.  In the meantime, I see what is happening in the dump.  Sorry if I overlooked a detail, but is the server anonymous or not?

I understand the desire to unblock testing.  However this feels like a server side bug or misconfiguration, so hacking around it on the client isn't a good idea...

I don't agree with the patch in general because it creates lock-in on auth cookies.  If a newer server has the option to disable cookies (which I'd like), then older clients will erroneously re-authenticate even though they are indeed authenticated sans cookie., > ... If a newer server has the option to disable cookies (which I'd like), then older clients will erroneously re-authenticate even though they are indeed authenticated sans cookie.

As mentioned before, the current patch is only a work around, once the real bug is fixed, we should revert the change.  Anyway, let's see if we could come up a real fix., the server is anonymous., If this is going to take time to resolve, is reverting HADOOP-10078 an option?, Reverting HADOOP-10078 is just going to re-introduce bugs.  The pseudo authenticator will also always be invoked causing double authentications for secure clusters.  This jira's patch would also force a double OPTIONS request to include the user, thus erasing any distinction between anonymous and non-anonymous.

The issue is the oozie server is rejecting anonymous users because it doesn't know who the user is, correct?  That doesn't make any sense.  Why is the server doing any sort of user-level authz if anonymous ("I don't care about users") is enabled?, When you try to kill or suspend an oozie job, and you enable the "oozie.service.AuthorizationService.security.enabled" in oozie-site.xml, then you need to put user info during authentication., [~rkanter], can you jump into the discussion since you did the previous commit?, I agree with [~daryn]: we shouldn't revert HADOOP-10078.  That basically just throws away the first if statement by making it always false.  I don't think this is a high enough priority to warrant an immediate work-around, it requires a very specific set of options that aren't the default.  We should try to fix this properly.  

Going back to what [~bowenzhangusa] said earlier, the command you ran was {{bin/oozie -Doozie.auth.token.cache=false job -oozie http://localhost:11000/oozie -kill 0000000-140314142500148-oozie-bzha-W}}.  As [~daryn] pointed out, the trace shows the user is anonymous.  If {{oozie.service.AuthorizationService.security.enabled}} is true, then it should be blocking anonymous users from killing the job because that job was (presumably) started by a different user who is not anonymous; so in that sense, the behavior is correct.  
It seems wrong that the user is anonymous; any idea why?  It should pick up the user who is running that kill command.  
What happens when you don't set the cache to false?  , Isn't this an invalid use case?  If anonymous auth is enabled, it makes no sense to enable authz which inherently requires non-anonymous auth.  Authz only makes sense when secure or non-anonymous., {{oozie.service.AuthorizationService.security.enabled}} lets you make it so that only the user who started the job, or an admin user, can modify/kill/etc the job.  Users can still view all jobs, and so an anonymous user could go look at the jobs (i.e. in the Web UI).  Documentation is [here|https://oozie.apache.org/docs/4.0.0/AG_Install.html#User_Authorization_Configuration].

I'm wondering why the user is showing up as anonymous when run from the CLI; that should be picking up the current user..., The user is anonymous because the server is anonymous.  I'm baffled how authz is applicable here because if an anonymous user submitted a job, what authz checks can possibly occur for other operations?, [~rkanter], you are asking the right question. The user showing up as anonymous when killing the job because of this bug. If we fall back to PseudoAuthenticator, we will pick the system value "user.name", so user will not be anonymous., the user who is killing the job is indeed the user who submitted the job. And the PseudoAuthenticator is supposed to pick up the "user.name" so on oozie server side, we know who the user is to authorize "kill/suspend"., The PseudoAuthenticator is for _non-anonymous_ connections.  An anonymous server accepts anonymous connections, as we see here.  A non-anonymous server returns 401 to an anonymous client, causing the PseudoAuthenticator to make the client non-anonymous.

Here's what I can piece together:  Anonymous server accepted an anonymous client's job submission.  Anonymous server accepts anonymous client to list the jobs.  Anonymous server fails authz checks for the anonymous user.  What am I missing?  How can authz + anonymous be expected to work?, Agree with [~daryn], if allowing anonymous, configuring authorization does not make sense. Do you see the problem if anonymous is switched off? If not, I think we can close this JIRA as invalid., Can you give us more time before invalidating the jira?, [~bowenzhangusa], we are still discussing, I will not close this JIRA, we should agree on that first. Can you please answer the question in my last comment? that would help understand the exact scenario.
, We have 2 issues here:
1.Say, if we allow anonymous request and disable authorization like you mentioned above, then this flag "-Doozie.auth.token.cache=false" will determine whether the request can pick the right auth token. If you put "-Doozie.auth.token.cache=false" as part of your command line, then your request will not have token like this one "u=bzhang&p=bzhang&t=simple&e=1394524353045&s=x/DrPWzyjbHP0KF57ta/5ZBrs+8=" at all since we fail to fall back to PseudoAuthenticator in KerberosAuthenticator.java due to HADOOP-10078. While on the other hand, if we use auth token cache, we will pick up the right token from the cahce file. In production, we generally don't want to use the token cache since multiple different users on the same machine can mess up the token.
2, like [~rkanter] mentioned above, "oozie.service.AuthorizationService.security.enabled" and "oozie.authentication.simple.anonymous.allowed" are not mutually exclusive from oozie product point of view. When we allow anonymous request and enable authorization at the same time, we are merely saying anonymous users can view the web console or other job info, it's just we enforce only the owner and admin can kill/modify a job. The "anonymous" config has more to do with viewing oozie webconsole and the "authorization" config has more to do with who can modify a job,
[~rkanter], do you agree? , {quote} In production, we generally don't want to use the token cache since multiple different users on the same machine can mess up the token.{quote}
By default, the token ends up in the user's home dir; so multiple users shouldn't be a problem.  (Unless they all have the same home directory, but that doesn't seem right).

For 2, IIRC, the {{oozie.service.AuthorizationService.security.enabled}} stuff is handled soley within Oozie, isn't it?  It isn't related to tokens at all.  A quick look at AuthorizationService it looks like it just checks the username of a job against the current user or the admin list.  

[~bowenzhangusa], have you run into this problem when you don't set the cache to false?, [~rkanter], 1) in production, what you said is theoretically true. But, we do see customers share or mount the same directories on flubber. This is also probably why we have this "-Doozie.auth.token.cache" flag to begin with.
2) No, I don't have this problem when we don't set "-Doozie.auth.token.cache" to false.
The core of the issue is this: when enabling security, to kill a job, there are two ways to set "user.name" which AuthorizationService.java will use to authorize operation in "public void authorizeForJob(String user, String jobId, boolean write) throws AuthorizationException". One is to read the token cahe file, the other is through calling 
"if (!currentToken.isSet()) {
            Authenticator authenticator = getAuthenticator();
            try {
                new AuthenticatedURL(authenticator).openConnection(url, currentToken);
            }
            catch (AuthenticationException ex) {
                AUTH_TOKEN_CACHE_FILE.delete();
                throw new OozieClientException(OozieClientException.AUTHENTICATION,
                                               "Could not authenticate, " + ex.getMessage(), ex);
            }
        }"
in authoozieclient.java. Due to hadoop-10078, we no longer get "user.name" anymore
, [~tucu00], by looking at apache oozie trunk, "oozie.authentication.simple.anonymous.allowed" is set to true by default. And refer to your previous comment, "If ANONYMOUS is enabled, then there is a token (cookie) and the respose is 200. This does not trigger a fallback". That is not true. We see response of 200 without a token when enabling "ANONYMOUS". And the fact that there is token triggered our problem. , correct my last statement from previous comment. It should be "And the fact that there is no token triggered our problem.", > If ANONYMOUS is enabled, then there is a token (cookie) and the respose is 200. This does not trigger a fallback.

[~tucu00], anonymous with no token seem wrong according to your previous statement.
, Nicholas, there is a special token being used when the ANONYMOUS is enabled. I'll comment on Bowen's and Robert's comments from today later tonight., Oh, right.  I forgot there was a token for the ANONYMOUS user.  
Perhaps the problem is somewhere on Oozie's side where its not properly doing something in the case where the token cache isn't being used?  , bq. But, we do see customers share or mount the same directories on flubber. 

Well, just tell them they are shooting themselves in their feet. They should not do that.

bq.  like Robert Kanter mentioned above, "oozie.service.AuthorizationService.security.enabled" and "oozie.authentication.simple.anonymous.allowed" are not mutually exclusive from oozie product point of view. When we allow anonymous request and enable authorization at the same time, we are merely saying anonymous users can view the web console or other job info, it's just we enforce only the owner and admin can kill/modify a job. The "anonymous" config has more to do with viewing oozie webconsole and the "authorization" config has more to do with who can modify a job,

Are we dealing here with the special authentication handling based on user-agent?
, [~tucu00], when we disable anonymous request, the code works since
{code}
if (conn.getResponseCode() == HttpURLConnection.HTTP_OK)
{code}
evaluates to false because we get 401 back. When we allow anonymous, the above if statement returns true but there is no token. What is the special token you are talking about?, {quote}What is the special token you are talking about?{quote}
If you look in the AuthenticationToken class, there's a token called {{ANONYMOUS}} and some special handling for it.  Also look at the AuthenticationFilter class.  , But the special ANONYMOUS token is not found in Bowen's test.  It is the bug.

This is the reason that my patch works (as a work around) -- it checks if there is a token set in the response.  If there is no token, fall back to PseudoAuthenticator., {quote}But the special ANONYMOUS token is not found in Bowen's test. It is the bug.{quote}
Then shouldn't we fix this instead of doing a work around., If we could fix the bug, yes.  Otherwise, using the work around may not be a bad idea.

[~bowenzhangusa], in your test, the web client is the Ooize CLI, what is the web server?  Is it a Oozie server or a NameNode?, In AuthenticationFilter, it never sets cookie when token is ANONYMOUS.
{code}
//AuthenticationFilter.doFilter(..)
          if (newToken && !token.isExpired() && token != AuthenticationToken.ANONYMOUS) {
            String signedToken = signer.sign(token.toString());
            createAuthCookie(httpResponse, signedToken, getCookieDomain(),
                    getCookiePath(), token.getExpires(), isHttps);
          }
{code}, For simple, anonymous server, if the request has a expired token with username foo but user.name is not set, what should the username in the response token be?  foo or anonymous?, Filed HADOOP-10416 and HADOOP-10417 for the server-side bugs.  Resolving this as invalid., Overall, I think it's a bad design for oozie to use KerberosAuthenticator in a non-secure environment and expect hadoop client to fall back to PseudoAuthenticator., The idea is that the oozie client handles a secure oozie server but fallback to non-secure if the server is non-secure., Is it reasonable to stop the user from shooting themselves in the foot by having anonymous disable authz?, > ... having anonymous disable authz?

But then the Ooize web ui will also need authentication.

Also, if we cannot enable it, what is the point to have such "anonymous" feature?  It is simply broken., [~szetszwo], anonymous means 'we don't expect the username to be known at all', if you enable authorization for something (oozie job kill in  Bowen's use case, if I recall correctly), then you cannot use anonymous., [~tucu00], in Bowen's use case, there is an expired token with a valid username.  The client doesn't want to be authenticated as anonymous.  However, the auth filter somehow authenticates the client as anonymous.  Returning an error (so that the client could retry with user.name) or taking the username from the token is fine.

> ... anonymous means 'we don't expect the username to be known at all' ...

I don't understand the statement above.  Do you mean that the client should not provide user.name?]