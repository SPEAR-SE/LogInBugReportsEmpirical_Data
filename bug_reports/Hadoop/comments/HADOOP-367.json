[Will the setAccessable trick used in JobConf.newInstance() work here too?  I hope it is possible to have non-public classes as parameters in non-public RPC protocols.  For implementation flexibility we'd like to keep some protocols package-protected, so that our only back-compatibility burdens are public, client APIs., When would you call setAccessable? It would have to be outside of the class 
since nothing is initialized at class load time.

One option would be to put a public static getFactory() method on class that want this non-public behavior. 
Not only would that cause the static blocks to be run when called, but it would allow you 
to get rid of the factory table and just use reflection to call getFactory() 
on the class if there is one otherwise fall back to newInstance()., I was thinking of a hack where we call setAccessible on the constructor before calling it, as is done in JobConf.  We'd bypass the factory altogether.

Your proposal (a public static getFactory method) is better.  Would you like to prepare a patch?, Arg! It seems that public static methods on non-public classes cannot be called with reflection :( So I took a different approach that is simpler and less code. (This patch removes 132 lines and adds 18.)

I noticed that all of the factories simply created new objects. So now the WritableFactories.newInstance method finds the factory that corresponds to the package of the class and lets that factory create it. This means that there needs to be a WriteableFactory for each package that has Writables. This lowers the number of overall factories while adding one visible factory per package. It also simplifies the Writables since they don't need to worry about factories anymore., Oops.  Mistakenly resolved., We might as well just use setAccessible.  Let's just add a static util method:

public Object newInstance(Class aClass);

This can can be implemented like JobConf.newInstance().  Then JobConf.newInstance() can call this, and we can replace all calls to WritableFactories.newInstance() with calls to this.  If we ever become worried about abuse of this method, we can restrict its use to particular, approved packages or somesuch.

This would be even less code!, This patch provides a util function newInstance. It's an incomplete patch to this bug. Still need to clean up all the factories., I committed the reflection patch, but am not yet closing this.

Hairong, will you provide a patch replacing WritableFactory with ReflectionUtils?, 
   [[ Old comment, sent by email on Tue, 25 Jul 2006 10:30:37 -0700 ]]

When would you call setAccessable? It would have to be outside of the class 
since nothing is initialized.

One option would be to put a public static getFactory() method on the class. 
Not only would that cause the static blocks to be run, but it would allow you 
to get rid of the factory table and just use reflection to call getFactory() 
on the class if there is one otherwise fall back to newInstance().

ben

, This has been fixed across several patches by using the new ReflectionUtils.newInstance in all contexts. We currently require java 5.0, so clearly this bug isn't present anymore.]