[Thanks [~xiaochen] and [~shahrs87] for reporting this. I hava attach \{{HADOOP-15344.001.patch}}., Now I am thinking whether we should do this change.
{{keyProvider#close}} is getting called from {{KMSTokenRenewer#close}}.

{code:java}
// Some comments here
  public long renew(Token<?> token, Configuration conf) throws IOException {
{
         ...
         ...
         return ((KeyProviderDelegationTokenExtension.DelegationTokenExtension)
          keyProvider).renewDelegationToken(token);
    } finally {
      if (keyProvider != null) {
        keyProvider.close();
      }
    }
}
{code}
 Lets assume  the {{keyProvider}} object is a {{LoadBalancingKMSCP}} comprising of 2 {{KMSCP}} and one {{KMSClientProvider}} is having problems while closing.
Since there are retries inside {{LoadBalancingKMSCP#doOp}}, {{keyProvider#renewDelegationToken(token)}} will retry after encountering bad {{KMSCP}} and it succeeds on second KMSCP but {{renew}} will throw an Exception in finally block which will fail the renew operation.
Hope it makes sense.
Let me know if I missed anything or if my analysis is incorrect., | (/) *{color:green}+1 overall{color}* |
\\
\\
|| Vote || Subsystem || Runtime || Comment ||
| {color:blue}0{color} | {color:blue} reexec {color} | {color:blue}  0m  9s{color} | {color:blue} Docker mode activated. {color} |
|| || || || {color:brown} Prechecks {color} ||
| {color:green}+1{color} | {color:green} @author {color} | {color:green}  0m  0s{color} | {color:green} The patch does not contain any @author tags. {color} |
| {color:green}+1{color} | {color:green} test4tests {color} | {color:green}  0m  0s{color} | {color:green} The patch appears to include 1 new or modified test files. {color} |
|| || || || {color:brown} trunk Compile Tests {color} ||
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green} 25m  7s{color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 27m 26s{color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} checkstyle {color} | {color:green}  0m 50s{color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green}  1m  7s{color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} shadedclient {color} | {color:green} 12m 13s{color} | {color:green} branch has no errors when building and testing our client artifacts. {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green}  1m 31s{color} | {color:green} trunk passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green}  0m 56s{color} | {color:green} trunk passed {color} |
|| || || || {color:brown} Patch Compile Tests {color} ||
| {color:green}+1{color} | {color:green} mvninstall {color} | {color:green}  0m 44s{color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} compile {color} | {color:green} 26m 15s{color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} javac {color} | {color:green} 26m 15s{color} | {color:green} the patch passed {color} |
| {color:orange}-0{color} | {color:orange} checkstyle {color} | {color:orange}  0m 49s{color} | {color:orange} hadoop-common-project/hadoop-common: The patch generated 1 new + 11 unchanged - 0 fixed = 12 total (was 11) {color} |
| {color:green}+1{color} | {color:green} mvnsite {color} | {color:green}  1m  4s{color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} whitespace {color} | {color:green}  0m  0s{color} | {color:green} The patch has no whitespace issues. {color} |
| {color:green}+1{color} | {color:green} shadedclient {color} | {color:green} 10m 14s{color} | {color:green} patch has no errors when building and testing our client artifacts. {color} |
| {color:green}+1{color} | {color:green} findbugs {color} | {color:green}  1m 37s{color} | {color:green} the patch passed {color} |
| {color:green}+1{color} | {color:green} javadoc {color} | {color:green}  0m 55s{color} | {color:green} the patch passed {color} |
|| || || || {color:brown} Other Tests {color} ||
| {color:green}+1{color} | {color:green} unit {color} | {color:green}  8m 13s{color} | {color:green} hadoop-common in the patch passed. {color} |
| {color:green}+1{color} | {color:green} asflicense {color} | {color:green}  0m 36s{color} | {color:green} The patch does not generate ASF License warnings. {color} |
| {color:black}{color} | {color:black} {color} | {color:black}119m 30s{color} | {color:black} {color} |
\\
\\
|| Subsystem || Report/Notes ||
| Docker | Client=17.05.0-ce Server=17.05.0-ce Image:yetus/hadoop:8620d2b |
| JIRA Issue | HADOOP-15344 |
| JIRA Patch URL | https://issues.apache.org/jira/secure/attachment/12916388/HADOOP-15344.001.patch |
| Optional Tests |  asflicense  compile  javac  javadoc  mvninstall  mvnsite  unit  shadedclient  findbugs  checkstyle  |
| uname | Linux 21c1cefde06e 3.13.0-139-generic #188-Ubuntu SMP Tue Jan 9 14:43:09 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux |
| Build tool | maven |
| Personality | /testptch/patchprocess/precommit/personality/provided.sh |
| git revision | trunk / c22d62b |
| maven | version: Apache Maven 3.3.9 |
| Default Java | 1.8.0_151 |
| findbugs | v3.1.0-RC1 |
| checkstyle | https://builds.apache.org/job/PreCommit-HADOOP-Build/14394/artifact/out/diff-checkstyle-hadoop-common-project_hadoop-common.txt |
|  Test Results | https://builds.apache.org/job/PreCommit-HADOOP-Build/14394/testReport/ |
| Max. process+thread count | 1531 (vs. ulimit of 10000) |
| modules | C: hadoop-common-project/hadoop-common U: hadoop-common-project/hadoop-common |
| Console output | https://builds.apache.org/job/PreCommit-HADOOP-Build/14394/console |
| Powered by | Apache Yetus 0.8.0-SNAPSHOT   http://yetus.apache.org |


This message was automatically generated.

, Thanks [~zhenyi] for working on this and [~shahrs87] for the thoughts.

{quote}but {{renew}} will throw an Exception in finally block which will fail the renew operation.
{quote}
Could you elaborate? If one of the KMSCP inside LBKMSCP succeeds, LBKMSCP#doOp will return. The exception from the failure is just logged and won't be thrown out.

Regarding close, if any of the close failed, I think it makes sense to throw, the same way as if in a close method of a class, if any sub resources failed to close, the class' close should throw, right? So I think your initial propose makes sense, and we should throw on close failures, bq. The exception from the failure is just logged and won't be thrown out.
Yes, you are correct.  LBKMSCP#doOp will succeed.

{code}
finally {
      if (keyProvider != null) {
        keyProvider.close();
      }
{code}
Lets say if one of kmscp threw an exception on close, then it will appear to renew client that the renew operation failed but it succeeded in reality.
Am I making sense ?
, Makes sense. IMO that falls to API semantics - close should still throw. It's a broader API and we should follow the general close behavior (e.g. java.io.IOException.Closeable)

If a caller wants to swallow and log the close exception, they can do tat. In this case, I think KMSTokenRenewer should log.error the close.]