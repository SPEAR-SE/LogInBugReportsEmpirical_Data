[I can see the second of these.

The problem is that setupIOStreams tries to clean up 
  try {
       ...
       this.out = new DataOutputStream
            (new BufferedOutputStream(NetUtils.getOutputStream(socket)));
      ...
      } catch (IOException e) {
        markClosed(e);
        close();
      }

but what does close() do? It synchronizes on out, which will be null if the exception happened before the output stream was created, leading to our friend NPE:
    synchronized (out) {
        // release the resources
        // first thing to do;take the connection out of the connection list
        synchronized (connections) {
          if (connections.get(remoteId) == this) {
            connections.remove(remoteId);
          }
        }
, Hairong -is the first stack trace from a different version of the code than SVN_HEAD? If so, is line 521 and 434 of that version what is at line 519 and 432 of SVN head? 

If so, the root cause is the same: out is null., For the first one, I did some changes in Client.java trying to fix the bug.  So the line numbers are different from the original source.  Steve, you are right: the cause of two cases are probably the same., This patch makes sure that connection.close() checks if the connection has been set up or not so avoiding NPE., This patch does not work because a call might have enqueued when socket is null. Maybe using a lock as Steve suggested is a better approach. Let me think more about  it., I think it makes sense to keep a separate output stream lock the way Steve suggested. 

Object outLock = new Object()
synchronizes (outLock) { ... }

This should fix the Null pointer issue with synchronizing on null output stream.  

, The bug was fixed as part of HADOOP-3455.]