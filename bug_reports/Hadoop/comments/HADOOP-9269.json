[afaik, the field metrics are created in method org.apache.hadoop.metrics2.lib.MutableMetricsFactory.newForField(Field, Metric, MetricsRegistry), and the value of @Metric#always is just ignored in case of MutableCounter/Gauge classes.
Also, in case of MurableStat/Rate the "always" value is used as "extended" parameter, which has another meaning: "produce extended stat (stdev, min/max etc.) if true.". 
It looks like there is a mess with this annotation parameter., Making the description short and moving the details to this comment.

{noformat}Metrics2: 
if a metric defined via annotations, like this 
@Metric(....,always=true), it should be snapshotted always, as defined by the "always" attribute description: 
  /**
   * @return true to create a metric snapshot even if unchanged.
   */
  boolean always() default false;

However, that does not work in that way. 
The problem can be reproduced with the following test:

public class TestBugDemo {

  @Metrics(name="record1", context="context1")
  static class MyMetrics1 {
    
    @Metric(value={"annotatedMetric1", "An integer gauge"},always=true) 
    MutableGaugeInt testMetric1;

    public MyMetrics1 registerWith(MetricsSystem ms) {
      return ms.register("annotated", "annotated", this);
    }
  }
  
  private static class MySink implements MetricsSink {
    private final String sinkName;
    public MySink(String name) {
      sinkName = name;
    }
    @Override
    public void init(SubsetConfiguration conf) {
    }
    @Override
    public void flush() {
    }
    @Override
    public void putMetrics(MetricsRecord record) {
      if (!"metricssystem".equals(record.context())) {
        for (AbstractMetric am: record.metrics()) {
          System.out.println("### METRIC: " + am.name() + " = " + am.value());
        }
      }
    }
  }
  
  private MetricsSystem ms;
  MyMetrics1 m1;
  
  @Before
  public void before() {
    ms = DefaultMetricsSystem.initialize("");

    // register annotated source:
    m1 = new MyMetrics1().registerWith(ms);
    
    // register not-annotated source:
    final MetricsInfo fooInfo = Interns.info("non-annotated metric foo", "foo descrption");
    ms.register("not-annotatad", "", new MetricsSource() {
      @Override
      public void getMetrics(MetricsCollector collector, boolean all) {
        collector
          .addRecord("testRecord")
          .addCounter(fooInfo, 88)
          .setContext("test1")
          .endRecord();
      }
    });
    
    ms.register("sink1", null, new MySink("sink1"));
  }
  
  @Test
  public void testAlways() {
    m1.testMetric1.set(5);
    System.out.println("First  Pubishing: ===========================================================");
    ms.publishMetricsNow();
    
    //m1.testMetric1.set(7);
    System.out.println("Second Pubishing: ===========================================================");
    ms.publishMetricsNow();
  }
  
}

This test generates the following output:
First  Pubishing: ===========================================================
### METRIC: annotatedMetric1 = 5
### METRIC: non-annotated metric foo = 88
Second Pubishing: ===========================================================
### METRIC: non-annotated metric foo = 88

That is, the metric "annotatedMetric1" is absent in the 2nd snapshot.

Once we uncomment the line "//m1.testMetric1.set(7);", we observe expected behavior:
First  Pubishing: ===========================================================
### METRIC: annotatedMetric1 = 5
### METRIC: non-annotated metric foo = 88
Second Pubishing: ===========================================================
### METRIC: annotatedMetric1 = 7
### METRIC: non-annotated metric foo = 88

The expected behavior is that the metric "annotatedMetric1" will be snapshotted even if it was not changed, because it is annotated with "always=true". 

{noformat}
]