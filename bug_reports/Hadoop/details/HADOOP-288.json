{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12344101","self":"https://issues.apache.org/jira/rest/api/2/issue/12344101","key":"HADOOP-288","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310240","id":"12310240","key":"HADOOP","name":"Hadoop Common","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310240&avatarId=10095","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310240&avatarId=10095","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310240&avatarId=10095","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310240&avatarId=10095"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312051","id":"12312051","description":"","name":"0.7.0","archived":false,"released":true,"releaseDate":"2006-10-06"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2006-06-20T07:30:22.000+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Thu Sep 14 22:11:37 UTC 2006","customfield_12310420":"80662","customfield_12312320":null,"customfield_12310222":"10002_*:*_1_*:*_1302129000_*|*_1_*:*_2_*:*_7214477000_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_1899439000","customfield_12312321":null,"resolutiondate":"2006-09-14T22:11:37.000+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-288/watchers","watchCount":1,"isWatching":false},"created":"2006-06-08T08:28:11.000+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"7.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312025","id":"12312025","description":"","name":"0.6.0","archived":false,"released":true,"releaseDate":"2006-09-08"}],"issuelinks":[{"id":"12313281","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12313281","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12347835","key":"MAPREDUCE-458","self":"https://issues.apache.org/jira/rest/api/2/issue/12347835","fields":{"summary":"Adding caching to Hadoop which is independent of the task trackers.","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/4","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/minor.svg","name":"Minor","id":"4"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype","name":"New Feature","subtask":false,"avatarId":21141}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2006-10-06T21:48:56.000+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[],"timeoriginalestimate":null,"description":"RFC: Efficient file caching \n(on Hadoop Task nodes, for benefit of MapReduce Tasks)\n------------------------------------------------------\n\nWe will start implementing this soon. Please provide feedback and improvements to this plan.\n\nThe header \"Options:\" indicates places where simple choices must be made.\n\n\nProblem:\n-------\no MapReduce tasks require access to additional out-of-band data (\"dictionaries\")\n\nThis out-of-band data is:\n\no in addition to the map/reduce inputs.\no large (1GB+)\no broadcast (same data is required on all the Task nodes)\no changes \"infrequently\", in particular:\noo it is always constant for all the Tasks in a Job. \noo it is often constant for a month at a time \noo it may be shared across team members\no sometimes used by pure-Java MapReduce programs\no sometimes used by non-Java MapReduce programs (using Hadoop-Streaming)\no (future) used by programs that use HDFS and Task-trackers but not MapReduce.\n\nExisting Solutions to the problem:\n---------------------------------\nThese solutions are not good enough. The present proposal is to do Sol 1 with caching.\n\nSol 1: Pure Hadoop: package the out-of-band data in the MapReduce Job jar file.\nSol 2: Non  Hadoop: for each task node run rsync from single source for data.\nSol 3: Non  Hadoop: use BitTorrent, etc.\n\nSol.1 is correct but slow for many reasons:\n The Job submitter must recreate a large jar(tar) file for every Job.\n  (The jar contains both changing programs and stable dictionaries)\n The large Jar file must be propagated from the client to HDFS with \n a large replication factor. \n At the beginning of every Task, the Task tracker gets the job jar from HDFS \n and unjars it in the working directory. This can dominate task execution time.\n \nSol.2 has nice properties but also some problems.\n It does not scale well with large clusters (many concurrent rsync read requests i.e. single-source broadcast)\n It assumes that Hadoop users can upload data using rsync to the cluster nodes. As a policy, this is not allowed.\n It requires rsync.\n \nSol.3 alleviates the rsync scalability problems but \n      It is a dependency on an external system. \n      We want something simpler and more tightly integrated with Hadoop.\n      \n\nStaging (uploading) out-of-band data:\n------------------------------------\nThe out-of-band data will often originate on the local filesystem of a user machine \n (i.e. a MapReduce job submitter)\nNevertheless it makes sense to use HDFS to store the original out-of-band data because:\no HDFS has (wide) replication. This enables scalable broadcast later.\no HDFS is an available channel to move data from clients to all task machines.\no HDFS is convenient as a shared location among Hadoop team members.\n\n\nAccessing (downloading) out-of-band data:\n----------------------------------------\nThe non-Java MapReduce programs do not have or want[1] APIs for HDFS.\nInstead these programs just want to access out-of-band data as \n local files at predefined paths.\n([1] Existing programs should be reusable with no changes. \n This is often possible bec. communication is over stdin/stdout.)\n\n\n\nJob's jar file as a special case:\n--------------------------------\nOne use case is to allow users to make the job jar itself cachable.\n\nThis is only useful in cases where NOTHING changes when a job is resubmitted\n (no MapRed code changes and no changes in shipped data)\nThis situation might occur with an 'extractor' job (gets data from an external source: like Nutch crawler)\n\nCurrently the Hadoop mapred-jar mechanism works in this way:\n the job jar data is unjarred in the \"working directory\" of the Task \n the jar contains both MapRed java code (added to classpath)\n\n\n\nCache synchronization:\n---------------------\n\nThe efficient implementation of the out-of-band data distribution\nis mostly a cache synchronization problem.\nA list of the various aspects where choices must be made follows.\n\n\nCache key:\n---------\nHow do you test that the cached copy is out-of-date?\n\nOptions: \n1. the archive/file timestamp \n2. the MD5 of the archive/file content\n\nComparing source and destination Timestamps is problematic bec. it assumes synchronized clocks.\nAlso there is no last-modif metadata in HDFS (for good reasons, like scalability of metadata ops)\n\nTimestamps stored with the source ('last-propagate-time') do \n not require synchronized clocks, only locally monotonic time. \n(and the worse which can happen at daylight-savings switch is a missed update or an extra-update)\n\nThe cache code could store a copy of the local timestamp \nin the same way that it caches the value of the content hash along with the source data.\n \n\n\nCachable unit:\n-------------\nOptions: individual files or archives or both.\n\nNote:\nAt the API level, directories will be processed recursively \n(and the local FS directories will parallel HDFS directories)\nSo bulk operations are always possible using directories.\nThe question here is whether to handle archives as an additional bulk mechanism.\n\n\nArchives are special because:\no unarchiving occurs transparently as part of the cache sync\no The cache key is computed on the archive and preserved although \n  the archive itself is not preserved.\nSupported archive format will be: tar (maybe tgz or compressed jar)\nArchive detection test: by filename extension \".tar\" or \".jar\"\n\nSuppose we don't handle archives as special files:\nPros:\n o less code, no discussion about which archive formats are supported\n o fine for large dictionary files. And when files are not large, user may as well\n   put them in the Job jar as usual.\n o user code could always check and unarchive specific cached files\n   (as a side-effect of MapRed task initialization)\nCons:\n o handling small files may be inefficient \n  (multiple HDFS operations, multiple hash computation, \n   one 'metadata' hash file along with each small file)\n o It will not be possible to handle the Job's jar file as a special case of caching \n\n\n\nCache isolation: \n---------------\nIn some cases it may be a problem if the cached HDFS files are updated while a Job is in progress:\nThe file may become unavailable for a short period of time and some tasks fail.\nThe file may change (atomically) and different tasks use a different version.\n\nThis isolation problem is not addressed in this proposal.\nStandard solutions to the isolation problem are:\n\no Assume that Jobs and interfering cache updates won't occur concurrently.\n\no Put a version number in the HDFS file paths and refer to a hard-coded version in the Job code.\n\no Before running the MapRed job, run a non-distributed application that tests\n  what is the latest available version of the out-of-band data. \n  Then make this version available to the MapRed job.\n  Two ways to do this. \n  o either set a job property just-in-time:\n    addCachePathPair(\"/mydata/v1234/\", \"localcache/mydata_latest\"); \n    (see Job Configuration for meaning of this)\n  o or publish the decision as an HDFS file containing the version.\n    then rely on user code to read the version, and manually populate the cache:\n    Cache.syncCache(\"/hdfs/path/fileordir\", \"relative/local/fileordir\");\n    (see MapReduce API for meaning of this)\n\n\nCache synchronization stages:\n----------------------------\nThere are two stages: Client-to-HDFS and HDFS-to-TaskTracker\n\no Client-to-HDFS stage.\nOptions: A simple option is to not do anything here, i.e. rely on the user.\n\nThis is a reasonable option given previous remarks on the role of HDFS:\n HDFS is a staging/publishing area and a natural shared location.\nIn particular this means that the system need not track \nwhere the client files come from.\n\n\no HDFS-to-TaskTracker:\nClient-to-HDFS synchronization (if done at all) should happen before this.\nThen HDFS-to-TaskTracker synchronization must happen right before \nthe data is needed on a node.\n\n\n\nMapReduce cache API:\n-------------------\nOptions:\n\n1. No change in MapReduce framework code:\nrequire the user to put this logic in map() (or reduce) function:\n\n in MyMapper constructor (or in map() on first record) user is asked to add:\n \n    Cache.syncCache(\"/hdfs/path/fileordir\", \"relative/local/fileordir\");\n    Cache.syncCache(\"...\"); //etc.\n  \n-----\n\n2. Put this logic in MapReduce framework and use Job properties to\n   communicate the list of pairs (hdfs path; local path)\n \nDirectories are processed recursively.\nIf archives are treated specially then they are unarchived on destination.\n\n \nMapReduce Job Configuration:\n---------------------------\nOptions:\n\nwith No change in MapReduce framework code (see above)\n no special Job configuration: \n   it is up to the MapRed writer to configure and run the cache operations.\n\n---\nwith Logic in MapReduce framework (see above)\n some simple Job configuration\n\nJobConf.addCachePathPair(String, String)\nJobConf.addCachePathPair(\"/hdfs/path/fileordir\", \"relative/local/fileordir\");\n\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12339522","id":"12339522","filename":"caching.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-24T21:06:14.000+0000","size":57398,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12339522/caching.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12339391","id":"12339391","filename":"caching.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-23T08:51:28.000+0000","size":59679,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12339391/caching.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12340013","id":"12340013","filename":"caching-3.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-01T03:33:39.000+0000","size":55339,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12340013/caching-3.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12340213","id":"12340213","filename":"caching-4.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-05T19:38:57.000+0000","size":57205,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12340213/caching-4.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12340775","id":"12340775","filename":"caching-5.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-13T21:18:27.000+0000","size":61109,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12340775/caching-5.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12339393","id":"12339393","filename":"test.jar","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-23T08:51:28.000+0000","size":518,"mimeType":"application/java-archive","content":"https://issues.apache.org/jira/secure/attachment/12339393/test.jar"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12339392","id":"12339392","filename":"test.zip","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-23T08:51:28.000+0000","size":213,"mimeType":"application/zip","content":"https://issues.apache.org/jira/secure/attachment/12339392/test.zip"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"107198","customfield_12312823":null,"summary":"RFC: Efficient file caching","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12416824","id":"12416824","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"body":"Hadoop proposal: file caching\nupdated description with more details.\n----------\n\nEfficient file caching \n(on Hadoop Task nodes, for benefit of MapReduce Tasks)\n\nOverview\n========\nThis document describes a mechanism for caching files or archives on taskTracker nodes' local file system.\nExporting and extracting large archives from HDFS to local filesystem is expensive.\nAnd is often required by the applications.\nCurrently this would happen at the beginning of every Task of a MapReduce Job.\n\nThe purpose of the Hadoop file cache is to minimize this overhead by\npreserving and reusing the extracted data\n\nDuring a MapRed job there are two kinds of data being uploaded to a Hadoop cluster:\n  Java code and Out-of-band data.\n\nJava code may include libraries so this can easily get large. (megabytes)\n\nOut-of-band data is any data used by the job, in addition to the map input or the reduce input.\nFor example a large dictionary of words. This can also get large (gigabytes)\n\n\nThere are two main kinds of cacheable files:\n1. The MapReduce job jar. \n   This contains Java code and possibly out-of-band data.\n2. Additional archives\n   This contains out-of-band data.\n\nThe proposed solution suggests that\nCacheable files:\nare stored in HDFS, and specified in the JobConf of a MapReduce job.\nA special case is the job jar file, which will get cached by default.\n\nSupported formats for cacheable files are jar, tar and gzip, \nAdditional formats could be added at a future time.\nRegular files are also supported\n\n\nWorkflow:\n========\nFor out-of-band data, the user must first explicitly upload archives to HDFS.\nThis can be done using any HDFS client.\nIt is typical for out-of-band data to be reused across Jobs and users.\n\nThe user specifies the out-of-band data using:\nJobConf.addCachedArchive() or JobConf.addCachedFile()\n\nThe user specifies the job jar as today:\nJobConf.setJar(\"f.jar\") which implicitly has the effect of:\nJobConf.addCachedArchive(\"f.jar\"). \n\nWhen a Job starts, the JobTracker does the following for each cached archive.\nCompute a strong hash of the archive and store the hash in the HDFS.\nTo avoid reading and scanning the archive, the strong hash is based\non the existing HDFS block-CRC codes rather than on the actual content.\n\nWhen a Task starts, the TaskTracker does the following for each cached archive.\nRetrieve the strong hash from HDFS, compare with the hash of the local copy.\nIf the local hash does not exist or is different, then\n  retrieve the archive, unarchive it, update the local hash.\nIf the archive is the job jar, then\n  copy or hard-link the archive contents to the Task working directory.\nThen start the TaskRunner as usual.\n\nOnce the Task is running, the user code may access the cached archive contents.\nThis usually happens at initialization time.\nIf the JobConf added the cached archive: /hdfsdir/path/f.jar\nThen the task can expect to access the archive content at:\n$HADOOP_CACHE/hdfsdir/path/fdir/ffile \nor maybe:\n$HADOOP_CACHE/hdfsdir/path/f_jar/fdir/ffile\nThe second option guarantees that multiple archives \nin the same directory will not clobber each other.\nThe translation of f.jar to f_jar is a convention to ease the distinction of file names and directory names.\n\n\nNote that in the above, the HDFS paths are mirrored on the local filesystem.\nThe intent is to provide namespace protection.\n[i.e. the contents of hdfs1/archive.jar and hdfs2/archive.jar should not collide in the cache]\nThe intent is not to make cache paths interchangeable with HDFS paths. \n\n\nThe variable HADOOP_CACHE is made available to the task as\na JobConf property that is dynamically set by the TaskRunner code.\n\nCache size control:\n------------------\nWe cannot let the cache grow unbounded.\n\nThe cache is always up-to-date at the start of a job.\nSo the configurable parameter should not be the age of the cached data \nbut the total size of the cache. \nThe cache size is a static TaskTracker configuration parameter.\n\nLRU (least recently used) policy:\nOn each Task tracker, the cache manager will measure the total size of the cache\nand expire the oldest cached items. \nWhen a cached item is requested again in a different job, it goes back to the top.\n\nThe cached archive contents are required for the MapReduce task to function.\nSo when the promised cache contents cannot be provided, \nthe cache manager will force a job failure \n\nBefore new files are added to the cache, we do this size test.\nIf the cache size limit WOULD require to expire files...\n1. .. expire files for completed jobs then everything is fine: delete them.\n2. .. expire files for jobs that are already running, then the NEW job fails.\n3. .. expire files for the new job then the new job fails.\n\nNote that a file (archive) may belong to multiple jobs.\n\nIn normal use the cache size is expected to be significantly larger \nthan the files requested by a single job. \nSo the failure modes due to cache overflow should rarely occur.\n\nTHE END.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"created":"2006-06-20T07:10:32.000+0000","updated":"2006-06-20T07:10:32.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12416826","id":"12416826","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=psutter","name":"psutter","key":"psutter","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"p sutter","active":true,"timeZone":"Etc/UTC"},"body":"\nWhy not \n- leave the \"archived\" data in DFS,\n- with its replication level set to infinite, and\n- make a change to the DFS client so that it will replicate blocks of such files locally when they are accessed, and\n- ensure that blocks that are local are accessed through the local file system instead of through DFS\n\nWouldnt that be simpler than having a whole new mechanism?\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=psutter","name":"psutter","key":"psutter","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"p sutter","active":true,"timeZone":"Etc/UTC"},"created":"2006-06-20T07:30:22.000+0000","updated":"2006-06-20T07:30:22.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12416978","id":"12416978","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"body":"Yes, staying within the context of DFS could be simpler. \nNote however that we have these requirements:\n1. archive files are sometimes used by non-Java non-Hadoop MapReduce programs (using http://wiki.apache.org/lucene-\nhadoop/HadoopStreaming) \n2. avoid repetitive expansion of the job jar and of other archives for each Task in the Job.\n3. In case of many small files, avoid a per-file overhead for DFS and cache operations.\n\nBecause of 1. the files must really be native OS files, not DFS files. \nFor such general tools, the \"common-denominator API\" is only: the base directory for the cache.\n\nToday, unarchiving the job jar occurs in Hadoop, not in the MapRed application. But it is not cached.\nBecause of 2. and 3. the unarchiving process itself must be cacheable.\nSo unarchiving must occur in the Hadoop framework, not the MapRed application.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"created":"2006-06-21T03:11:28.000+0000","updated":"2006-06-21T03:11:28.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12417918","id":"12417918","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"body":"A problematic choice must be made to implement the following.\n--\nCurrently without caching: in Hadoop the Task working directory contains the expanded contents of the job jar. \nLater with caching: the Task working directory contents should be efficiently created from the filecache contents.\n--\nSo how to synchronize the task working directory job jar data with the file cache?\nOr how to work around the need to do this?\n\nSome options follow, all have problems. \nWhich one is best?\n---------------------------------------\nOption 1. Symbolic links\nThis includes Symbolic links to jar files.\nIt is probably brittle to have classpath elements as symbolic links.\nBut cross-platform support is a little easier than hard links (next)\n--\nOption 2. Hard links\nProblematic for cross-platform support. Both NTFS and UFS can create hard-linked files.\nAt best it works on all platforms but requires launching native/cygwin tools.\nAnd possibly cygwin is not good enough to handle hard links on NTFS.\n--\nOption 2.5 File copy as a fallback mechanism for Option 2.\nProblem is that this is slower and partially defeats the purpose of caching.\n--\nOption 3. \nchange the MapReduce Job jar location.\nThe current convention is \"working directory\" contains MapReduce code jar and resources.\nThe modified convention would be that this directory is a parameter (pointing to a specific directory in the archive cache area)\n This new parameter could be exposed to the MapRed job as JobConf param, as a system property or as environment variable.\nUpside: pure java. \nDownside: not fully backward compatible\n--\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=michel_tourn","name":"michel_tourn","key":"michel_tourn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Michel Tourn","active":true,"timeZone":"America/New_York"},"created":"2006-06-27T05:24:39.000+0000","updated":"2006-06-27T05:24:39.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12417955","id":"12417955","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"body":"Option #3 seems like the simplest to implement, maintain and explain.  \nWould this blow anything up in nutch?  \n\nWe could of course provide a flag that causes the backwards compatible copy for a release or two if really needed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-06-27T10:52:32.000+0000","updated":"2006-06-27T10:52:32.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12429938","id":"12429938","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"I have attached two other files to the patch which are small .jar and .zip files needed for the junit tests.\n\nCaching and job.jars:\n\nTwo parts to the patch:\n1) Unjarring job.jar once for a job\n2) Archiving archives/files locally \n\n1) Unjarring of job.jar\nCurrently the job.jar is unjarred for each task. This patch makes the framework do the unjarring only once for the job. The current working directory for each task if the same directory where the job is unjarred once. \nSo the directory structure now looks like:\n\ntasktracker/jobcache/jod_id/workdir -- the dir where the job is unjarred once\n----------------------------/job_id/task_id/task_specific_job.xml\n\nThe current working dir for each task is the workdir.\n\n2) Archiving of files- \n\ni) Each job can ask for a set of archives/files to be localized. The api for that is \n jobconf.setCacheArchives(comma seperated list of archives)\n or \n jobconf.setCacheFiles(comma seperated list of files).\n The comma seperated list can be specified as absolute path to files/caches (eg. /user/mahadev/test.jar) if they are in the same dfs as the mapred is running on or else they can be specified using urls as in copyfiles ( dfs://hostname:port/path_to_cache )\n There are two apis provided so that users who do not want their archives to be unarchived by the framework or just want to localize a file should use the second api.\n\nii) These archives/files should be present in the specified DFS for localizing.\n    The user makes sure that these archives are present in the DFS before he submits the job else an error will be thrown that these archives are not present in DFS.\n\niii) Localization happens across jobs. So each cache archive/file has a key and the key is the url of the cache (in case of absolute path its the absolute path) \n\niv) Whenever a job is started, the first tasks for these jobs will localize the archives. \n    The archives are stored in mapred.local/tasktracker/archives/hostname_of_dfs/dfs path of the archive.\n    So an archive called /user/mahadev/k.zip  on a dfs running on machine1 would be unarchived in  \n    dir =  mapred.local/tasktracker/archives/machine1/user/mahadev/k.zip/\n    This dir contains the unarchived contents of k.zip.\n    If it is just a file (/user/mahadev/test.txt and not an archive, then it is stored in a directory called \n    mapred.local/tasktracker/archives/machine1/user/mahadev/test.txt/test.txt\n    the local directory name contains test.txt directory just to make it similar to the archive structure.\n\n   if no dfs://hostname:port is specified (eg : setcachefiles(/user/mahadev/test.txt)), in that case it is stored in \n  mapred.local/tasktracker/archives/hostname_of_dfs_usedby_mapred/user/mahadev/test.txt\n\nv) The archives are localized only once and checked for each task if they are fresh and need to be refresed or not.\n   This is done using md5 checksum of the .crc files for the archives.\n   \n   Steps:\n    a) When a job is submitted, the md5 checksums of the required archives/files in dfs are calculated and are written into the \n       jobconf.\n    b) when a task is executing, it matches this md5 to the md5 of the localized cache (stored in memory after it has been localized). If they match its fine to go ahead with this archive.\n       If it does not match then the md5 of the .crc of the file in dfs is calculated. If this does not match then the archives have been changed since the job has been submitted, so the tasks fail with this error. If they do match then the cache is refreshed again. \n\n    c) Two jobs can use the same archives in parallel, but if the second job updates the same archive and tries using the updated archive, then it will fail.\n    \nvi) How to get the localized cache paths\n   An api in the jobconf called jobconf.getLocallizedCacheArchives gives a comma seperated list of localized path of the archives in the same order they had been asked to be localized.\n  Also, you can use names for archives. So you could do something like:\n setcachearchives(x=somearchive)\nand in the maps/reduces do conf.getNamedCache(x) and it will return the localized path of the cache named x.\nvii) Restrictions: \n  Currently only *.zip and *.jar are only supported for archives. \n\nviii) Also, caching across tasktracker going up and down is not supported. So a tasktracker would lose all caching information once it goes down. The caching information can be reconstructed when the task tracker comes up but the support is not available in this patch.\n\nix) When are the caches deleted?\n    A soft limit on the cache directory is a configuration parameter in the hadoop-default set to 10GB. So whenever the cache directory size goes beyond this size the framework will try deleting local caches that are not being used.\n\n\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-23T08:51:28.000+0000","updated":"2006-08-23T08:51:28.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12430084","id":"12430084","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"The LocalDU class should rather be a method on FileUtils, as should the UnZip utility.\n\nDistributedCache should not be public, nor should the methods you add to TaskTracker.  The only public API for this new feature is the two new JobConf methods, right?\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-08-23T19:38:17.000+0000","updated":"2006-08-23T19:38:17.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12430288","id":"12430288","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"You are right Doug. The only public api's should be the jobconf methods. I will incorporate your changes and resubmit the patch. Thanks for your comments.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-24T17:05:29.000+0000","updated":"2006-08-24T17:05:29.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12430328","id":"12430328","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"Incorporated doug's suggestions in this new patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-08-24T21:06:14.000+0000","updated":"2006-08-24T21:06:14.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12431689","id":"12431689","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"body":"Jira ate my comments again. Since I didn't realize it for a day, I'll try to reconstruct them.\n\nThey were mostly nits:\n\n1. You add 3 new mini-cluster bring up/tear down cycles in the junit tests. It would be faster to use the same cluster with multiple jobs.\n2. The fields in DistributedCache should be private instead of package local.\n3. The same for the string constants in TaskTracker.\n4. TaskTracker.getCacheSubdir and getJobCacheSubdir should return Path's and be package local. \n5. getJobCacheSubdir should have a String jobId as a parameter and the result should be customized for that job. Furthermore, the result should be pushed through getLocalPath so that they are spread between the local dirs. Therefore, it should be given the server's conf also.\n6. runningJobs should be declared as \"Map runningJobs;\" instead of TreeMap. You might also consider using \"Map<String, RunningJob> runningJobs;\"\n7. appendString should probably be promoted into StringUtils as join(String[], String).\n8. the catch after the calls to launchTaskForJob should probably be rolled into the body of the method rather  than repeated.\n9. MapTask.java just has space changes.\n10. justPaths is public and probably should be package local (and get some java doc). \n11 getCacheArchives is kind of confusing as a name since it gets both archives and files. It should also probably not be public.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-08-30T21:04:55.000+0000","updated":"2006-08-30T21:04:55.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12432038","id":"12432038","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"incorporated most of owen's comments, except that of merging all my junit tests into other junit tests. I merged my local/minimr junit test into TestMiniMRLocalFS.  I tried including my caching junit test with DFS and MiniMR in TestMiniMRWIthDFS but that made it longer htan 3 mins. It currently takes arnd 140 seconds. So I have a seperate junit test for DFS and MiniMR.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-01T03:33:39.000+0000","updated":"2006-09-01T03:33:39.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12432634","id":"12432634","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"The indentation of this patch is non-standard.  Please use 2 spaces per indent level, no tabs.\n\nShould the JobConf setters be adders?  For example, should setCacheFiles(String) instead be named addCacheFile(Path)?  Also, should we use paths instead of strings?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-09-05T17:16:51.000+0000","updated":"2006-09-05T17:16:51.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12432660","id":"12432660","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"indented the patch to make it 2 spaces.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-05T19:38:57.000+0000","updated":"2006-09-05T19:38:57.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12432685","id":"12432685","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"about setcacheFiles(), we could add a addcacheFIles though I have not done it in the patch. Also, we are using URI's (dfs://hostname:port/path) so I dont think we should be using paths instead of strings.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-05T22:21:09.000+0000","updated":"2006-09-05T22:21:09.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12432963","id":"12432963","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"If we are using URIs then shouldn't the parameters be java.net.URI?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-09-06T20:55:15.000+0000","updated":"2006-09-06T20:55:15.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12432993","id":"12432993","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"sorry to have caused confusion. The files are specified as dfs://hostname:port/pathtofile. These are later converted to URI's by the framework to get the dfs and absolute paths. This is all similar to distcp where the input and outfiles can be specified as dfs://......","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-06T23:12:20.000+0000","updated":"2006-09-06T23:12:20.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12433206","id":"12433206","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"The documentation of the primary user API should fully describe the format of the parameters, e.g., that these are strings representing URIs.  This would be simpler if the API used a type other than String.\n\nWe need an addCacheFile() method before we need a setCacheFiles() method, not the other way around.\n\nI'd like to see this as independent of the mapred core as is possible, in order to support things like HADOOP-452.  In particular, the DistributedCache class should probably move to a separate package (filecache)?, and as much of the functionality as is possible should be put in that package.  The TaskTracker and JobTracker should become clients of this facility.\n\nUtilities to store a set of files to cache in a Configuration should arguably move to the new package as well.  There's a temptation to overload JobConf that we need to resist.  So I'd rather see these as static methods like DistributedCache.addFile(Configuration, URI).\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-09-07T19:30:38.000+0000","updated":"2006-09-07T19:30:38.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12433450","id":"12433450","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"\nok, this is what I plan to do. Doug, please comment if you are ok with this -- \n\n1) DistributedCache class will be seperate package - org.apache.hadoop.filecache;\n\n2) To make it idependent of mapreduce -- \nDistributedCache will have methods -- \nPath localizeCacheArchives(URI of archive to localize, conf)\n-- this will return the Path of the localized archive directory\nPath localizeCacheFiles(URI of file to localize, conf)\n-- this will return the Path of the localized file\n\nThe difference between these two methods being that localizeCacheArchives automatically unarchives a zip/jar file while localizeCacheFiles just copies the file locally.\n\n3) DistributedCache maintains a list of localized files/caches so as to copy only once.\n\n4) The TaskRunner is client of DistributedCache asking to cache files locally.\n\n5) JobConf does not have any api's related to setCache/addCache. These will be seperate static methods in DistributedCache to setCaches/files in jobconf. The getCaches can also be impelmented as a static method in DistributedCache.\n\nComments?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-08T17:31:53.000+0000","updated":"2006-09-08T17:31:53.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12433459","id":"12433459","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"+1  That sounds great!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-09-08T17:45:20.000+0000","updated":"2006-09-08T17:45:20.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12434545","id":"12434545","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"body":"Made the suggested changes by doug. I moved all the public methods in jobconf for caching into DistributedCache. Mapreduce is now a client of DistributedCache class. Also, the public api now uses URI to addcachefiles/archives. DistributedCache is seperate package.\n\nSo the api now looks like \nDistrbutedCache.addCacheArchives(uri, jobconf)\n\nand to get the localized Paths \nDistibutedCache.getLocalArchives(Configuration conf) gives an array of  localized path directory of cache archives in the order they were added.  \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mahadev","name":"mahadev","key":"mahadev","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mahadev konar","active":true,"timeZone":"Etc/UTC"},"created":"2006-09-13T21:18:27.000+0000","updated":"2006-09-13T21:18:27.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12344101/comment/12434829","id":"12434829","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"I just committed this.  Thanks, Mahadev!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-09-14T22:11:37.000+0000","updated":"2006-09-14T22:11:37.000+0000"}],"maxResults":21,"total":21,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-288/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0ipbz:"}}