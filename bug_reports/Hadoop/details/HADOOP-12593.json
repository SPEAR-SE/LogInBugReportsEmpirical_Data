{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12915776","self":"https://issues.apache.org/jira/rest/api/2/issue/12915776","key":"HADOOP-12593","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310240","id":"12310240","key":"HADOOP","name":"Hadoop Common","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310240&avatarId=10095","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310240&avatarId=10095","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310240&avatarId=10095","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310240&avatarId=10095"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2015-11-24T17:04:19.308+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Tue Dec 01 16:47:59 UTC 2015","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-12593/watchers","watchCount":8,"isWatching":false},"created":"2015-11-24T12:17:48.872+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/4","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/minor.svg","name":"Minor","id":"4"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12329058","id":"12329058","description":"2.8.0 release","name":"2.8.0","archived":false,"released":true,"releaseDate":"2017-03-22"}],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2015-12-01T16:47:59.486+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":"If you get your IDE to scan for \"volatile long\", you find 20-30 entries. Volatile operations on `long` variables are not guaranteed to be atomic, so these usages can be vulnerable to race conditions generating invalid data.\n\nthey need to be replaced by AtomicLong references, except in the specific case that you want performance values for statistics, and are prepared to take the risk","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"multiple \"volatile long\" field declarations exist in the Hadoop codebase","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15024861","id":"15024861","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"body":"Writes and reads of volatile longs or doubles are very much atomic: http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"created":"2015-11-24T17:04:19.308+0000","updated":"2015-11-24T17:04:19.308+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15024937","id":"15024937","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"body":"really? I guess I was mistaken. Even so, what isn't atomic is any addition ++, +=, etc. The code has to be reviewed to make sure that isn't happening at least","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"created":"2015-11-24T17:41:57.890+0000","updated":"2015-11-24T17:41:57.890+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15024979","id":"15024979","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"body":"Non-volatile assignments of longs and doubles *may* lead to seeing half-writes (i.e. completely different value) unlike ints (where you see either the old value or the new value but never any other value). But volatile longs and doubles are always atomic per Java Memory Model.\n\nI agree that volatiles and compound operators (++, +=, etc.) don't mix as volatiles are for giving you visibility for single assignments. That is true for any types (int, long, double, short, etc.).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"created":"2015-11-24T17:55:58.669+0000","updated":"2015-11-24T17:55:58.669+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15030725","id":"15030725","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gliptak","name":"gliptak","key":"gliptak","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gliptak&avatarId=25518","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gliptak&avatarId=25518","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gliptak&avatarId=25518","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gliptak&avatarId=25518"},"displayName":"Gabor Liptak","active":true,"timeZone":"America/New_York"},"body":"In https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java:\n\n{code:Java}\n     * There is only a single writer to thread-local StatisticsData objects.\n     * Hence, volatile is adequate here-- we do not need AtomicLong or similar\n     * to prevent lost updates.\n     * The Java specification guarantees that updates to volatile longs will\n     * be perceived as atomic with respect to other threads, which is all we\n     * need.\n\n      volatile long bytesRead;\n      volatile long bytesWritten;\n\n      this.bytesRead += other.bytesRead;\n      this.bytesWritten += other.bytesWritten;\n{code}\n\nCould this above cause a race condition?\n\nPS ZK also worked these with https://issues.apache.org/jira/browse/ZOOKEEPER-1972","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gliptak","name":"gliptak","key":"gliptak","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gliptak&avatarId=25518","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gliptak&avatarId=25518","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gliptak&avatarId=25518","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gliptak&avatarId=25518"},"displayName":"Gabor Liptak","active":true,"timeZone":"America/New_York"},"created":"2015-11-29T01:16:29.368+0000","updated":"2015-11-29T01:16:29.368+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15032331","id":"15032331","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"body":"I don't think that's a real issue. The key assumption here is that there is only a single writer thread (these are basically thread-local data structures). With volatile declarations and a single writer thread, even if a reader comes in during the \"+=\" operation it's not going to be a problem.\n\nI'd be the first to admit that the way it is written is not very clear or intentional, but t appears correct. The only exception to the single-writer rule is Statistics.rootData. However, that is also currently protected by the Statistics instance lock. Again, that could be made more explicit (e.g. sometimes synchronization is done in a couple of layers above in the call chain).\n\nHope this helps.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"created":"2015-11-30T19:48:50.235+0000","updated":"2015-11-30T19:48:50.235+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15032618","id":"15032618","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cmccabe","name":"cmccabe","key":"cmccabe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cmccabe&avatarId=29060","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cmccabe&avatarId=29060","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cmccabe&avatarId=29060","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cmccabe&avatarId=29060"},"displayName":"Colin P. McCabe","active":true,"timeZone":"America/Los_Angeles"},"body":"[~gliptak], as the comment you pasted states, \"there is only a single writer to thread-local StatisticsData objects.\"  A single writer cannot race with itself, as [~sjlee0] commented.\n\n[~sjlee0] wrote:\nbq. I'd be the first to admit that the way it is written is not very clear or intentional, but t appears correct. The only exception to the single-writer rule is Statistics.rootData. However, that is also currently protected by the Statistics instance lock. Again, that could be made more explicit (e.g. sometimes synchronization is done in a couple of layers above in the call chain).\n\nHmm.  The declaration of {{rootData}} has a comment saying that it is protected by the Statistics lock.  There's also a comment near {{reset}} talking about the locking, commenting that \"Both reads and writes to rootData are done under the lock, so we're free to modify rootData from any thread that holds the lock\".  Are other places we could add comments to make it clearer?  To be honest, I think the locking here is better documented than most places in our code base.\n\nI did a quick scan of our uses of {{volatile long}}, and the only place I can find that might be a problem is here:\n{{hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/NNThroughputBenchmark.java}} might have a \"lost update\" here:\n{code}\n    void benchmarkOne() throws IOException {\n      for(int idx = 0; idx < opsPerThread; idx++) {\n        if((localNumOpsExecuted+1) % statsOp.ugcRefreshCount == 0)\n          refreshUserMappingsProto.refreshUserToGroupsMappings();\n        long stat = statsOp.executeOp(daemonId, idx, arg1);\n        localNumOpsExecuted++;\n        localCumulativeTime += stat;  <=== should be using AtomicLong\n      }\n    }\n{code}\n\n{{localCumulativeTime}} should be an AtomicLong to prevent lost updates.\n\nPerhaps we should change this JIRA to be about fixing this issue.  Or maybe we should close this and file the {{localCumulativeTime}} issue as a follow-on, to make it less confusing.  [~steve_l], what do you think?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cmccabe","name":"cmccabe","key":"cmccabe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cmccabe&avatarId=29060","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cmccabe&avatarId=29060","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cmccabe&avatarId=29060","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cmccabe&avatarId=29060"},"displayName":"Colin P. McCabe","active":true,"timeZone":"America/Los_Angeles"},"created":"2015-11-30T22:31:38.039+0000","updated":"2015-11-30T22:31:38.039+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15032651","id":"15032651","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"body":"{quote}\nHmm. The declaration of rootData has a comment saying that it is protected by the Statistics lock. There's also a comment near reset talking about the locking, commenting that \"Both reads and writes to rootData are done under the lock, so we're free to modify rootData from any thread that holds the lock\". Are other places we could add comments to make it clearer? To be honest, I think the locking here is better documented than most places in our code base.\n{quote}\n\nI totally agree that it is better documented than other places in our code base (and the code is correct). It is about a couple of places we can touch up to make it crystal clear. The only minor nits I had were\n- the single-writer assumption has one exception, which is Statistics.rootData: this could have been documented in StatisticsData so that one can connect the dots between the single-writer assumption and rootData quickly\n- The access to rootData in Statistics.reset() is safe because visitAll() is synchronized, but it may be easy to miss (I did when I went over it quickly). As you mentioned, there is the javadoc comment there mentioning the lock, but a quick mention to visitAll() would have been even better.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"created":"2015-11-30T22:50:46.056+0000","updated":"2015-11-30T22:50:46.056+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15033446","id":"15033446","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"body":"I knew some were tagged, and others not. I think my main concern was whether writes to a 64 bit value were atomic at all —but roman corrected me there. Which leaves the issue of: are there any operations which cause problems, with ++, += and the equivalents being it.\n\nI think we should just review them, and for all that we deem safe, add that in big comments.\n\nLife would be easier if java had an {{atomic}} type alongside {{volatile}}, atomic add/subtract operations are only a couple of cycles on a modern part, plus the same impact on OoO scheduling that volatile r/w ops have.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"created":"2015-12-01T09:59:44.060+0000","updated":"2015-12-01T09:59:44.060+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12915776/comment/15034044","id":"15034044","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"body":"+1 on what [~stevel@apache.org] suggested. How about using this to review all unsafe uses of volatiles, mainly in the context of using compound operations (++, +=, etc.)? [~cmccabe] already flagged one. Volatile int/short/byte/double/float are no different in this regard, so they should be reviewed too.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sjlee0","name":"sjlee0","key":"sjlee0","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=sjlee0&avatarId=16831","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=sjlee0&avatarId=16831","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=sjlee0&avatarId=16831","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=sjlee0&avatarId=16831"},"displayName":"Sangjin Lee","active":true,"timeZone":"America/Los_Angeles"},"created":"2015-12-01T16:47:59.486+0000","updated":"2015-12-01T16:47:59.486+0000"}],"maxResults":9,"total":9,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-12593/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i2ov3j:"}}