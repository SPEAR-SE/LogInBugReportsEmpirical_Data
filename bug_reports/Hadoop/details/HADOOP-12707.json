{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12930029","self":"https://issues.apache.org/jira/rest/api/2/issue/12930029","key":"HADOOP-12707","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310240","id":"12310240","key":"HADOOP","name":"Hadoop Common","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310240&avatarId=10095","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310240&avatarId=10095","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310240&avatarId=10095","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310240&avatarId=10095"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/2","id":"2","description":"The problem described is an issue which will never be fixed.","name":"Won't Fix"},"customfield_12312322":null,"customfield_12310220":"2016-01-14T06:27:43.819+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Jun 04 17:21:06 UTC 2018","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":"1_*:*_1_*:*_12982977_*|*_5_*:*_1_*:*_0","customfield_12312321":null,"resolutiondate":"2016-01-14T06:27:43.777+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-12707/watchers","watchCount":6,"isWatching":false},"created":"2016-01-14T02:51:20.857+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12331977","id":"12331977","description":"2.7.1 release","name":"2.7.1","archived":false,"released":true,"releaseDate":"2015-07-06"}],"issuelinks":[{"id":"12490798","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12490798","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"13033542","key":"HADOOP-13971","self":"https://issues.apache.org/jira/rest/api/2/issue/13033542","fields":{"summary":"Fix memory leak in FileSystem.Cache.Key class","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2018-06-04T17:21:06.828+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12310689","id":"12310689","name":"fs","description":"Generic FileSystem code"}],"timeoriginalestimate":null,"description":"FileSystem.get(conf) method,By default it will get the fs object from CACHE,But the key of the CACHE  constains ugi.hashCode, which uses the default hascode method of subject instead of the hascode method overwritten by subject.\n   @Override\n      public int hashCode() {\n        return (scheme + authority).hashCode() + ugi.hashCode() + (int)unique;\n      }\nIn this case, even if same user, if the calll FileSystem.get(conf) twice, two different key will be created. In long duartion, this will lead to memory leak.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"key of FileSystem inner class Cache contains UGI.hascode which uses the default hascode method, leading to the memory leak with Proxy Users","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15097507","id":"15097507","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"body":"My suggested solutionis for UserGroupInformation, the hashCode method should be\n  public int hashCode() {\n    return subject.hashCode();\n  }\ninstead of \n  public int hashCode() {\n    return System.identityHashCode(subject);\n  }","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"created":"2016-01-14T03:04:57.959+0000","updated":"2016-01-14T03:04:57.959+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15097698","id":"15097698","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cnauroth","name":"cnauroth","key":"cnauroth","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cnauroth&avatarId=11432","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cnauroth&avatarId=11432","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cnauroth&avatarId=11432","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cnauroth&avatarId=11432"},"displayName":"Chris Nauroth","active":true,"timeZone":"America/Los_Angeles"},"body":"Hello, [~haitao-tony].  Thank you for filing the issue, but the current implementation of {{UserGroupInformation#hashCode}} and {{UserGroupInformation#equals}} is by design.  Please see issue HADOOP-6670 if you're interested in more background.\n\nI have 2 suggestions to offer for the memory leak problem that you noticed:\n# Consider using the {{FileSystem#closeAllForUGI}} method, which would close all cached instances for a user.\n# If it's not possible to change code, then consider disabling the cache by setting configuration property {{fs.hdfs.impl.disable.cache}} to {{true}} in core-site.xml.  This would bypass the cache completely, which might be appropriate depending on your application.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cnauroth","name":"cnauroth","key":"cnauroth","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cnauroth&avatarId=11432","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cnauroth&avatarId=11432","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cnauroth&avatarId=11432","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cnauroth&avatarId=11432"},"displayName":"Chris Nauroth","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-01-14T06:27:43.819+0000","updated":"2016-01-14T06:27:43.819+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15097705","id":"15097705","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"body":"Hi Chris Nauroth,Many thanks for your reply, this two option can solve the problem.\nFor the current design, even if the same user ,if the user calls this method twice then the filesystem ojbect will be created twice.\nThe CACHE can't have any effect except buffers a lot of unreferenced filesystem object.\nIsn't there any plan to fix this?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"created":"2016-01-14T06:35:38.943+0000","updated":"2016-01-14T06:35:38.943+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15097706","id":"15097706","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"body":"Hi Chris Nauroth,Many thanks for your reply, this two option can solve the problem.\nFor the current design, even if the same user ,if the user calls this method twice then the filesystem ojbect will be created twice.\nThe CACHE can't have any effect except buffers a lot of unreferenced filesystem object.\nIsn't there any plan to fix this?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=haitao-tony","name":"haitao-tony","key":"haitao-tony","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"sunhaitao","active":true,"timeZone":"Etc/UTC"},"created":"2016-01-14T06:35:45.501+0000","updated":"2016-01-14T06:35:45.501+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15098366","id":"15098366","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cnauroth","name":"cnauroth","key":"cnauroth","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cnauroth&avatarId=11432","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cnauroth&avatarId=11432","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cnauroth&avatarId=11432","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cnauroth&avatarId=11432"},"displayName":"Chris Nauroth","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. For the current design, even if the same user ,if the user calls this method twice then the filesystem ojbect will be created twice.\n\nJust a small clarification: it happens only if those 2 calls use different {{UserGroupInformation}} instances that really represent the same \"logical\" underlying user ({{Subject}}).  This is a much less common usage pattern compared to usage of a single {{UserGroupInformation}} instance that always represents that \"logical\" user.\n\nThere are no plans to change this behavior at this time.  The standard solution is to do one of the two things I described in my last comment: disable the cache in configuration or use {{FileSystem#closeAllForUGI}}.\n\nThere is a lot of legacy behind the current behavior of the {{FileSystem}} cache.  Some of it is described in HADOOP-6670, and some of it is described in other old JIRAs.  I wish we could make some big changes there, but a lot of applications are coded to expect the current behavior.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cnauroth","name":"cnauroth","key":"cnauroth","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cnauroth&avatarId=11432","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cnauroth&avatarId=11432","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cnauroth&avatarId=11432","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cnauroth&avatarId=11432"},"displayName":"Chris Nauroth","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-01-14T16:49:11.598+0000","updated":"2016-01-14T16:49:11.598+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15098415","id":"15098415","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"body":"...we could consider using weak references, or at least having some idleness","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"created":"2016-01-14T17:06:50.991+0000","updated":"2016-01-14T17:06:50.991+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/15098508","id":"15098508","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cnauroth","name":"cnauroth","key":"cnauroth","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cnauroth&avatarId=11432","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cnauroth&avatarId=11432","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cnauroth&avatarId=11432","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cnauroth&avatarId=11432"},"displayName":"Chris Nauroth","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. ...we could consider using weak references, or at least having some idleness\n\nI thought about weak references at one point but abandoned it for a few reasons:\n\n# Weak references would provide different semantics compared to the current cache implementation.  Right now, applications can get a {{FileSystem}}, use it, abandon it for a long time (no longer holding a reference to it), and then come back and still find that instance sitting in the cache.  With weak references, there would be a race condition if a GC swept away the instance before the application came back to claim it again.  This could change performance and load patterns in negative ways if clients need to reconnect sockets.  Whether or not it would really be problematic in practice is unclear, but there is a ton of ecosystem and application code that would need testing.  Any such testing would be difficult and perhaps unconvincing, because it would be dependent on external factors like heap configuration, and ultimately, the timing of GC is non-deterministic anyway.\n# The cache goes beyond just resource management and is actually coupled to some logic that implements the API contract.  Delete-on-exit becomes problematic.  With weak references, I suppose we'd have to trigger the deletes from {{finalize}}.  I've experienced a lot of bugs in other codebases that rely on a finalizer to do significant work, so I have an immediate aversion to this.  I also worry about tricky interactions with the {{ClientFinalizer}} shutdown hook.  I guess an alternative could be to somehow \"resurrect\" a reaped instance that still has pending delete-on-exit work, but I expect this would be complex.\n# Even assuming we do a correct bug-free implementation of delete-on-exit from a finalizer, it still changes the semantics.  The deletions are triggered from the {{close}} method.  Many applications don't bother calling {{close}} at all.  In that case, the deletes would happen during the {{ClientFinalizer}} shutdown hook.  Effectively, these applications expect that delete-on-exit means delete-on-process-exit.  They might even be calling {{cancelDeleteOnExit}} to cancel a prior queued delete.  If a weak-referenced instance drops out because of GC, then the deletes would happen at an unexpected time, all of that prior state would be lost, and the application has lost its opportunity to call {{cancelDeleteOnExit}}.\n\nAn idleness policy would have similar challenges.  It's hard to identify idleness correctly within the {{FileSystem}} layer, because current applications expect they can come back to the cache at any arbitrary time and get the same instance again.\n\nEffectively, this cache isn't just a cache.  It's really a set of global variables where clients expect that they can do stateful interactions.  Pitfalls of global variables, blah blah blah...  :-)\n\nI don't like the current implementation, but I also don't see a safe way forward that is backwards-compatible.  If I had my preference, we'd re-implement it with explicit reference counting, require by contract that all callers call {{close}} when finished, and perhaps try to scrap the delete-on-exit feature entirely.  There has been pushback on the reference-counting proposal in the past, but I don't remember the exact JIRA.\n\nMaybe explore backwards-incompatible changes for 3.x?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cnauroth","name":"cnauroth","key":"cnauroth","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=cnauroth&avatarId=11432","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cnauroth&avatarId=11432","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cnauroth&avatarId=11432","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cnauroth&avatarId=11432"},"displayName":"Chris Nauroth","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-01-14T17:52:36.016+0000","updated":"2016-01-14T17:52:36.016+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/16498370","id":"16498370","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=xinlishang","name":"xinlishang","key":"xinlishang","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34044","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"},"displayName":"Xinli Shang","active":true,"timeZone":"Etc/UTC"},"body":"We hit this issue also and it impacts us a lot. Our Hadoop cluster is pretty big and Hadoop security plays a big part of it. So please consider it high priority.\r\n\r\nYes, disabling cache or calling closeAll() would prevent leaking but we lose the benefit of cache. We would like it to be fixed so that we can have a performant service. \r\n\r\nThe use case for us is we have to create proxy user and get FileSystem in doAs(). The code is as below. \r\n\r\nUserGroupInformation ugi = UserGroupInformation.createProxyUser(proxyUser, UserGroupInformation.getCurrentUser());\r\n\r\nfs = ugi.doAs((PrivilegedExceptionAction<FileSystem>) () -> FileSystem.get(conf));\r\n\r\nBecause ugi is different object even for same proxy user, the FileSystem#Cache#Key would be different for same proxy user. \r\n\r\nIt would be great to fix it. HADOOP-6670 does have a valid reason that mutable object but simply using identityHashCode() is a bold decision and impact the usage of it. \r\n\r\n ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=xinlishang","name":"xinlishang","key":"xinlishang","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34044","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"},"displayName":"Xinli Shang","active":true,"timeZone":"Etc/UTC"},"created":"2018-06-01T18:18:12.353+0000","updated":"2018-06-01T18:18:12.353+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12930029/comment/16500549","id":"16500549","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"body":"Added proxy users to the title.\r\n [~cnauroth]: what are your thoughts here?\r\n\r\n[~xinlishang] I think you may want to consider what you could do with  your own cache, as that would isolate your code & you could be clever here. That is; you can cache filesystems outside FileSystem.cache if you really want to","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stevel%40apache.org","name":"stevel@apache.org","key":"stevel@apache.org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stevel%40apache.org&avatarId=16513","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stevel%40apache.org&avatarId=16513","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stevel%40apache.org&avatarId=16513","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stevel%40apache.org&avatarId=16513"},"displayName":"Steve Loughran","active":true,"timeZone":"Europe/London"},"created":"2018-06-04T17:21:06.828+0000","updated":"2018-06-04T17:21:06.828+0000"}],"maxResults":9,"total":9,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-12707/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i2r9zr:"}}