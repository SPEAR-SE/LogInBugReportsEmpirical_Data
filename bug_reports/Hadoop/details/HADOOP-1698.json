{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12375630","self":"https://issues.apache.org/jira/rest/api/2/issue/12375630","key":"HADOOP-1698","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310240","id":"12310240","key":"HADOOP","name":"Hadoop Common","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310240&avatarId=10095","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310240&avatarId=10095","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310240&avatarId=10095","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310240&avatarId=10095"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312474","id":"12312474","description":"","name":"0.14.0","archived":false,"released":true,"releaseDate":"2007-08-20"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2007-08-09T07:07:50.454+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Tue Aug 14 05:31:54 UTC 2007","customfield_12310420":"80959","customfield_12312320":null,"customfield_12310222":"10002_*:*_1_*:*_37617683_*|*_1_*:*_1_*:*_413056403_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_564037832","customfield_12312321":null,"resolutiondate":"2007-08-14T05:31:54.577+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-1698/watchers","watchCount":3,"isWatching":false},"created":"2007-08-09T00:20:40.491+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/1","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/blocker.svg","name":"Blocker","id":"1"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"4.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312579","id":"12312579","description":"","name":"0.13.1","archived":false,"released":true,"releaseDate":"2007-07-26"}],"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2009-07-08T17:06:29.671+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[],"timeoriginalestimate":null,"description":"Steps to Reproduce:\nOn the above cluster run any job with #partitions/reducers = 8000+\nObserve CPU utilization on any mapper.\n\nObservations:\nThe output.collect(Key, Value) call takes a huge amount of CPU, causing the job to hang.\n\nThis is a result of two issues:\n1) Number of partitions beyond 7500 results in a call to sortAndSpillToDisk() on each call to output.collect\n2) Call to sortAndSpillToDisk causes creation of a writer object, eventually calling:\n MessageDigest digester = MessageDigest.getInstance(\"MD5\");\n        digester.update((new UID()+\"@\"+InetAddress.getLocalHost()).getBytes());\n        sync = digester.digest();\nA code-block in  SequenceFile.java(652)\n\n\nIssue #1:\nFurther investigation reveals the following stack trace whenever the task is suspended.\n  [1] java.net.Inet4AddressImpl.lookupAllHostAddr (native method)\n  [2] java.net.InetAddress$1.lookupAllHostAddr (InetAddress.java:849)\n  [3] java.net.InetAddress.getAddressFromNameService (InetAddress.java:1,183)\n  [4] java.net.InetAddress.getLocalHost (InetAddress.java:1,312)\n  [5] org.apache.hadoop.io.SequenceFile$Writer.<init> (SequenceFile.java:653)\n  [6] org.apache.hadoop.io.SequenceFile$Writer.<init> (SequenceFile.java:622)\n  [7] org.apache.hadoop.io.SequenceFile.createWriter (SequenceFile.java:386)\n  [8] org.apache.hadoop.io.SequenceFile.createWriter (SequenceFile.java:412)\n  [9] org.apache.hadoop.mapred.MapTask$MapOutputBuffer.startPartition (MapTask.java:307)\n  [10] org.apache.hadoop.mapred.MapTask$MapOutputBuffer.sortAndSpillToDisk (MapTask.java:387)\n  [11] org.apache.hadoop.mapred.MapTask$MapOutputBuffer.collect (MapTask.java:355)\n/*My code*/\n  [12] mypackage.MyClass$Map.map (MyClass.java:283)\n--------------\n  [13] org.apache.hadoop.mapred.MapRunner.run (MapRunner.java:46)\n  [14] org.apache.hadoop.mapred.MapTask.run (MapTask.java:189)\n  [15] org.apache.hadoop.mapred.TaskTracker$Child.main (TaskTracker.java:1,771)\n\nThe piece of code causing the problem is (MapTask.java:355)\n----------------------------------------------------------\n        long totalMem = 0;\n        for (int i = 0; i < partitions; i++)\n          totalMem += sortImpl[i].getMemoryUtilized();  <---- == 16K (BasicTypeSorterBase.java(88) (startOffsets.length (below)) * BUFFERED_KEY_VAL_OVERHEAD;\n\n        if ((keyValBuffer.getLength() + totalMem) >= maxBufferSize) { <----------------condition is always true if partitions > 7500\n          sortAndSpillToDisk();\n          keyValBuffer.reset();\n          for (int i = 0; i < partitions; i++) {\n            sortImpl[i].close();\n          }\n        }\n----------------------------------------------------------\n\nLooking at the variable values in  org.apache.hadoop.mapred.MapTask$MapOutputBuffer.collect (MapTask.java:355)\n sortImpl[0] = {\n    org.apache.hadoop.mapred.BasicTypeSorterBase.keyValBuffer: instance of org.apache.hadoop.io.DataOutputBuffer(id=1159)\n    org.apache.hadoop.mapred.BasicTypeSorterBase.startOffsets: instance of int[1024] (id=1160) <--1K * 16 (previously explained) == 16K\n    org.apache.hadoop.mapred.BasicTypeSorterBase.keyLengths: instance of int[1024] (id=1161)\n    org.apache.hadoop.mapred.BasicTypeSorterBase.valueLengths: instance of int[1024] (id=1162)\n    org.apache.hadoop.mapred.BasicTypeSorterBase.pointers: instance of int[1024] (id=1163)\n    org.apache.hadoop.mapred.BasicTypeSorterBase.comparator: instance of org.apache.hadoop.io.MD5Hash$Comparator(id=1164)\n    org.apache.hadoop.mapred.BasicTypeSorterBase.count: 0\n    org.apache.hadoop.mapred.BasicTypeSorterBase.BUFFERED_KEY_VAL_OVERHEAD: 16\n    org.apache.hadoop.mapred.BasicTypeSorterBase.reporter: instance of org.apache.hadoop.mapred.Task$2(id=1165)\n}\nComputation\nmaxBufferSize == 120M \ntherotical max #of partitions assuming 0 keyValBuffer.getLength() =120M/16K = 7500 partitions\n\nIssue #2: \ndigester.update((new UID()+\"@\"+InetAddress.getLocalHost()).getBytes());\n  [1] java.net.Inet4AddressImpl.lookupAllHostAddr (native method)\n  [2] java.net.InetAddress$1.lookupAllHostAddr (InetAddress.java:849)\n  [3] java.net.InetAddress.getAddressFromNameService (InetAddress.java:1,183)\nInetAddress.getLocalHost() call does not cache results, this results in a look up to the host file and DNS(???) bumping up the CPU usage even higher (Observed).\n\nThis is a BLOCKER issue and needs immediate attention. \n\nNotes:\n1) Output.collect should not take hit from framework, separate thread to handle spill buffer?\n2) InetAddress.getLocalHost result should be cached in a static variable?\n3) Spilling logic should not involve #of partitions, needs redesign?\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12363715","id":"12363715","filename":"1698.1.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-13T19:40:37.691+0000","size":6348,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12363715/1698.1.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12363714","id":"12363714","filename":"1698.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-13T19:04:27.321+0000","size":6140,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12363714/1698.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12363611","id":"12363611","filename":"1698.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-10T19:57:22.129+0000","size":6191,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12363611/1698.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12363606","id":"12363606","filename":"1698.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-10T18:45:03.789+0000","size":6098,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12363606/1698.patch"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"106079","customfield_12312823":null,"summary":"7500+ reducers/partitions causes job to hang","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=srikantk","name":"srikantk","key":"srikantk","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Srikanth Kakani","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=srikantk","name":"srikantk","key":"srikantk","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Srikanth Kakani","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"Standard hadoop installation, any number of nodes > 10","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12518641","id":"12518641","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=acmurthy","name":"acmurthy","key":"acmurthy","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arun C Murthy","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. 1) Output.collect should not take hit from framework, separate thread to handle spill buffer?\n\nI'm not sure this is very easy to achieve... I'll let Devaraj comment on this one.\n\nbq. 2) InetAddress.getLocalHost result should be cached in a static variable?\n\n+1 \nWe probably do not need to use this at all... some other statistic could be enough e.g. a numerical trackerid?\n\nbq. 3) Spilling logic should not involve #of partitions, needs redesign?\n\nHere the main idea is that each spill (i.e. to each reduce) is sorted individually; since the reducer only merges the sorted spills form each map. However I guess we could limit the no. of partitions we track in memory at a given point? Again, over to Devaraj...\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=acmurthy","name":"acmurthy","key":"acmurthy","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arun C Murthy","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-08-09T07:07:50.454+0000","updated":"2007-08-09T07:07:50.454+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519086","id":"12519086","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"body":"Thanks Srikanth for the so-detailed bug report/analysis. Really awesome!\n\nThe attached patch should address the concerns. Regarding your questions:\n\n1) Output.collect should not take hit from framework, separate thread to handle spill buffer?\nI can't see how this can be done without substantial redesign, and I don't see much gain of doing it this way (if we want to keep memory usage under bounds)\n\n2) InetAddress.getLocalHost result should be cached in a static variable?\nDone. The code is modified to always use 127.0.0.1\n\n3) Spilling logic should not involve #of partitions, needs redesign?\nModified this to take into account the number of key/value in a particular partition. If a particular partition has nothing, then the associated arrays (like startOffset) doesn't contribute anything to the memory used. Also, reduced the initial array sizes from 1K to 5. Shouldn't be a problem on performance. \n\nAlso, the patch models the memory usage better. It takes into account the temp space that the mergesort would take for the temp arrays when the spilling logic executes. The patch also reinitializes the arrays to null upon every spill to reflect the used memory better.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-10T18:45:04.778+0000","updated":"2007-08-10T18:56:03.666+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519093","id":"12519093","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=srikantk","name":"srikantk","key":"srikantk","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Srikanth Kakani","active":true,"timeZone":"Etc/UTC"},"body":"1) Output.collect should not take hit from framework, separate thread to handle spill buffer?\n\nI would think we should have a producer consumer architecture where the consumer should have the logic of spill buffers. I do not believe it is much difficult to go there from here. Agreed that there is a need for a bit more analysis, but the overhead is limited to running another thread, mostly waiting for input. I believe the straight benefit out of this would be to keep problems with the application and problems with the framework would be kept separate, which is a big thing. Frankly I assumed this would be the case until I debugged it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=srikantk","name":"srikantk","key":"srikantk","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Srikanth Kakani","active":true,"timeZone":"Etc/UTC"},"created":"2007-08-10T19:00:06.685+0000","updated":"2007-08-10T19:00:06.685+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519096","id":"12519096","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=acmurthy","name":"acmurthy","key":"acmurthy","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arun C Murthy","active":true,"timeZone":"America/Los_Angeles"},"body":"bq.2) InetAddress.getLocalHost result should be cached in a static variable?\nDone. The code is modified to always use 127.0.0.1\n\n-1\n\nI believe we do a reverse-lookup of the actual IP address of the network interface and use it to generate a statistically strong unique-random number for the *sync marker*, which this patch breaks. \n\nRather than the IP address we could use a timestamp which is further randomized by trackerid or some such mechanism... \n\nEssentially we need a {{UUID}} (http://java.sun.com/j2se/1.5.0/docs/api/java/util/UUID.html); clearly we need to check the performance impact to generate one.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=acmurthy","name":"acmurthy","key":"acmurthy","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arun C Murthy","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-08-10T19:05:12.382+0000","updated":"2007-08-10T19:07:21.471+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519107","id":"12519107","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"body":"This patch addresses Arun's concern about the randomness of the sync bytes. \n\nSrikanth, your comment\nbq. I would think we should have a producer consumer architecture where the consumer should have the logic of spill buffers. I do not believe it is much difficult to go there from here. Agreed that there is a need for a bit more analysis, but the overhead is limited to running another thread, mostly waiting for input. \n\nThe problem here is that the keys/values, that the map method is doing output.collect for, have to be queued up in a queue associated with the consumer thread. And the spilling logic has to consider the sizes of these key/value pairs (imagine large key/value sizes). So we might end up maintaining a separate buffer for these in-flight keys/values. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-10T19:57:22.258+0000","updated":"2007-08-10T19:57:22.258+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519119","id":"12519119","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tahir","name":"tahir","key":"tahir","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tahir Hashmi","active":true,"timeZone":"Etc/UTC"},"body":"Is there any proof of the fact that generating a 128 bit random number makes the sync marker any less prone to collisions? I don't think so. The probability of occurrence of the marker is only proportional to the amount of data in the file and is not influenced by the actual value of the marker.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tahir","name":"tahir","key":"tahir","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tahir Hashmi","active":true,"timeZone":"Etc/UTC"},"created":"2007-08-10T20:59:04.632+0000","updated":"2007-08-10T20:59:04.632+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519488","id":"12519488","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sameerp","name":"sameerp","key":"sameerp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34061","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"},"displayName":"Sameer Paranjpye","active":true,"timeZone":"America/Los_Angeles"},"body":"It is certainly proportional to the size of the marker. The longer the marker the less likely it is that the sequence will occur in real data.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sameerp","name":"sameerp","key":"sameerp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34061","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"},"displayName":"Sameer Paranjpye","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-08-13T18:39:48.390+0000","updated":"2007-08-13T18:39:48.390+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519490","id":"12519490","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tahir","name":"tahir","key":"tahir","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tahir Hashmi","active":true,"timeZone":"Etc/UTC"},"body":"Yeah, that's true. My point was about the fact that changing the value of the marker for every file doesn't make a difference, so we need not generate a UUID per file.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tahir","name":"tahir","key":"tahir","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tahir Hashmi","active":true,"timeZone":"Etc/UTC"},"created":"2007-08-13T18:49:45.170+0000","updated":"2007-08-13T18:49:45.170+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519491","id":"12519491","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"body":"This patch has one change to do with sync bytes generation from the previous patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-13T19:04:27.449+0000","updated":"2007-08-13T19:04:27.449+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519492","id":"12519492","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tahir","name":"tahir","key":"tahir","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tahir Hashmi","active":true,"timeZone":"Etc/UTC"},"body":"Minor nit with the latest patch. SequenceFile.java still has the following comment, which no longer applies:\n   // use hash of uid + host","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tahir","name":"tahir","key":"tahir","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tahir Hashmi","active":true,"timeZone":"Etc/UTC"},"created":"2007-08-13T19:20:50.575+0000","updated":"2007-08-13T19:20:50.575+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519497","id":"12519497","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"body":"Tahir's comment taken care of. Also, reduced the rate of at which the arrays \"grow\" to 1.1 from 1.5 - basically reducing the amount of extra space we allocate for each call to grow. That will keep a check on the unused memory consumption by the auxiliary arrays for small keys/values (where the keyValBuffer is small but the auxiliary arrays take a lot of space).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=devaraj","name":"devaraj","key":"devaraj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Devaraj Das","active":true,"timeZone":"Pacific/Pitcairn"},"created":"2007-08-13T19:40:37.855+0000","updated":"2007-08-13T19:40:37.855+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519515","id":"12519515","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1, build or testing failed\n\n2 attempts failed to build and test the latest attachment http://issues.apache.org/jira/secure/attachment/12363714/1698.patch against trunk revision r565434.\n\nTest results:   http://lucene.zones.apache.org:8080/hudson/job/Hadoop-Patch/546/testReport/\nConsole output: http://lucene.zones.apache.org:8080/hudson/job/Hadoop-Patch/546/console\n\nPlease note that this message is automatically generated and may represent a problem with the automation system and not the patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2007-08-13T20:29:53.729+0000","updated":"2007-08-13T20:29:53.729+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519538","id":"12519538","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"> changing the value of the marker for every file doesn't make a difference, so we need not generate a UUID per file.\n\nThe rationale for generating a new sync marker per file is to make it make it difficult for someone to include a sync marker in their data.  If we used a constant marker then it might exist in compiled code files that might end up stored in a sequence file.  Or perhaps someone might wish to nest a sequence file within a sequence file.  Etc.  So, yes, it doesn't make collisions any less likely in theory, but it might in practice.  Bzip uses a binary rendering of pi as its sync marker.  That seems fragile to me, as does any given constant.  Once you've picked a constant, it's no longer random, it's well known.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-08-13T21:59:27.821+0000","updated":"2007-08-13T21:59:27.821+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519541","id":"12519541","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"body":"The current patch still generates a random number per a file. It just changes the seed of the number to be the current time rather than the hostname. It is not a preset constant.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-08-13T22:11:27.667+0000","updated":"2007-08-13T22:11:27.667+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375630/comment/12519594","id":"12519594","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"body":"I just committed this. Thanks, Devaraj!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=owen.omalley","name":"owen.omalley","key":"owen.omalley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=29697","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=29697","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=29697","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=29697"},"displayName":"Owen O'Malley","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-08-14T05:31:54.556+0000","updated":"2007-08-14T05:31:54.556+0000"}],"maxResults":15,"total":15,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-1698/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0iifb:"}}