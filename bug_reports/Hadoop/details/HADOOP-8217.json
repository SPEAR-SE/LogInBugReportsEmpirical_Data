{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12548199","self":"https://issues.apache.org/jira/rest/api/2/issue/12548199","key":"HADOOP-8217","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310240","id":"12310240","key":"HADOOP","name":"Hadoop Common","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310240&avatarId=10095","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310240&avatarId=10095","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310240&avatarId=10095","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310240&avatarId=10095"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2012-03-28T04:56:51.924+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Sat Mar 31 01:55:31 UTC 2012","customfield_12310420":"233296","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-8217/watchers","watchCount":10,"isWatching":false},"created":"2012-03-26T22:23:03.687+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"1.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12317652","id":"12317652","description":"0.24.0 release","name":"0.24.0","archived":false,"released":false}],"issuelinks":[{"id":"12349755","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12349755","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12547977","key":"HADOOP-8206","self":"https://issues.apache.org/jira/rest/api/2/issue/12547977","fields":{"summary":"Common portion of ZK-based failover controller","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype","name":"New Feature","subtask":false,"avatarId":21141}}}},{"id":"12349756","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12349756","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12545001","key":"HDFS-3042","self":"https://issues.apache.org/jira/rest/api/2/issue/12545001","fields":{"summary":"Automatic failover support for NN HA","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype","name":"New Feature","subtask":false,"avatarId":21141}}}},{"id":"12477913","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12477913","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12998157","key":"HADOOP-13515","self":"https://issues.apache.org/jira/rest/api/2/issue/12998157","fields":{"summary":"Redundant transitionToActive call can cause a NameNode to crash","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/4","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/minor.svg","name":"Minor","id":"4"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2016-08-18T10:23:39.640+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12317908","id":"12317908","name":"auto-failover","description":"Automatic failover"},{"self":"https://issues.apache.org/jira/rest/api/2/component/12316608","id":"12316608","name":"ha","description":"High Availability"}],"timeoriginalestimate":null,"description":"As discussed in HADOOP-8206, the current design for automatic failover has the following race:\n- ZKFC1 gets active lock\n- ZKFC1 is about to send transitionToActive() and machine freezes (eg GC pause + swapping)\n- ZKFC1 loses its ZK lock, ZKFC2 gets ZK lock\n- ZKFC2 calls transitionToStandby on NN1, and transitions NN2 to active\n- ZKFC1 wakes up from pause, calls transitionToActive(), now we have a bad situation\n\nThis is rare, since it requires ZKFC1 to freeze longer than its ZK session timeout, but worth fixing, since the results can be disastrous.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12320350","id":"12320350","description":"Branch for automatic NN failover","name":"Auto Failover (HDFS-3042)","archived":true,"released":false}],"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12520570","id":"12520570","filename":"hadoop-8217-testcase.txt","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-30T05:44:05.559+0000","size":9790,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12520570/hadoop-8217-testcase.txt"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"43719","customfield_12312823":null,"summary":"Edge case split-brain race in ZK-based auto-failover","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13238915","id":"13238915","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"body":"My thinking for the solution is the following:\n- add a parameter to transitionToStandby/transitionToActive which is a {{long logicalTime}}\n- when the ZKFC acquires the lock znode, it makes a note of the zxid (ZK transaction ID)\n- when it then asks the old active to go to standby, or asks its own node to go active, it includes the zxid\n- the NN itself maintains a record of the highest zxid it has heard. If it receives a state transition request with an older zxid, it ignores it.\n\nThis would solve the race as described, since when ZKFC2 calls NN1.transitionToStandby(), it hands NN1 a higher zxid than ZKFC1 saw. So when ZKFC1 then asks it to go active, the request is denied.\n\nThere is still potentially some race involving the NNs restarting quickly and \"forgetting\" the highest zxid. I'm not sure whether the right solution there is to record the info persistently, or to attach a UUID to each NN startup, and use that to make sure we don't target a newer instance of a NN with an RPC that was meant for an earlier one.\n\nOther creative solutions appreciated :)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-26T22:27:53.022+0000","updated":"2012-03-26T22:27:53.022+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13240171","id":"13240171","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sureshms","name":"sureshms","key":"sureshms","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10450","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10450","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10450","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10450"},"displayName":"Suresh Srinivas","active":true,"timeZone":"America/Los_Angeles"},"body":"Todd, I think this has been brought up in other comments as well. I am very uncomfortable with just creating jiras for each scenarios as we think of, instead of capturing it in a design document. I cannot keep up with jiras, that are created and committed in short periods of time. I do not want to comment on jiras asking for time and impede progress. A design document helps here. Perhaps, we should setup a meeting to go over the design, and discuss issues in more detail.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sureshms","name":"sureshms","key":"sureshms","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10450","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10450","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10450","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10450"},"displayName":"Suresh Srinivas","active":true,"timeZone":"America/Los_Angeles"},"created":"2012-03-28T04:56:51.924+0000","updated":"2012-03-28T04:56:51.924+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13240237","id":"13240237","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"body":"Suresh: we've already had a meeting ostensibly for this purpose, I think. There is also a design document posted to HDFS-2185. The document doesn't include every possible scenario, because I don't have infinite foresight. I don't think having meetings or more reviews of the design doc will help that.\n\nFor example, with the original manual-failover project, we had several design meetings as well as a design document posted on HDFS-1623. Looking back at that project, the design document captured the overall idea (like the HDFS-2185 one does here) but did not foresee some of the trickiest issues we dealt with during implementation (for example, how to deal with invalidations with regard to datanode fencing, how to handle safe mode, how to deal with delegation tokens, etc).\n\nIn that project, as we came upon each new scenario to deal with, we opened a JIRA and had a discussion on the design solution for that particular scenario. I don't see why we can't do the same here. Nor do I see why we are likely to be able to foresee all the corner cases a priori here better than we were able to with HDFS-1623.\n\nSo, I am not going to pause work to wait for meetings or more design discussion. If you see problems with the design, please comment on the design doc on HDFS-2185, or on the individual JIRAs which seem to have problems. I'm happy to address them, even after commit (eg I'm currently addressing Bikas's review comments on HADOOP-8212)\n\nSince there seems to be concern that we are moving too fast, I will create an auto-failover branch later tonight to continue working on implementing this design. I'll also create a new auto-failover component on JIRA so it's easier to follow them. If you have concerns about the implementation or the design when it comes time to merge it, please do vote against the merge, voicing whatever objections you might have. And please do comment along the way if you see issues.\n\nThanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-28T06:49:50.754+0000","updated":"2012-03-28T06:49:50.754+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13240960","id":"13240960","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sureshms","name":"sureshms","key":"sureshms","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10450","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10450","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10450","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10450"},"displayName":"Suresh Srinivas","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. we've already had a meeting ostensibly for this purpose, I think. \nThe way I understood the meeting we had was more about the next steps and not design details.\n\nbq. with the original manual-failover project...\nHDFS-1623 was not a manual-failover project. It did talk about automatic failover. It is just that we decided to merge the branch post manual failover. Any way that is orthogonal.\n\nWhile HDFS-1623 did give high level direction, some of the design could have been hashed out in more detail. It would have helped people follow what is happening, instead of having to piece together the design through numerous jiras. Any way that is my opinion. I also heard concerns from folks following that branch, that the development looked chaotic...\n\nbq. So, I am not going to pause work to wait for meetings or more design discussion.\nWell it us up to you. Complex design such as FailoverController could benefit from meeting of folks than doing it in comments over jiras. At least, some of our own internal discussion on this (for example ZK library we did and other design we are doing) greatly benefited from real time discussions.\n\nbq. Since there seems to be concern that we are moving too fast, I will create an auto-failover branch later tonight to continue working on implementing this design.\nThanks for doing that.\n\nbq. HDFS-2185...\nWill review the design and post the comments.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sureshms","name":"sureshms","key":"sureshms","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10450","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10450","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10450","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10450"},"displayName":"Suresh Srinivas","active":true,"timeZone":"America/Los_Angeles"},"created":"2012-03-29T04:41:04.919+0000","updated":"2012-03-29T04:41:04.919+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242084","id":"13242084","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"body":"Here's a test case which produces the issue as described. This builds on top of the test infrastructure introduced in HADOOP-8228. I also introduced a simple fault injector class to make it possible to deterministically introduce this issue (this is similar to the fault injection technique we use in HDFS for checkpointing).\n\nThis patch also copies GenericTestUtils.DelayAnswer from HDFS into Common. We can later do a followup patch on the HDFS side to remove the copy in that project.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-30T05:44:06.578+0000","updated":"2012-03-30T05:44:06.578+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242797","id":"13242797","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eli2","name":"eli2","key":"eli2","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Eli Collins","active":true,"timeZone":"Etc/UTC"},"body":"I think the sequence number approach makes sense. This is effectively two transactions (one to make NN1 active, one to make NN2 active), each with it's own zxid, and each time we execute a new transaction we need to fence previous ones.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eli2","name":"eli2","key":"eli2","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Eli Collins","active":true,"timeZone":"Etc/UTC"},"created":"2012-03-30T21:56:08.993+0000","updated":"2012-03-30T21:56:08.993+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242818","id":"13242818","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=harip","name":"harip","key":"harip","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hari Mankude","active":true,"timeZone":"Etc/UTC"},"body":"Todd, \n\nI don't think zxid will fix the problem. Caveat is that I don't know the exact design that is being implemented here.\n\nConsider the scenario\n\n1. ZKFC1 goes to gc sleep and loses the active lock\n2. NN1 also goes to gc sleep. (NN1 was already active)\n3. ZKFC2 tries to do transitionToStandby() on NN1. RPC times out.\n4. Don't know what happens now in your design\n5. Assuming ZKFC2 continues to make NN2 active.\n6. NN1 wakes up, assumes that it is active.\n7. both NN1 and NN2 are active.\n\nWithout some sort of persistent fencing across all shared resources, it will not work.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=harip","name":"harip","key":"harip","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hari Mankude","active":true,"timeZone":"Etc/UTC"},"created":"2012-03-30T22:35:45.792+0000","updated":"2012-03-30T22:35:45.792+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242838","id":"13242838","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bikassaha","name":"bikassaha","key":"bikassaha","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bikassaha&avatarId=29845","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bikassaha&avatarId=29845","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bikassaha&avatarId=29845","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bikassaha&avatarId=29845"},"displayName":"Bikas Saha","active":true,"timeZone":"America/Los_Angeles"},"body":"bq.ZKFC1 is about to send transitionToActive() and machine freezes (eg GC pause + swapping)\nbq.This would solve the race as described, since when ZKFC2 calls NN1.transitionToStandby(), it hands NN1 a higher zxid than ZKFC1 saw. So when ZKFC1 then asks it to go active, the request is denied.\n\nGiven, the above, how will NN1 receive the zxid from ZKFC2? If it does not then the solution is invalid. Hari's scenario exemplifies this.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bikassaha","name":"bikassaha","key":"bikassaha","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bikassaha&avatarId=29845","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bikassaha&avatarId=29845","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bikassaha&avatarId=29845","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bikassaha&avatarId=29845"},"displayName":"Bikas Saha","active":true,"timeZone":"America/Los_Angeles"},"created":"2012-03-30T23:11:03.608+0000","updated":"2012-03-30T23:11:03.608+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242855","id":"13242855","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"body":"bq. 3. ZKFC2 tries to do transitionToStandby() on NN1. RPC times out.\nbq. 4. Don't know what happens now in your design\n\nAs has been the case in all of the HA work up to and including this point, it initiates the fence method at this point. The fence method has to do persistent fencing of the shared resource (eg. disable access to the SAN or STONITH the node). Please refer to the code in which I think this is fairly clear.\n\nThe solution here is to improve the ability to do failover when \"graceful fencing\" suffices. In many failover cases it's preferable to _not_ have to invoke STONITH or storage fencing, since those mechanisms will often require administrative intervention to un-fence.\n\nbq. Given, the above, how will NN1 receive the zxid from ZKFC2? If it does not then the solution is invalid. Hari's scenario exemplifies this.\n\nAll transitionToActive/transitionToStandby calls would include the zxid. So, the sequence becomes:\n\n\n1. ZKFC1 gets active lock (zxid=1)\n2. ZKFC1 is about to send transitionToActive(1) and machine freezes (eg GC pause + swapping)\n3. ZKFC1 loses its ZK lock, ZKFC2 gets ZK lock (zxid=2)\n4. ZKFC2 calls NN1.transitionToStandby(2) and NN2.transitionToActive(2).\n5. ZKFC1 wakes up from pause, calls NN1.transitionToActive(1). NN1 rejects the request because it previously accepted zxid=2 in step 4 above. \n\nor the failure case:\n4(failure case): if NN1.transitionToStandby() times out or fails, the non-graceful fencing is initiated (same as in existing HA code for the last several months)\n5(failure case with storage fencing): ZKFC1 wakes up from pause, and calls NN1.transitionToActive(1). NN1 tries to access the shared edits storage and fails, because it has been fenced. So, there is no split-brain.\n5(failure case with STONITH): ZKFC1 never wakes up from pause, because its power plug has been pulled. So, there is no split-brain.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-30T23:46:07.833+0000","updated":"2012-03-30T23:46:07.833+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242874","id":"13242874","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bikassaha","name":"bikassaha","key":"bikassaha","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bikassaha&avatarId=29845","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bikassaha&avatarId=29845","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bikassaha&avatarId=29845","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bikassaha&avatarId=29845"},"displayName":"Bikas Saha","active":true,"timeZone":"America/Los_Angeles"},"body":"bq.4(failure case): if NN1.transitionToStandby() times out or fails, the non-graceful fencing is initiated (same as in existing HA code for the last several months)\n\nCan you please point me to the existing HA code for last several months? I thought we have manual HA in which admin does fencing. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bikassaha","name":"bikassaha","key":"bikassaha","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bikassaha&avatarId=29845","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bikassaha&avatarId=29845","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bikassaha&avatarId=29845","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bikassaha&avatarId=29845"},"displayName":"Bikas Saha","active":true,"timeZone":"America/Los_Angeles"},"created":"2012-03-31T00:07:46.273+0000","updated":"2012-03-31T00:07:46.273+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242880","id":"13242880","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"body":"bq. Can you please point me to the existing HA code for last several months? I thought we have manual HA in which admin does fencing.\n\nSee HDFS-2179 (committed last August), which added the fencing code, and HADOOP-7938, which added the fencing behavior to the manual failover controller (committed in January).\n\nThe HA guide ({{hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-site/src/site/apt/HDFSHighAvailability.apt.vm}}) also details the configuration and operation of the fencing:\n{quote}\n  * <<failover>> - initiate a failover between two NameNodes\n\n    This subcommand causes a failover from the first provided NameNode to the\n    second. If the first NameNode is in the Standby state, this command simply\n    transitions the second to the Active state without error. If the first NameNode\n    is in the Active state, an attempt will be made to gracefully transition it to\n    the Standby state. If this fails, the fencing methods (as configured by\n    <<dfs.ha.fencing.methods>>) will be attempted in order until one\n    succeeds. Only after this process will the second NameNode be transitioned to\n    the Active state. If no fencing method succeeds, the second NameNode will not\n    be transitioned to the Active state, and an error will be returned.\n{quote}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-31T00:15:22.974+0000","updated":"2012-03-31T00:15:22.974+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242908","id":"13242908","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bikassaha","name":"bikassaha","key":"bikassaha","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bikassaha&avatarId=29845","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bikassaha&avatarId=29845","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bikassaha&avatarId=29845","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bikassaha&avatarId=29845"},"displayName":"Bikas Saha","active":true,"timeZone":"America/Los_Angeles"},"body":"Ah. The confusion was caused by \nbq. 4(failure case): if NN1.transitionToStandby() times out or fails, the non-graceful fencing is initiated (same as in existing HA code for the last several months)\nIt seemed like non-graceful fencing existed in HA code for several months. You were referring to fencing methods.\n\nI think the piece that was missing from the solution was \nbq. 4(failure case): if NN1.transitionToStandby() times out or fails, the non-graceful fencing is initiated\n\nI think this is what confused me (and perhaps Hari too) into thinking that NN1 would behave badly. On HDFS-2185 I have commented on ZKFC state diagram missing the arcs for transitionToActive/Standby() failing. It looks like ZKFC does takes specific action there. Its just missing from the transition diagram posted on that jira.\n\nIn this case, the problem is happening because FC2 is calling NN1.transitionToStandby() and then FC1 is calling NN1.transitionToActive(). \nI would like to question the value of FC2 calling NN1.transitionToStandby() in general. FC1 on NN1 is supposed to call NN1.transitionToStandby() because thats is FC1's responsibility upon losing the leader lock.\nSecondly, based on the recent work done to add breadcrumbs to the ActiveStandbyElector, FC2 is going to fence NN1 if NN1 has not gracefully given up the lock, which is clearly the case here. So the problem is already solved unless I am mistaken.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bikassaha","name":"bikassaha","key":"bikassaha","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bikassaha&avatarId=29845","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bikassaha&avatarId=29845","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bikassaha&avatarId=29845","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bikassaha&avatarId=29845"},"displayName":"Bikas Saha","active":true,"timeZone":"America/Los_Angeles"},"created":"2012-03-31T01:01:30.257+0000","updated":"2012-03-31T01:01:30.257+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12548199/comment/13242944","id":"13242944","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"body":"bq. I would like to question the value of FC2 calling NN1.transitionToStandby() in general. FC1 on NN1 is supposed to call NN1.transitionToStandby() because thats is FC1's responsibility upon losing the leader lock.\n\nThis doesn't work, since FC1 can take arbitrarily long to notice that it has lost its lock.\n\nbq. Secondly, based on the recent work done to add breadcrumbs to the ActiveStandbyElector, FC2 is going to fence NN1 if NN1 has not gracefully given up the lock, which is clearly the case here. So the problem is already solved unless I am mistaken.\n\nBut the first stage of \"fencing\" is to gracefully ask the NN to go to standby. This is exactly the problem here. If, instead, we always required that we always use an aggressive fencing mechanism (STONITH/NAS fencing), you're right that there would not be a problem. But we can avoid that in many cases -- for example, imagine that the active node loses its connection to the ZK quorum, but still has a connection to the other NN (eg by a crossover cable). In this case it will leave its breadcrumb znode there, but the new active can easily transition it to standby.\n\nHere's another way of looking at this JIRA:\n- the \"aggressive\" fencing mechanisms have the property of being \"persistent\". i.e after fencing, the node cannot become active, even if asked to.\n- the \"graceful\" fencing mechanism (transitionToStandby() RPC) does not currently have the property of being \"persistent\". If another older node asks it to become active after it's been \"gracefully fenced\", it will do so incorrectly.\n- This JIRA makes \"graceful fencing\" persistent, so it can be used correctly.\n\n\nRegarding the ActiveStandbyElector callback for {{becomeStandby}}, I actually think it's redundant. There are two cases in which it could be called:\n- If already standby, it's a no-op\n- If active, then this indicates that the elector lost its znode. Since it lost its znode (rather than quitting the election gracefully), it will leave its breadcrumb behind. Thus, the other node will fence it. So, calling transitionToStandby is redundant with fencing which the other node will have to perform anyway.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tlipcon","name":"tlipcon","key":"tlipcon","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=tlipcon&avatarId=26804","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=tlipcon&avatarId=26804","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=tlipcon&avatarId=26804","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=tlipcon&avatarId=26804"},"displayName":"Todd Lipcon","active":true,"timeZone":"America/Tijuana"},"created":"2012-03-31T01:55:31.152+0000","updated":"2012-03-31T01:55:31.152+0000"}],"maxResults":13,"total":13,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-8217/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i07ukf:"}}