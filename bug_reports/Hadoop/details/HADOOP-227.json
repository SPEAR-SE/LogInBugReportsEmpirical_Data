{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12343183","self":"https://issues.apache.org/jira/rest/api/2/issue/12343183","key":"HADOOP-227","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310240","id":"12310240","key":"HADOOP","name":"Hadoop Common","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310240&avatarId=10095","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310240&avatarId=10095","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310240&avatarId=10095","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310240&avatarId=10095"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312257","id":"12312257","description":"","name":"0.11.0","archived":false,"released":true,"releaseDate":"2007-02-02"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2006-05-26T08:46:11.000+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Fri Jan 26 23:46:42 UTC 2007","customfield_12310420":"80559","customfield_12312320":null,"customfield_12310222":"10002_*:*_1_*:*_258731251_*|*_1_*:*_1_*:*_21662112472_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_617797208","customfield_12312321":null,"resolutiondate":"2007-01-26T23:46:42.723+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-227/watchers","watchCount":2,"isWatching":false},"created":"2006-05-18T06:39:19.000+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"4.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12310813","id":"12310813","description":"","name":"0.2.0","archived":false,"released":true,"releaseDate":"2006-05-05"}],"issuelinks":[{"id":"12314486","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12314486","type":{"id":"12310000","name":"Duplicate","inward":"is duplicated by","outward":"duplicates","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"},"outwardIssue":{"id":"12345216","key":"HADOOP-334","self":"https://issues.apache.org/jira/rest/api/2/issue/12345216","fields":{"summary":"Redesign the dfs namespace datastructures to be copy on write","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype","name":"Improvement","subtask":false,"avatarId":21140}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-06-23T13:55:23.821+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[],"timeoriginalestimate":null,"description":"In current implementation when the name node starts, it reads its image file, then\nthe edits file, and then saves the updated image back into the image file.\nThe image file is never updated after that.\nIn order to provide the system reliability reliability the namespace information should\nbe check pointed periodically, and the edits file should be kept relatively small.\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12346448","id":"12346448","filename":"patch-async-checkpoints-0.9.0","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-05T14:56:21.000+0000","size":33635,"mimeType":"application/octet-stream","content":"https://issues.apache.org/jira/secure/attachment/12346448/patch-async-checkpoints-0.9.0"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12346447","id":"12346447","filename":"patch-async-checkpoints-0.9.0","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-05T14:50:39.000+0000","size":33635,"mimeType":"application/octet-stream","content":"https://issues.apache.org/jira/secure/attachment/12346447/patch-async-checkpoints-0.9.0"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12346440","id":"12346440","filename":"patch-async-checkpoints-0.9.0","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-05T14:11:40.000+0000","size":33423,"mimeType":"application/octet-stream","content":"https://issues.apache.org/jira/secure/attachment/12346440/patch-async-checkpoints-0.9.0"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12349655","id":"12349655","filename":"periodiccheckpoint7.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-26T01:10:07.070+0000","size":76308,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12349655/periodiccheckpoint7.patch"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"107255","customfield_12312823":null,"summary":"Namespace check pointing is not performed until the namenode restarts.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12413332","id":"12413332","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=awootton","name":"awootton","key":"awootton","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"alan wootton","active":true,"timeZone":"Etc/UTC"},"body":"Does anyone have a clever idea of how to take a snapshot of a running, very active, and very large, NameNode? Without things timing out like crazy? We're ok with the idea of just stopping everything once in a while and restarting the namenode. Still.... ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=awootton","name":"awootton","key":"awootton","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"alan wootton","active":true,"timeZone":"Etc/UTC"},"created":"2006-05-26T08:46:11.000+0000","updated":"2006-05-26T08:46:11.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12444717","id":"12444717","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ckunz","name":"ckunz","key":"ckunz","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Christian Kunz","active":true,"timeZone":"Etc/UTC"},"body":"It looks as if this is on a back burner. I would like to raise the issue again, because the edits file can become large very quickly depending on the frequency of file operations. I generate an edits file of more than 2.5Gb every 24 hours. Of course, the namenode server could be restarted periodically (this what I have to do right now), but this is rather interruptive to clients. What about rotating the edits file periodically and resolving the older edits file with the image file in a separate thread? ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ckunz","name":"ckunz","key":"ckunz","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Christian Kunz","active":true,"timeZone":"Etc/UTC"},"created":"2006-10-25T19:13:39.000+0000","updated":"2006-10-25T19:13:39.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12453449","id":"12453449","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"body":"Proposal for Checkpointing the Namesystem State in DFS\n------------------------------------------------------\n\nCurrently, the namesystem state in memory consists of a tree\nwhere the leaf nodes are files and internal nodes are directories.\nThis is serialized onto a disk file once when the namenode starts\nup. During the namenode operation, the state changes are made in\nmemory, but the on-disk copy of the image is not modified. Instead,\na transaction log (called edits log) for the namesystem changes\nis stored on the disk. When the namenode starts up again, it merges\nthe on-disk image and the edits log, and writes out the updated image.\n\nWhile the namenode is in operation, the edits log keeps on growing,\nirrespective of the size of the namesystem. For example, if a single file\nis constantly created and deleted, the namesystem state will be of\nconstant size, however, the edits log will keep on growing.\n\nTherefore it is necessary to periodically checkpoint the current state\nof the namesystem, and to purge the edits log.\n\nImage File Format on Disk\n-------------------------\n\nThe image on the disk consists of a header followed by a list of\npath entries, followed by known datanode entries. The header consists\nof DFS version number, namespace ID, and number of path entries.\nEach path entry corresponds to either a file or a directory. A file entry\ncontains the full path of the file, it's replication factor, number of\nblocks, and a list of block-entries for blocks belonging to that file.\nEach block entry consists of blockID and length of the block.\nA directory entry consists of full path of the directory, replication\nfactor (which, for a directory is always 0), followed by 0. This last\n0 distinguishes between files and directories.\nThe datanodes section of the image begins with number of known datanodes\nfrom the datanode map that the FSNameSystem maintains, followed by\nserialized form of each DatanodeDescriptor in that map.\n\nEdits Log File Format on Disk\n-----------------------------\n\nThe edits log contains a list of namespace transactions. Each transaction\nbegins with a transaction op-code that signifies type of the transaction.\nThere are seven types of transactions, and each type contains different\nproperties associated with it. These types of transactions and their\nassociated properties are listed\nbelow:\n\n1. Add File : Full path of the file, replication factor, list of blocks\n2. Rename : Old path of the file, new path of the file\n3. Delete : Path of the file deleted\n4. Make Directory : Path of the created directory\n5. Set Replication : Path of the file, new replication factor\n6. Add Datanode : datanode descriptor of the node\n7. Remove Datanode : datanode ID of the node\n\nWhen should we Checkpoint ?\n---------------------------\n\nCheckpointing decision could be based on elapsed time (e.g. every hour)\nor based on number of transactions (e.g. every 100,000 changes to the\nnamesystem). Since the later is approximately reflected in the size of\nthe edits log, this decision could also be based on the size of the\nedits log. This is preferred since, the cpu and/or memory requirements\nof checkpointing are determined by the size of the image as well as\nsize of the edits log. Also, this choice ensures that an idle\nnamenode is not checkpointed unnecessarily based on elapsed time.\n\nHow should we Checkpoint ?\n--------------------------\n\nThere are a number of choices here. We describe each choice, and its pros\nand cons below.\n\n1. Lock the entire namespace in the main namenode thread, while we save\nthe entire image on disk.\n\nThis would disable all namenode operations while we are checkpointing\nthe image. That would include processing of heartbeats also, and would\ncause datanodes to consider namenode to be dead, and cause cascading\nDFS crash.\n\n2. While saving an INode (i.e. path), only lock those nodes in the tree\nfrom root to that node.\n\nThis would require extensive changes in the simple locking model used\nin the namenode. Currently all the operations that the namenode\nperforms are fairly inexpensive. Therefore the simple locking model\nthat locks the entire namespace durung the transaction suffices. With\nthe new fine-grained locking model, one would need to acquire multiple\nlocks for each namspace operation, thus incurring additional overhead\nfor normal operations, which is the common case.\n\n3. Lock the entire namespace while we make an in-memory copy of the\nnamespace. Hand the copy over to a checkpointing thread, unlock the\nnamespace.\n\nThis would certainly be faster that option 1, since it does not involve\nwriting the namespace to disk while it is locked. However, it would\nrequire double the amount of virtual memory to hold the namespace\nwhile checkpointing is in progress.\n\n4. Lock the namespace. Rename the edits log. Start a new edits log.\nUnlock the namespace. Fork off a separate process, which loads old image\nand old edits log, and saves new image.\n\nThis method suffers from the same problem of requiring double the virtual\nmemory as does option 3. In addition, the forked process doubles the\nsystem resources such as open files and sockets.\n\n5. Lock the namespace. Rename the edits log. Start a new edits log.\nUnlock the namespace. Start a new thread, which merges old image on disk\nwith old edits log on disk to create a new image.\n\nOne observation that makes this proposal attractive is that the current\nin-memory image of the namesystem can be recreated by merging the old\nimage on the disk with the current edits log. On the face of it, this\nmethod would also suffer from extensive virtual memory requirements,\nhaving to load an entire disk image into memory. However, upon closer\ninspection, merging an on-disk image with on-disk edits log can be\nachieved with very small memory footprint, if we change the way the image\nis stored on disk. These changes and their rationale is explained below.\n\nEach entry in the on-disk image corresponds to a path. The only\nrequirement on the order of these entries for successfully loading\nthe image is that the entries corresponding to directories be before\nthe entries for files within those directories.\n\nIf we store the image where entries are sorted by their 'path' field,\nclearly entries for directories would be earlier than entries for files\nwithin them. With the sorted image, checkpointing process would involve\nin-memory sorting of edit log on the 'path' field, and then merging\nthe path-related ttransaction one path at a time before writing the\nfinal path record on the new disk image.\n\nAlmost all the path-related transactions in the edits log correspond to\na single path. The only exception to this is the 'rename' transaction,\nwhich corresponds to two paths, one old and one new. For files, this\ntransaction could be split into a pair of transactions that corresponds\nto one path each. 'rename old-path new-path' can be split into\n'delete old-path' and 'create new-path' for the sake of transaction\nlogging. Even for directories that are empty, one can do a similar\nsplit. However, for directories that contains files and/or subdirectories\nit becomes complicated, because each file/subdirectory under the\nrenamed directory needs to have a pair of log-entries corresponding\nto a 'delete' and 'create'. This will increase the edits log size\nby a factor proportional to the number of files in the renamed directory.\n\nOne approach to handle the directory rename operation while periodically\ncheckpointing, is to apply the rename operations both on the on-disk\nimage, and on the edits log entries previous to the rename operation.\nAfter renaming, though, the image will need to be sorted again according\nto the path names. This could be very expensive, since the on-disk image\nof a large filesystem (>1PB) could be a few GB.\n\nThe edits log would typically be a few Megabytes at the time of\nperiodic checkpointing, typically much smaller than the image. We take\nadvantage of this size difference, and an observation about the directory\nrename operation, to propose a solution to this problem.\n\nA rename operation \"rename srcPath dstPath\" in the edits log can be\nmoved to the end of the edits log, by applying other rename operations\non the edits log entries timestamped after the rename entry. That is,\n\nrename srcPath dstPath\n\noperation can be removed, and \n\nrename srcPath dstPath\nrename tmpPath srcPath\n\ncan be appended at the end of the edits log, if we apply the following\nrename operations to all edits log entries that occur after the rename\ndirectory operations:\n\nrename srcPath tmpPath\nrename dstPath srcPath\n\nThis way, we can manipulate the edits log, so that all the rename\ndirectory transactions are moved to the end. Then, we remove these\nrename operations into a separate file called the rename-table.\n\nWe change the definition of the on-disk image, so that it consists not\nonly of the sorted list of all paths in the namesystem, but also this\nrename-table. When the namenode starts up, it loads the list of paths\ninto memory to form a filesystem tree, and the applies the rename\noperations from the rename-table, to get the final image.\n\nWith this modification for handling directory-renames, our periodic\ncheckpointing algorithm becomes:\n\nId = On disk image\nRd = Rename table on the disk\nEd = Edits log on the disk\n\n1. Load Ed into memory as a list of edits entries\n2. Scan from the end of the edits log in order to find a directory rename\n   By applying the transformation described above, move these renames\n   towards the end. Do this for all directory renames.\n3. Append these rename operation to Rd.\n4. Sort the remaining edits log in memory.\n5. Merge Id (which is sorted), and sorted Ed, to get a new Id.\n\nThe namenode startup procedure is also modified, to be:\n\n1. Load Id, form a root directory tree.\n2. For each entry in Rd, apply rename operations on the image.\n3. Merge edits log, if exists.\n4. Store back the image as a sorted list of paths.\n5. Delete renames-table, and edits log.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-26T18:24:01.000+0000","updated":"2006-11-26T18:24:01.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12453716","id":"12453716","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"A checkpointing approach you don't seem to evaluate is making it very cheap to clone the in-memory  tree, specifically, by always copying nodes between the root and each edit.  That way one can checkpoint by just grabbing the pointer to the root, and then writing the shadow tree in the background.  No merging required, no complex re-sorting of operations, etc.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-27T21:57:01.000+0000","updated":"2006-11-27T21:57:01.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12453772","id":"12453772","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"body":"Well, the sort-merge approach does not seem performant anyway if the number of renames is large. So, I am adding the copy-on-write (Dhruba's comment on HADOOP-334) to the proposal. This proposal suggests adding a clone member to every node. While checkpointing is in progress, change to a node is instead made to a clone. When periodic checkpointing is finished, the checkpointer resets the clones by making them actual nodes. I will write up a better description and post as RFC soon.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-28T01:30:44.000+0000","updated":"2006-11-28T01:30:44.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12453781","id":"12453781","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"body":"Complex rename relocation stuff could be avoided if we used (unique) files ids to identify files.\nIn this case file name is just an attribute of the file. Renaming does not change the file id.\nFile hierarchy is based on ids rather than file names.\nAnd if we need to sort, we sort by file ids rather than their names.\n\nI like the merging approach. It is simple in general (not in details though) and does not\ninvolve introducing additional structures in the name-node, which will be hard to support,\nespecially if we plan to replace global locking by something more elaborate.\nAnd best of all it can work as a separate component.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-28T02:53:40.000+0000","updated":"2006-11-28T02:53:40.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12454492","id":"12454492","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"body":"Proposal for Copy-On-Write FileSystem Tree For Periodic Checkpointing\n\nWe propose that the hadoop namenode image be checkpointed to disk after\nevery fixed (configurable) number of transactions.\n\nThe checkpointing method we propose:\n\n1. Does not introduce extensive changes in the simple locking model\n   currently used in the namesystem (FSNamesystem).\n2. Does not fork a heavyweight process to perform checkpointing.\n3. Does not lock the entire namesystem during checkpointing.\n4. Does not change the image or transaction log format in any way.\n5. Does not significantly increase garbage collection activity.\n\nThis proposal is based on making the filesystem tree copy-on-write\n*only during checkpointing*. We keep track of the number of outstanding\ntransactions in the main namenode thread. When this number reaches the\nconfigured (dfs.checkpoint.interval) number (say 10 million), the\nnamenode thread that was performing the transaction (in a synchronized\nmethod) performs the following actions:\n\n1. Close the transaction log 'edits.N', where N is the current\n   generation number. (Current fsedits is considered equivalent to\n   'edits.0', and current fsimage is considered to be 'fsimage.0').\n3. Creates a new transaction log 'edits.<N+1>'.\n4. Wakes up a checkpointing thread to dump a new image.\n5. Release namesystem lock.\n\nThis checkpointing thread:\n\n1. Acquires global namesystem lock.\n2. Sets a namenode-global boolean volatile variable\n'checkpointingInProgress' to true.\n3. Releases global lock.\n4. Starts traversing the filesystem tree in breadth-first manner, and\nwriting it to the disk in a file called 'fsimage.<N+1>' and removes\nfsimage.N, and edits.N.\n5. After writing the image, reacquires the global namesystem lock.\n6. Applies the changes on the shadow nodes to actual nodes.\n7. Set checkpointingInProgress to false.\n8. Releases the global namesystem lock.\n9. Sleep waiting for notification to do checkpointing again. \n\nStep 6 operation will become clear, when we describe how the namenode\nserver threads change the namesystem tree *while* checkpointing is in\nprogress.\n\nNamenode server threads always acquire the global namesystem lock\nbefore making any changes to the filesystem tree. Therefore all the\nsteps described below occur in critical-section.\n\n1. Check if checkpointingInProgress is false.\n2. If it is false, perform the requested namesystem changes, exactly as\nthey are performed currently.\n3. If it is true, locate the node of the filesystem tree that needs to\n   be changed.\n  3.1 If its member named 'shadow' of type 'Inode' is non-null,\n      perform the requested changes to that node.\n  3.2 Otherwise, create a new shadow Inode, clone all the fields from\n      original Inode there, assign it to the 'shadow' field of original\n      Inode. And perform the requested changes to the shadow Inode.\n      Append the original node in a list called 'changedNodes'.\n      \nStep 6 of the checkpointing node consists of traversing the\n'changedNodes' list, and replacing the fields of original node, with\nit's shadow node, and resetting the shadow reference to null.\n\nWith this checkpointing scheme, the namenode startup procedure remains\nunchanged, except that now the namenode looks for a valid image.N with\nmaximum N in the dfs.name.dir(s).\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-29T23:47:26.000+0000","updated":"2006-11-29T23:47:26.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12454493","id":"12454493","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"body":"Minor correction:\n\nIn the comment above, instead of\n\nStep 6 of the checkpointing *node* consists of \n\nPlease read:\n\nStep 6 of the checkpointing *thread* consists of \n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-29T23:48:38.000+0000","updated":"2006-11-29T23:48:38.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12454523","id":"12454523","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"body":"The design looks pretty simple and clean.\nI still like the merging approach better. It is stand-alone!\nThere is no need to change anything in the name-node code.\nIt is useful as a maintenance utility for merging edits and images externally.\nDoes not lock name-node.\nAt some point the name-node data structures should be revised substantially\nand this copy-on-write effort will most probably be a wasted effort.\nDoes it make sense to invest more effort in designing a simpler merge algorithm?\n\nIf we still choose to do that:\n- Should we use \"standard name\" for current image and edits files (without .N)?\nMeaning before checkpointing edits is renamed to edits.N and new edits is re-created.\n- Do we need to keep all old images? Looks like just the last one is required.\nThis is periodic checkpointing, not a backup procedure.\n- If the node crashes in the middle of the checkpoint it is left with the old image,\nold edits, and new edits files. Are we going to apply both old and new edits during startup?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-11-30T03:06:47.000+0000","updated":"2006-11-30T03:06:47.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12455497","id":"12455497","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"body":"Merging of fsimage with the edits can be done using O(sqrt( number of files )) memory.\n\nSuppose the number of files in fsimage (sorted by path name) is N.\nI divide fsimage into blocks so that each block has B=sqrt(N) namespace entries.\nThe number of such blocks will be also M=sqrt(N).\nFor each block we store in memory the path name of the first entry of the block, and the block offset.\nI then start reading the edits file. For every operation in edits I read an appropriate block from\nfsimage using the table in-memory, look for the appropriate entry, and perform operation on the \ncorresponding file. Update operations are performed in place, remove just leaves the free space \nin the block. When a new entry needs to be added current block is split into two new blocks each \ncontaining half of the records of the original block, and is stored in the end of the fsimage file.\nThe in-memory table is also updated to reflect new keys and new block offsets.\nThis algorithm needs to keep in memory the table of size M and one block of size B.\nThe total size of memory used is M + B = O(sqrt(N)).\n\nIf we need to tighten the memory requirement then we can divide N into smaller number \nof blocks (reduce M) and read a part of the block each time (reduce B).\nThe price is more disk IOs, which seems acceptable, for the name-node disk usage is not critical.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-12-05T02:22:58.000+0000","updated":"2006-12-05T02:22:58.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12455530","id":"12455530","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"body":"Sounds a lot like a BTree and comes with all of the issues.  Lots of IO and complexity.  Reimplementing that seems like a bad idea.  perhaps you can find a good java BTree, but this seems like a big, heavy piece of code.\n\nWhy do we  need to do this?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eric14","name":"eric14","key":"eric14","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"eric baldeschwieler","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-12-05T07:23:17.000+0000","updated":"2006-12-05T07:23:17.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12455641","id":"12455641","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"body":"Here is a patch on the current Hadoop trunk .\n\nThis patch do automatic checkpoints without locking the filesystem.\n\nWhen it is time to do a checkpoint, edit logs stream are closed and new edit logs are opened, a thread is created that create a fake FSNamesystem that will merge previously written logs into fsimage. At the end, new edit logs are renamed to their old names.\n\nIt  will consume as much memory during the chekpointing as the current running instance of the FSNamesystem.\n\nThe auto checkpointing feature is disabled by default. So applying the patch \"as is\" is almost safe. (It does not break current image and logs format and loading philosophy) \n\nNonetheless, I can understand that you, the Hadoop dev team,  does not want to integrate this huge hacky patch as a part of the hadoop distribution...\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-05T14:11:40.000+0000","updated":"2006-12-05T14:11:40.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12455657","id":"12455657","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"body":"Right patch with a right name for the unit test case","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-05T14:50:39.000+0000","updated":"2006-12-05T14:50:39.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12455658","id":"12455658","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"body":"Ouch ! I'm tired today sorry, here is the right patch !","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-05T14:56:21.000+0000","updated":"2006-12-05T14:56:21.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12455851","id":"12455851","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"body":"Thanks Philippe, this is a refined effort that uses just the existing code to upload the image and merge it with the edits.\nUnfortunately, it doubles the memory consumption during checkpointing, which is what this issue all about imo.\n\n> Sounds a lot like a BTree and comes with all of the issues.\nIt's not a tree, there is no balancing, and I didn't mentioned trees even once.\nThe only issue I can associate with BTrees is splitting the block into 2.\n\n> Why do we need to do this?\nI am advocating to revive Milind's proposal #5 of the initial design.\nOur goal is to minimize memory overhead used for checkpointing and to provide uninterrupted access to the name-node during checkpointing.\nWe are not considering blocking approaches here so far, which makes minimizing memory our main requirement.\n\nThe copy-on-write approach potentially leads to a linear memory increase and requires additional name-node data structures.\nProposal #5 is an attempt to separate checkpointing from the name-node regular operation process.\nIt takes the image file and the edits file and merges them whether the name-node is present or not.\nIt does it with lots of IOs BUT in constant space.\n\nI was trying to come up with a simpler algorithm for the stand-alone checkpointing.\nIt uses more space but does not require external sorting or unintuitive file entry renaming (as #5).\nAnd it can be adapted to use constant space for the price of more ios.\nGiving up IOs imo is the right tradeoff here, since disk is not used by the name-node and as mostly idle during its regular operation.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-12-06T03:16:45.000+0000","updated":"2006-12-06T03:16:45.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12457507","id":"12457507","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"The Backup Namenode Proposal\n--------------------------------------------\nThe idea is to create a backup namenode, download the fsimage and the edits file\nto the backup namenode, merge them into a single image and then upload the newly\ncreated image into the primary namenode.\n\nThis approach has the following advantages:\n    1. No additional memory or CPU requirement for the primary namenode.\n    2. Good scalability, backup namenodes can be plugged into the network\n       on demand.\n    3. Address space separation of primary namenode and backup namenode, thus\n       better fault tolerance.\n\nThe namenode when invoked with the \"-backupmode\" command line option functions as the backup namenode. No additional scripts needed. One can run the backup namenode and the primary namenode on the same physical machine.\n\nThe backup namenode downloads the fsimage and the edits from the primary namenode through a http-get message. The primary namenode rolls the edit file on disk, send starts logging new transactions into the new editlog file. The backup namenode merges the downloaded fsimage and edit into a new image file. It then uploads the new image file to the primary namenode. The primary namenode replaces the old fsimage and the old editlog with the new uploaded fsimage.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2006-12-11T23:15:39.000+0000","updated":"2006-12-11T23:15:39.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12457540","id":"12457540","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=runping","name":"runping","key":"runping","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Runping Qi","active":true,"timeZone":"Etc/UTC"},"body":"I like this proposal. It is simple, clean, reliable.\nWe need a backup namenode anyway for a production deployment.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=runping","name":"runping","key":"runping","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Runping Qi","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-12T01:36:27.000+0000","updated":"2006-12-12T01:36:27.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12457630","id":"12457630","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"body":"I like this proposal too :)\n\nMuch cleaner that my hacky patch !","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=phil%40anyware-tech.com","name":"phil@anyware-tech.com","key":"phil@anyware-tech.com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Philippe Gassmann","active":true,"timeZone":"Etc/UTC"},"created":"2006-12-12T08:50:21.000+0000","updated":"2006-12-12T08:50:21.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12458332","id":"12458332","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"Here is a much detailed writeup on the Backup NameNode proposal. \"Secondary NameNode\" and \"Backup NameNode\" refer to the same node in this writeup. Please review and comment.\n\nConfiguration\n-------------\nThere will be an additional file named \"masters\" in the configuration directory (similar to the \"slaves\" file) that will list the node names where Secondary NameNode should be run. The start-dfs.sh script will start the Secondary-NameNode appropriately.\n\nThe configuration file will have a the following new definitions:\n    * fs.checkpoint.dir      : Location where the Secondary NameNode can download the\n                                        fsImage and edits file.\n    * fs.checkpoint.period   : Time (in seconds) between two checkpoints.\n    * fs.checkpoint.size     : Size (in MB) of edit log that triggers a checkpoint.\n\nThe Secondary NameNode will use \"org.apache.hadoop.dfs.NameNode.Alternate\" property to log its debug and informational messages.\n\nPrimary NameNode\n--------------------------\nThe Primary NameNode will add the following new RPCs to the ClientProtocol:\n\n    * getEditLogSize()\n        This call returns the size of the current edit log file. This call fails\n        if the NameNode is in SafeMode or there are more than one edit log file.\n\n    * rollEditLog()\n        This call closes the current edit log and opens a new edit log file.\n        The names of the edit files are either \"edits\" or \"edits.new\". To keep\n        complexity to a minimum, there will be a max of two edit log\n        files \"edits\" and \"edits.1\".\n        This call returns an error if any of the following conditions occur:\n        - NameNode is in SafeMode\n        - Both \"edits\" and 'edits.new\" are already pre-existing\n\n    * rollFsImage()\n        This call does the following steps (atomically):\n        - removes fsImage\n        - copies fsImage.tmp to fsImage\n        - removes edits\n        - moves edit.new to edits\n        This call fails if any of the files fsImage, fsImage.new or edits\n        does not exist. It also fails if the dfs is in SafeMode.\n\nThe NameNode will have two additional servlets:\n    * putFsImage.class\n        This servlet causes all the incoming data to be stored in a file\n        named fsImage.tmp in the dfs.name.dir directory. If this file already\n        exists, then this call returns error.\n\n    * getFile.class?param=pathname\n        This servlet retrieves the contents of the specified file.\n\nThe Primary NameNode at startup time deletes fsImage.tmp (if it exists). The NameNode loads the fsImage, then loads the edits and then loads edits.1.  Then it writes the merged fsImage, deletes edits and edits.1.\n\n\nSecondary NameNode\n-------------------------------\nThe Secondary NameNode periodically pings the NameNode with the getCurrentEditLogSize() RPC. This call returns the size of the current edit log. The Secondary NameNode initiates a checkpoint if either the size of the edit log exceeds the size specified in the fs.checkpoint.size or if the time since last checkpoint completion has exceeded fs.checkpoint.period.\n\nThe Secondary NameNode issues the rollEditLog() RPC to instruct the Primary NameNode to start logging edits into edits.1.  The Secondary NameNode then uses the getFile servlet to fetch the contents of fsImage and edits. It puts them in the fs.checkpoint.dir and, reads them into memory, merges them and writes it back to fsImage.tmp. The Secondary NameNode than uploads the fsImage.tmp file to the Primary NameNode using the putFsImage servlet.\n\nOnce the above steps are successful, the Secondary NameNode issues the rollFsImage() RPC. A checkpoint is complete when this RPC completes successfully.\n\nIf any of the RPC calls returns an error, the Secondary NameNode discards all processing that it might have done, logs an error message, and waits for the normal trigger to start the next checkpoint.\n\nIssues\n------\n1. The emphasis is on simplicity. For this reason, the NameNode restricts that there can be only two outstanding edits file at any time: edits and edits.1. This ensures that there cannot be more than one Secondary NameNode for a Primary NameNode.\n\n2. The fact that rollFsImage() fails if either edits or edits.1 are non-existent means that the system is protected against spurious checkpoint if the NameNode restarts when the Secondary NameNode was doing a merge. This check can be made more explicit by returning a cookie with the rollEditLog() command and enforcing that rollFsImage() supplies the same cookie. (The Primary NameNode resets the cookie if it restarts).\n\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2006-12-14T01:16:07.000+0000","updated":"2006-12-14T01:16:07.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12458650","id":"12458650","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"body":">    * fs.checkpoint.period : Time (in seconds) between two checkpoints.\nThis is the maximal time between the checkpoints, right?\n\nWe should introduce new NamenodeProtocol for primary to secondary name-node communication.\n\nI'd go in the other direction: the primary node checks the edits log size each time it adds an entry.\nWhen it reaches the checkpoint.size or if the checkpoint was not done longer than checkpoint.period\nthe primary rolls the edits log and sends a command to the secondary node to create a new checkpoint.\n\nI think we should think about supporting multiple secondary nodes at least at the design stage.\nIn that case we will need to further propagate the checkpoints.\nOr do we just write the latest image into hdfs?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-12-15T01:15:08.000+0000","updated":"2006-12-15T01:15:08.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12458679","id":"12458679","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"I agree that we can introduce a new Protocol called the SecondaryNamenodeProcotol. \n\nI would still persist with the proposal that the primary namenode is just a \"slave\" as far as periodic checkpointing is concerned. All the \"intelligence\" of when to create the checkpoint, how to create it, etc.etc remains with the SecondaryNamenode. In the case when we support multiple Secondary namenodes doing their own periodic checkpointing according to their own schedules, the primary Namenode would otherwise have to do lots of schedule management for each of these periodic-checkpointers.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2006-12-15T05:41:30.000+0000","updated":"2006-12-15T05:41:30.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12458886","id":"12458886","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"An addition to the above proposal. There will be an additional parameter named dfs.namenode.secondary.configfile that contains the absolute pathname of the \"masters\" file.\n\nThe namenode will allow SecondaryNamenodeProcotol connections only from nodes listed in the \"masters' file. Also, the webUI can query the namenode to list the identities of the Secondary Namenodes.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2006-12-15T19:04:59.000+0000","updated":"2006-12-15T19:04:59.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12458905","id":"12458905","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"body":"My idea of supporting multiple secondary nodes was that the primary node always deals with ONE secondary node, which in turn\nbecomes the \"primary\" node for next secondary node, and so on. The order of the nodes is defined by how the secondary nodes\nare listed in the config file. That way each name-node need to know and speak to only one secondary, which substantially\nsimplifies the logic. The primary decides when the new check point should be created and initiates the chain of checkpoints.\nI think we want to avoid heartbeat processing from secondary nodes and minimize inter-name-node communication traffic.\n\nI'd prefer to have all configuration in config file rather than configurable paths to other files, containing edditional configuration parameters.\nDon't like the last proposal linking \"masters\" in the config. This will make configration even more complicated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shv","name":"shv","key":"shv","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Konstantin Shvachko","active":true,"timeZone":"America/Los_Angeles"},"created":"2006-12-15T19:49:01.000+0000","updated":"2006-12-15T19:49:01.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12458994","id":"12458994","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"Konstantin proposal is essentially a push model where the primary Namenode drives the scehduling policies of the periodic checkpointing. Also, he mentioned about supporting cascading secondaries.\n\nI am going ahead the pull model: the Namenode is a very passive entity as far as periodic checkpointing is concerned. The scheduling policies are maintained only by the secondary namenode. The secondary namenode polls the primary periodically (say every 5 minutes) to determine the size of the current edit log.\n\nThe secondary would use HTTP-GET method to transfer fsmage and edits. Al alternative that was discussed was to use HDFS itself to transfer the image. However using HDFS has the disadvantage that the secondary would have to poll the primary to determine when the upload to HDFS was complete (HDFS does not have streaming RPC and has a fixed timeout for an RPC).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2006-12-16T05:19:32.000+0000","updated":"2006-12-16T05:19:32.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12460951","id":"12460951","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"First draft of periodic chekpointing code. Code review comments appreciated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2006-12-27T06:30:45.000+0000","updated":"2006-12-27T06:30:45.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12462270","id":"12462270","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"The second draft of the periodic checkpointing code. This includes a unit test case to test checkpointing as part of nightly test run.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-04T18:12:50.139+0000","updated":"2007-01-04T18:12:50.139+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12462313","id":"12462313","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"body":"Comments on Periodic Checkpointing Patch - v2\n----------------------------------------\n\nfs.checkpoint.period should be in seconds, not milliseconds.\nCode still contains debugging printfs. Log messages are not descriptive\nenough.\nTransferFsImage.java has windows-style crlf line-endings.\nTestCheckpoint does not test periodic checkpointing. Instead it does the\nsame thing as TestRestartDFS.\nNewly added methods in namesystem should not be public.\nFSImage.java has several whitespace-only-changes.\nIn FSEditLog.java, getEditLogSize checks to see if all edit logs have the same\nlength. However, this may not be true. If one of the local or remote fs which\nstores edits is full (or has exceeded quotas), the edits log will be of\ndifferent sizes. In that case getEditLogSize should return maximum\namong all edits.\nSecondaryNamenode.java does not use Logging to print errors, instead\nuses System.err.\nprintUsage is called once with an empty string.\nprintUsage prints [report] instead of [-geteditsize].\nIt should be possible to run the checkpointer as a cron job. There is\nno option for the secondaryNamenode to exit after finishing checkpointing.\ndefault masters files is not added. It should contain localhost.\nhadoop-daemons.sh usage contains [--file configfile]. It should be\ncalled [--hosts hostlistfile].\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-04T20:39:31.075+0000","updated":"2007-01-04T20:39:31.075+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12462695","id":"12462695","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"I am trying to come up with the default values for the following configurable parameters:\n\n1.\tThe size of the edit log that can cause the next checkpoint.\n2.\tThe time period from one checkpoint to the other.\n\nThe next periodic checkpoint occurs whenever at least one of the above conditions are met.\n\nAssuming that a transaction takes 200 bytes in the edits log and the rate of 100 transactions per second, the edit log will increase at the rate of about 70MB per hour. Thus I am proposing that the default values for periodic checkpoints be \n1.\tedit log size = 64KB\n2.\ttime = 1hour\n\nComments appreciated.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-06T09:11:31.884+0000","updated":"2007-01-06T09:11:31.884+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12463102","id":"12463102","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sameerp","name":"sameerp","key":"sameerp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34061","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"},"displayName":"Sameer Paranjpye","active":true,"timeZone":"America/Los_Angeles"},"body":"64KB seems aggressive, it only allows about 300 transactions before a checkpoint happens. Checkpointing should be frequent enough that when the namenode restarts it should be able to merge the edits into the namespace in a fairly short period of time (10-15 seconds perhaps?).\n\nIt might be useful to monitor how many edits can be merged into the image in 10 seconds (on a 2Ghz CPU say) and use something around that as the default.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sameerp","name":"sameerp","key":"sameerp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34061","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"},"displayName":"Sameer Paranjpye","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-08T19:05:41.402+0000","updated":"2007-01-08T19:05:41.402+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12463112","id":"12463112","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"Sorry, a typo. My earlier calculations should have resulted in:\n\n1. edit log size = 64MB (not KB)\n2. time = 1 hour","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-08T19:49:58.345+0000","updated":"2007-01-08T19:49:58.345+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12463116","id":"12463116","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"My theory is that a checkpoint time is actually dominated by the time to read and write the image to disk and the time to transfer the the image back and forth between the namenode and the secondary namenode. The actual CPU time needed to do the merge of the edit log with the fsimage may be relatively small.\n\nMy back-of-the-envelope calculation shows that sequential disk IO rates are at best  2GB per minute. Assuming a 2 GB image:\n\n1. NameNode reads image  = 1min\n2. Secondary NameNode stores image = 1 min (maybe in parallel with Step 1)\n3. Secondary NameNode stores new image = 1min\n4. NameNode stores image = 1 min\n\nThus a total of 3 to 4 minutes can be used to do a checkpoint (ignoring network issues).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-08T20:02:33.559+0000","updated":"2007-01-08T20:02:33.559+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12463118","id":"12463118","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"body":"\nIs it possible to eleminate 1. and 2. above? Since secondary holds the new image from the last checkpoint, at the start of checkpoint secondary can exchange a token with the primary to confirm its image is the latest and merge with that image.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-08T20:19:56.599+0000","updated":"2007-01-08T20:19:56.599+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12463133","id":"12463133","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"Yes, it is possible to optimize. But it will not be part of my current implementation.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-08T21:32:27.007+0000","updated":"2007-01-08T21:32:27.007+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12463466","id":"12463466","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"This incorporates most review comments.\n\nThe main changes in this round of changes were in the following areas:\n\n1. Handle error cases when one namedir is bad.\n2. Use the fstime file to locate the latest and greatest edits file and image file \n3. Change the saveFSImage() function to use the code from periodic checkpoint. This reduces code   complexity because two different code paths need not be maintained. \n4. Uses Enums for image file names.\n5. \"format\"ing creates an image and an empty editslog.\n6. The TestCheckpoint simulates various namenode failure cases.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-10T05:50:48.305+0000","updated":"2007-01-10T05:50:48.305+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12464081","id":"12464081","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"body":"\nregd 64MB default size, It need not be tailored so that it takes one hour to reach the limit.. there is already other variable to do checkpoints every one hour.  As Sameer pointed out its size could be determined by how it affects NameNode start up time. Since namenode start time depends more on the image size, edits log size could be larger. A small value could have more burden on NameNodes that are already busy.  In a big deployment, default many not matter at all since it will be manually set.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-12T02:31:41.620+0000","updated":"2007-01-12T02:31:41.620+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12464278","id":"12464278","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"Are you saying that the default editlogsize should be 128MB or so?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-12T17:59:56.895+0000","updated":"2007-01-12T17:59:56.895+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12464301","id":"12464301","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"body":"\nHow much time does it take to merge 512MB? I think as long as time to merge edit.log is in the order of 30-60 sec, that should be fine. That way if a node is lightly loaded it will checkpoint every hour and edit.log would still be much smaller and if it busy, we won't add extra checkpointing load.\n\nAnother thing, to implement 'image file token' to avoid steps 1. and 2. above, we don't need to store any extra state on disk. This would just be a runtime property. Every time primary gets a new image from secondary, it also exchanges a 'token/etag'. If primary restarts, first check point will have steps 1. and 2.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-12T18:54:27.335+0000","updated":"2007-01-12T18:54:27.335+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12464312","id":"12464312","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"The namenode is typically bottlenecked on CPU whereas a new checkpoint-upload is IO bound. A periodic checkpoint acquires the fsnamesystem lock and switches/renames files. The overhead of doing this operation once every 360000 namenode transactions (in our hour) should be minimal. I would like to make 64MB the default editlogsize and once deployed, I will observe a real life cluster and then determine if we need to change the default size.\n\nReagrding the optimization of 'image token': I would defer it till I see measureable difference in performance on a real cluster. My goal is to keep the periodic checkpoint \"as-simple-as-possible\" while achieving the goal of making the \"namenode-restart faster\".","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-12T19:16:41.509+0000","updated":"2007-01-12T19:16:41.509+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12464329","id":"12464329","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"body":"\nYes, the optimization should be/should be done later.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rangadi","name":"rangadi","key":"rangadi","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Raghu Angadi","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-12T20:07:59.829+0000","updated":"2007-01-12T20:07:59.829+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12466600","id":"12466600","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"This has been merged with the latest trunk. Please review.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-23T00:12:58.654+0000","updated":"2007-01-23T00:12:58.654+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12466860","id":"12466860","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"This is the final patch for periodic checkpointing. Review comments from Milind that were incorporated here were:\n\n[Minor] hadoop-config.sh added export command wrongly indented\n\n[Reconsider Design] Why do we prevent periodic checkpointing if the namenode is in safemode ? Periodic checkpointing does not alter namespace, so should be allowed in safemode.\n\n[Minor] Clearly mark ErrorSimulation functions in SecondaryNamenode.java as used only from the testcase, so as to avoid confusion while reading code.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-23T23:53:52.929+0000","updated":"2007-01-23T23:53:52.929+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12466861","id":"12466861","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"Please incorporate periodiccheckpoint6.patch. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-23T23:54:31.420+0000","updated":"2007-01-23T23:54:31.420+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12466870","id":"12466870","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"+1, because http://issues.apache.org/jira/secure/attachment/12349479/periodiccheckpoint6.patch applied and successfully tested against trunk revision r499156.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2007-01-24T00:34:09.663+0000","updated":"2007-01-24T00:34:09.663+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12467098","id":"12467098","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"body":"+1 code reviewed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=milindb","name":"milindb","key":"milindb","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Milind Bhandarkar","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-24T17:45:16.517+0000","updated":"2007-01-24T17:45:16.517+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12467715","id":"12467715","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"body":"bin/slaves.sh caused secondary namenodes to start on all datanodes (only if HADOOP_SLAVES defined in hadoop-env.sh)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dhruba","name":"dhruba","key":"dhruba","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dhruba&avatarId=30636","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dhruba&avatarId=30636","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dhruba&avatarId=30636","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dhruba&avatarId=30636"},"displayName":"dhruba borthakur","active":true,"timeZone":"America/Tijuana"},"created":"2007-01-26T01:10:07.242+0000","updated":"2007-01-26T01:10:07.242+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12467716","id":"12467716","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nidaley","name":"nidaley","key":"nidaley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nigel Daley","active":true,"timeZone":"Etc/UTC"},"body":"+1\n\nI've run sort, smalljobs, nnbench, and dfsio benchmarks with this patch.  All pass.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nidaley","name":"nidaley","key":"nidaley","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nigel Daley","active":true,"timeZone":"Etc/UTC"},"created":"2007-01-26T01:18:45.003+0000","updated":"2007-01-26T01:18:45.003+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12343183/comment/12467964","id":"12467964","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"body":"I just committed this.  Thanks, Dhruba!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=cutting","name":"cutting","key":"cutting","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Doug Cutting","active":true,"timeZone":"America/Los_Angeles"},"created":"2007-01-26T23:46:42.711+0000","updated":"2007-01-26T23:46:42.711+0000"}],"maxResults":47,"total":47,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HADOOP-227/votes","votes":2,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0ipon:"}}