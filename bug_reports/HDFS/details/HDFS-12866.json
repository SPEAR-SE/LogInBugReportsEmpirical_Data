{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13121511","self":"https://issues.apache.org/jira/rest/api/2/issue/13121511","key":"HDFS-12866","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310942","id":"12310942","key":"HDFS","name":"Hadoop HDFS","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310942&avatarId=10094","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310942&avatarId=10094","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310942&avatarId=10094","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310942&avatarId=10094"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2017-11-29T14:15:26.537+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Dec 04 18:36:39 UTC 2017","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HDFS-12866/watchers","watchCount":19,"isWatching":false},"created":"2017-11-29T01:44:32.306+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[],"issuelinks":[{"id":"12521373","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12521373","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"13026783","key":"HDFS-11225","self":"https://issues.apache.org/jira/rest/api/2/issue/13026783","fields":{"summary":"NameNode crashed because deleteSnapshot held FSNamesystem lock too long","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/2","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/critical.svg","name":"Critical","id":"2"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133}}}}],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2017-12-04T18:36:39.212+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12329603","id":"12329603","name":"hdfs"}],"timeoriginalestimate":null,"description":"Currently file/directory deletion happens in two steps (see {{FSNamesystem#delete(String src, boolean recursive, boolean logRetryCache)}}:\r\n\r\n# Do the following under fsn write lock and release the lock afterwards\r\n** 1.1  recursively traverse the target, collect INodes and all blocks to be deleted\r\n** 1.2  delete all INodes\r\n# Delete the blocks to be deleted incrementally, chunk by chunk. That is, in a loop, do:   \r\n** acquire fsn write lock,\r\n** delete chunk of blocks\r\n** release fsn write lock\r\n\r\nBreaking the deletion to two steps is to not hold the fsn write lock for too long thus making NN not responsive. However, even with this, for deleting large directory, or deleting snapshot that has a lot of contents, step 1 itself would takes long time thus still hold the fsn write lock for too long and make NN not responsive.\r\n\r\nA possible solution would be to add one more sub step in step 1, and only hold fsn write lock in sub step 1.1:\r\n\r\n* 1.1. hold the fsn write lock, disconnect the target to be deleted from its parent dir, release the lock\r\n* 1.2 recursively traverse the target, collect INodes and all blocks to be deleted\r\n* 1.3  delete all INodes\r\n\r\nThen do step 2.\r\n\r\nThis means, any operations on any file/dir need to check if its ancestor is deleted (ancestor is disconnected), similar to what's done in FSNamesystem#isFileDeleted method.\r\n\r\nI'm throwing the thought here for further discussion. Welcome comments and inputs.\r\n\r\n\r\n\r\n\r\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"Recursive delete of a large directory or snapshot makes namenode unresponsive","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=yzhangal","name":"yzhangal","key":"yzhangal","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Yongjun Zhang","active":true,"timeZone":"America/Los_Angeles"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=yzhangal","name":"yzhangal","key":"yzhangal","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Yongjun Zhang","active":true,"timeZone":"America/Los_Angeles"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13121511/comment/16270782","id":"16270782","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kihwal","name":"kihwal","key":"kihwal","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kihwal&avatarId=34594","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kihwal&avatarId=34594","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kihwal&avatarId=34594","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kihwal&avatarId=34594"},"displayName":"Kihwal Lee","active":true,"timeZone":"America/Chicago"},"body":"bq. 1.1. hold the fsn write lock, disconnect the target to be deleted from its parent dir, release the lock\r\nMany have thought about doing this. The snapshot makes it very hard.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kihwal","name":"kihwal","key":"kihwal","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kihwal&avatarId=34594","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kihwal&avatarId=34594","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kihwal&avatarId=34594","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kihwal&avatarId=34594"},"displayName":"Kihwal Lee","active":true,"timeZone":"America/Chicago"},"created":"2017-11-29T14:15:26.537+0000","updated":"2017-11-29T14:15:26.537+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13121511/comment/16271296","id":"16271296","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=daryn","name":"daryn","key":"daryn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daryn Sharp","active":true,"timeZone":"America/Chicago"},"body":"I've contemplated this exact approach for a long time and wish I did it eons ago because Kihwal is right, snapshots have made it much harder.\r\n\r\nThere's a high likelihood you will need the lock in step 2.1.  Inode based file operations.  Updating the snapshot diffs probably isn't thread-safe.   Perhaps batched locking like the block deletion might work.  Then you need to consider possible issues like incorrect quota computation if the live copy of the file is moved during the background delete of the snapshot.  Maybe I'm wrong, or maybe there are more tricky cases.\r\n\r\nbq.  any operations on any file/dir need to check if its ancestor is deleted\r\nUnless you have a means to avoid a traverse to root check for each block processed in an IBR/FBR, it's _not even an option_.\r\n\r\nStepping back, I've suggest actually profiling the NN.  Perhaps it's changed, but a major contributor to the slowness in the past was multiple subdir traversals to check permissions, compute quota, look for snapshots, etc that paled in comparison to the actual block collection.  Permission checks have been further degraded when acls are used.  It gets really bad when using an external inode attribute provider.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=daryn","name":"daryn","key":"daryn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daryn Sharp","active":true,"timeZone":"America/Chicago"},"created":"2017-11-29T18:24:09.529+0000","updated":"2017-11-29T18:24:09.529+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13121511/comment/16271732","id":"16271732","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=yzhangal","name":"yzhangal","key":"yzhangal","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Yongjun Zhang","active":true,"timeZone":"America/Los_Angeles"},"body":"Thanks much for the feedback [~kihwal] and [~daryn].\r\n\r\nYes, with snapshot, an INode won't be disconnected when it's in previous snapshot, it will be repaced with INodeRefenrence instead. So we can use a bit in the INode to indicate whether it's \"disconnected\" instead of physical disconnection from the parent.\r\n\r\nIndeed I was thinking traversing to the root to check, like done in {{FSNamesystem#isFileDeleted}}, it cost some time, but we can find if an INode is disconnected, right?\r\n\r\nOptimizing the permission checking etc would help, however, without postponing the deletion work to later, if the tree is large enough, we can still hit this problem.  Quota  computation will still be done, just not done right away. Hopefully that won't cause too much problem?\r\n\r\nSo the main issue of this approach is the cost of traversing to the root to check if any ancestor is disconnected? I wonder how bad it is. In IBR and FBR, can we assume the file exists if the INode is there? The block deletion step (step 2) will get them removed later anyways.\r\n\r\nThanks again.\r\n\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=yzhangal","name":"yzhangal","key":"yzhangal","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Yongjun Zhang","active":true,"timeZone":"America/Los_Angeles"},"created":"2017-11-29T23:03:38.910+0000","updated":"2017-11-29T23:04:07.662+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13121511/comment/16277219","id":"16277219","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=daryn","name":"daryn","key":"daryn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daryn Sharp","active":true,"timeZone":"America/Chicago"},"body":"bq. Indeed I was thinking traversing to the root to check, like done in FSNamesystem#isFileDeleted, it cost some time, but we can find if an INode is disconnected, right?\r\nI thought the parent was nulled for an inodeRef.WithName when deleted explicitly or implicitly as source of move.  The {{FSN#isFileDeleted}} implementation shows otherwise and is shockingly bad: looking up every ancestor child inode in its parent for an equality check.\r\n\r\nbq. So the main issue of this approach is the cost of traversing to the root to check if any ancestor is disconnected? I wonder how bad it is.\r\nActually the main issue is what does a profile reveal?  Let's not make premature optimizations w/o solid analysis.\r\n\r\nAs for the traverse, making that a pervasive check throughout operations is penalizing the common case for what should be a relatively rare case (deletion of super-large directory).  Perhaps every 1-2y a massive directory is removed and stalls the NN for mins.  I want that danger removed but not at the expense of general performance.\r\n\r\nbq. In IBR and FBR, can we assume the file exists if the INode is there?\r\nIt will be if only an ancestor is unlinked.   Don't have time to look, but I have concerns of what happens if a block slated for removal is updated and possibly added to other data structures (corrupt, excess, etc) or worse generates an edit which cannot be replayed.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=daryn","name":"daryn","key":"daryn","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daryn Sharp","active":true,"timeZone":"America/Chicago"},"created":"2017-12-04T18:36:39.212+0000","updated":"2017-12-04T18:36:39.212+0000"}],"maxResults":4,"total":4,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HDFS-12866/votes","votes":1,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i3nbhb:"}}