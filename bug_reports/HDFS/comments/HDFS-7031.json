[Hi, [~rdblue].

I've always understood the contract of {{Path#makeQualified}} to take an unqualified URI (no scheme/authority, possibly absolute or relative path) and join it to the default's scheme and authority to make it qualified, possibly also using working directory to turn a relative path into an absolute path.  In this example, the input is already a qualified URI.  It's unclear to me whether or not the contract is as clearly defined for this case.  The current behavior certainly looks wrong, but I can think of 2 possible "correct" behaviors:
# {{file://some/local/path}} - Your proposed change would do this.  Essentially, I think this is saying don't change the input URI if it's already qualified.
# {{hdfs://nn:8020/some/local/path}} - This is saying that the URI must always be qualified against the specified default, possibly overriding an existing scheme and authority.  Arguably, this is more correct when called in the context of {{FileSystem#makeQualified}}, because the caller has requested the action for a specific {{FileSystem}} instance.

Is there any chance that your application's code upstream of {{Path}} is doing something incorrect?  Perhaps it needs to be passing a {{Path}} without the file scheme.  The {{Path}} class is widely used across the whole ecosystem, and the ambiguity around the contract in this case makes me a bit reluctant to change the behavior., My application doesn't know what the incoming Path will look like, so it uses {{makeQualified}} to fill in the details that may be missing. If there is no scheme/authority, then those should be taken from the default URI (/some/path => hdfs://nn:8020/some/path). If there is only a relative path, then that's filled in from the working directory Path (path => hdfs://nn:8020/path). Because the URI argument is a "default", I think that behavior #1 is implied when the schemes don't match, which fits with my interpretation of the other examples: qualifying a URI doesn't change what the URI already contains, but fills in what's missing from it being fully qualified. Behavior #2 would change the original URI's meaning, not just fill in defaults. That said, I've added a work-around that only passes in the default FS URI if the schemes don't match so my application is no longer affected.

I think your argument that {{FileSystem#makeQualified}} is a better fit for behavior #2 is reasonable, but I don't think there is a reason to change the current behavior, which throws an IllegalArgumentException that the FS is incorrect. That's why I'm using {{Path#makeQualified}}, because it seems to have the behavior I want, to default the values if not specified, in most cases., Thanks for the additional details about your application usage, Ryan.  Another thing I just realized is that {{Path#makeQualified}} is annotated {{LimitedPrivate}} for HDFS and MapReduce only.  That implies that general application code should not call it, and there is no guarantee that the contract will remain consistent across versions.

I'm inclined to resolve this as won't fix.  Do you think that's acceptable?, It's fine with me if you think that's reasonable, although I think the current behavior is unintended. I'll avoid calling it and write my own. Thanks!, Thanks again, Ryan.  I've resolved this as won't fix.  I'm also going to ask for a second opinion from another committer who knows {{Path}} pretty well.  Let's try [~daryn] or [~arpitagarwal].  If either of you review the comments here and disagree with my decision to resolve as won't fix, then please feel free to reopen., Ryan is right that it mixing the default authority with a non-default scheme looks incorrect. However path handling is fragile so unless HDFS/MapReduce is broken I'm also inclined to leave it as it is.]