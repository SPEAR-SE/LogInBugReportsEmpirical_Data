[The following code snippets show a simple way to change FSNamesystem::renameTo in branch-0.23.4. Changes to other methods are similar.

//////////// existent code
  /** Rename src to dst */
  void renameTo(String src, String dst, Options.Rename... options)
      throws IOException, UnresolvedLinkException {
...
    writeLock();
    try {
      renameToInternal(src, dst, options);
      if (auditLog.isInfoEnabled() && isExternalInvocation()) {
        resultingStat = dir.getFileInfo(dst, false); 
      }
    } finally {
      writeUnlock();
    }
...
  }


  private void renameToInternal(String src, String dst,
      Options.Rename... options) throws IOException {
...
    if (isPermissionEnabled) {
      checkParentAccess(src, FsAction.WRITE);
      checkAncestorAccess(dst, FsAction.WRITE);
    }
...
  }


  private FSPermissionChecker checkParentAccess(String path, FsAction access
      ) throws AccessControlException, UnresolvedLinkException {
    return checkPermission(path, false, null, access, null, null);
  }


  private FSPermissionChecker checkPermission(String path, boolean doCheckOwner,
      FsAction ancestorAccess, FsAction parentAccess, FsAction access,
      FsAction subAccess) throws AccessControlException, UnresolvedLinkException {
    FSPermissionChecker pc = new FSPermissionChecker(
        fsOwner.getShortUserName(), supergroup);
    if (!pc.isSuper) {
      dir.waitForReady();
      readLock();
      try {
        pc.checkPermission(path, dir.rootDir, doCheckOwner,
            ancestorAccess, parentAccess, access, subAccess);
      } finally {
        readUnlock();
      } 
    }
    return pc;
  }

//////////// proposed changes
  /** Rename src to dst */
  void renameTo(String src, String dst, Options.Rename... options)
      throws IOException, UnresolvedLinkException {
...
    FSPermissionChecker pc = new FSPermissionChecker(
        fsOwner.getShortUserName(), supergroup);

    writeLock();
    try {
      renameToInternal(pc, src, dst, options);
      if (auditLog.isInfoEnabled() && isExternalInvocation()) {
        resultingStat = dir.getFileInfo(dst, false); 
      }
    } finally {
      writeUnlock();
    }
...
  }


  private void renameToInternal(FSPermissionChecker pc, String src, String dst,
      Options.Rename... options) throws IOException {
...
    if (isPermissionEnabled) {
      checkParentAccess(pc, src, FsAction.WRITE);
      checkAncestorAccess(pc, dst, FsAction.WRITE);
    }
...
  }


  private FSPermissionChecker checkParentAccess(FSPermissionChecker pc, String path, FsAction access
      ) throws AccessControlException, UnresolvedLinkException {
    return checkPermission(pc, path, false, null, access, null, null);
  }


  private FSPermissionChecker checkPermission(FSPermissionChecker pc, String path, boolean doCheckOwner,
      FsAction ancestorAccess, FsAction parentAccess, FsAction access,
      FsAction subAccess) throws AccessControlException, UnresolvedLinkException {
    if (!pc.isSuper) {
      dir.waitForReady();
      readLock();
      try {
        pc.checkPermission(path, dir.rootDir, doCheckOwner,
            ancestorAccess, parentAccess, access, subAccess);
      } finally {
        readUnlock();
      } 
    }
    return pc;
  }
, Sorry the former comment did not format well. I'm trying to format it now.

The following code snippets show a simple way to change FSNamesystem::renameTo in branch-0.23.4. Changes to other methods are similar.

//////////// existent code
{code:borderStyle=solid}
  /** Rename src to dst */
  void renameTo(String src, String dst, Options.Rename... options)
      throws IOException, UnresolvedLinkException {
...
    writeLock();
    try {
      renameToInternal(src, dst, options);
      if (auditLog.isInfoEnabled() && isExternalInvocation()) {
        resultingStat = dir.getFileInfo(dst, false); 
      }
    } finally {
      writeUnlock();
    }
...
  }


  private void renameToInternal(String src, String dst,
      Options.Rename... options) throws IOException {
...
    if (isPermissionEnabled) {
      checkParentAccess(src, FsAction.WRITE);
      checkAncestorAccess(dst, FsAction.WRITE);
    }
...
  }


  private FSPermissionChecker checkParentAccess(String path, FsAction access
      ) throws AccessControlException, UnresolvedLinkException {
    return checkPermission(path, false, null, access, null, null);
  }


  private FSPermissionChecker checkPermission(String path, boolean doCheckOwner,
      FsAction ancestorAccess, FsAction parentAccess, FsAction access,
      FsAction subAccess) throws AccessControlException, UnresolvedLinkException {
    FSPermissionChecker pc = new FSPermissionChecker(
        fsOwner.getShortUserName(), supergroup);
    if (!pc.isSuper) {
      dir.waitForReady();
      readLock();
      try {
        pc.checkPermission(path, dir.rootDir, doCheckOwner,
            ancestorAccess, parentAccess, access, subAccess);
      } finally {
        readUnlock();
      } 
    }
    return pc;
  }
{code}

//////////// proposed changes
{code:borderStyle=solid}
  /** Rename src to dst */
  void renameTo(String src, String dst, Options.Rename... options)
      throws IOException, UnresolvedLinkException {
...
    FSPermissionChecker pc = new FSPermissionChecker(
        fsOwner.getShortUserName(), supergroup);

    writeLock();
    try {
      renameToInternal(pc, src, dst, options);
      if (auditLog.isInfoEnabled() && isExternalInvocation()) {
        resultingStat = dir.getFileInfo(dst, false); 
      }
    } finally {
      writeUnlock();
    }
...
  }


  private void renameToInternal(FSPermissionChecker pc, String src, String dst,
      Options.Rename... options) throws IOException {
...
    if (isPermissionEnabled) {
      checkParentAccess(pc, src, FsAction.WRITE);
      checkAncestorAccess(pc, dst, FsAction.WRITE);
    }
...
  }


  private FSPermissionChecker checkParentAccess(FSPermissionChecker pc, String path, FsAction access
      ) throws AccessControlException, UnresolvedLinkException {
    return checkPermission(pc, path, false, null, access, null, null);
  }


  private FSPermissionChecker checkPermission(FSPermissionChecker pc, String path, boolean doCheckOwner,
      FsAction ancestorAccess, FsAction parentAccess, FsAction access,
      FsAction subAccess) throws AccessControlException, UnresolvedLinkException {
    if (!pc.isSuper) {
      dir.waitForReady();
      readLock();
      try {
        pc.checkPermission(path, dir.rootDir, doCheckOwner,
            ancestorAccess, parentAccess, access, subAccess);
      } finally {
        readUnlock();
      } 
    }
    return pc;
  }
{code}, Xiaobo, I think given that you described the change briefly earlier, the best way to cover the complete change is to by posting a patch., I manually tested the patch on release-1.0.3. Looks like we have some perf gain also.

I will test hdfs-4222-branch-0.23.3.patch soon., Please review my patches. hdfs-4222-branch-0.23.3.patch should be easier to review. hdfs-4222-release-1.0.3.patch is messy since moving synchronized scopes result in reformatting.
 
I think we should enclose all FSPermissionChecker instantiations in "if (isPermissionEnabled)" blocks as follows,

    FSPermissionChecker pc = null;
    if (isPermissionEnabled) {
      pc = new FSPermissionChecker(fsOwner.getShortUserName(), supergroup);
    }

But I have not done so because I want to limit the impact of this changes. If you know it is totally safe to do such changes, please let me know. Thanks a lot., What branches should my patches be prepared for? trunk or branch-1 or branch-2 or branch-0.23.6? Thanks, [~teledriver]Thanks for working on this. I will review this shortly. Please make the patch available for trunk first. Along with it, you can also make patch available for branch-1. For branch-2 and branch-0.23.6 the patch can be merged usually. If it cannot be, then I will let you know., Suresh, Thanks a lot. I should finish what you suggested within 2 days., Xiaobo, as I was reviewing the code, I started making some changes. Let me post my patch as well., Changes in this patch:
# Introduced {{FSNamesystem#fsOwnerShortUserName}} to avoid getting short username from a UGI {{FSNamesystem#fsOwner}} every time {{FSPermissionChecker}} is used.
# Made changes to create FSPermissionChecker outside the FSNamesystem read and write lock. This is along the lines of the work Xiaobo has done.
# Documented the synchronization semantics in FSPermissionChecker and made some members final.
, {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12570045/HDFS-4222.patch
  against trunk revision .

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:red}-1 tests included{color}.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    {color:green}+1 javac{color}.  The applied patch does not increase the total number of javac compiler warnings.

    {color:green}+1 javadoc{color}.  The javadoc tool did not generate any warning messages.

    {color:green}+1 eclipse:eclipse{color}.  The patch built with eclipse:eclipse.

    {color:green}+1 findbugs{color}.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 core tests{color}.  The patch passed unit tests in hadoop-hdfs-project/hadoop-hdfs.

    {color:green}+1 contrib tests{color}.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-HDFS-Build/3986//testReport/
Console output: https://builds.apache.org/job/PreCommit-HDFS-Build/3986//console

This message is automatically generated., Nice change.  I've quickly scanned the patch and {{checkSuperuserPrivilege}} internally instantiates a permission checker, which appears to be getting called within the namespace lock in a number of places too.

To reduce the size of the patch, would it maybe make sense to use a thread-local permission checker singleton?  Ie. {{FsPermissionChecker.init()}}  sets the thread-local for the current user, and then {{FsPermissionChecker.getInstance()}} instead of {{new FsPermissionChecker}} returns the singleton?  Just a thought.

Another thought might be an option to tell a UGI to "lock-in" it's group list.  Something earlier on at a high level, maybe the NN's RPC server, could call {{UserGroupInformation.getCurrentUser().lockGroups()}}., bq. Nice change. I've quickly scanned the patch and checkSuperuserPrivilege internally instantiates a permission checker, which appears to be getting called within the namespace lock in a number of places too.
Good catch.

bq. To reduce the size of the patch, would it maybe make sense to use a thread-local permission checker singleton? Ie. FsPermissionChecker.init() sets the thread-local for the current user, and then FsPermissionChecker.getInstance() instead of new FsPermissionChecker returns the singleton? Just a thought.
Not sure how to make this work. When does thread local variable get initialized and when is it cleared, given a thread gets used for different current users?

bq. Another thought might be an option to tell a UGI to "lock-in" it's group list. Something earlier on at a high level, maybe the NN's RPC server, could call UserGroupInformation.getCurrentUser().lockGroups().
Not sure I understood this., Updated patch to address Daryn's comments., {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12570230/HDFS-4222.patch
  against trunk revision .

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:red}-1 tests included{color}.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    {color:green}+1 javac{color}.  The applied patch does not increase the total number of javac compiler warnings.

    {color:green}+1 javadoc{color}.  The javadoc tool did not generate any warning messages.

    {color:green}+1 eclipse:eclipse{color}.  The patch built with eclipse:eclipse.

    {color:green}+1 findbugs{color}.  The patch does not introduce any new Findbugs (version 1.3.9) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 core tests{color}.  The patch passed unit tests in hadoop-hdfs-project/hadoop-hdfs.

    {color:green}+1 contrib tests{color}.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-HDFS-Build/3990//testReport/
Console output: https://builds.apache.org/job/PreCommit-HDFS-Build/3990//console

This message is automatically generated., bq. Not sure how to make this work. When does thread local variable get initialized and when is it cleared, given a thread gets used for different current users?

Perhaps init-ed in the same places where {{getPermissionChecker}} is being invoked, or ideally at a higher level to avoid all command methods from having "to do the right".

bq. bq. Another thought might be an option to tell a UGI to "lock-in" it's group list. Something earlier on at a high level, maybe the NN's RPC server, could call UserGroupInformation.getCurrentUser().lockGroups().
bq. Not sure I understood this.

"lockGroups" would internally fetch the groups and then make them immutable in the UGI.  It could be invoked where {{getPermissionChecker}} is being invoked, or ideally at a higher level chokepoint for calls so it's a one-line change.  Maybe in the rpc call's doAs since a call shouldn't be running long enough that the groups will change.  This would inoculate future methods or overlooked methods from taking the lookup penalty within a lock.

In either case, I'm just trying to think of how to simplify the change and future-proof against similar issues.  Again though, I really like this change., bq. Perhaps init-ed in the same places where getPermissionChecker is being invoked, or ideally at a higher level to avoid all command methods from having "to do the right".
Only problem is, if subsequent methods are not passed FSPermissionChecker, they might end up calling getPermissionChecker (due to a bug) as well, that too inside the lock. The likelihood of that with parameter passing is low.

bq. "lockGroups" would internally fetch the groups and then make them immutable in the UGI....
We should certainly explore this in a subsequent jira., bq. "lockGroups" would internally fetch the groups and then make them immutable in the UGI. 

This will ensure group lookups happen before entering a critical section. But since mappings are cached in Groups and the UGI is short-lived, simply calling getGroups() early will be enough. One concern in early lookup is whether it will generate excessive extra lookups. Some methods in client protocol don't need permission checks as they are lease-based. For example, addBlock(), complete() and renewLease() are lease-based and their request rate is quite high. In a busy grid, they add up to over 450 requests/sec. But again, caching may reduce actual lookups, so it may not be a big deal.

If unconditionally forced early lookup is not acceptable, we could selectively do early lookup/cache-filling in NameNodeRpcServer for those calls that actually need group lookups and leave FSNamesystem mostly unchanged., bq. If unconditionally forced early lookup is not acceptable...
Current patch could have been much simpler, if FSPermissionChecker was always created. Lets do further optimizations in another patch.

If someone reviews this and +1s it, I will commit it. I plan on getting this into branch-1 as well., +1 The latest patch looks good to me. Future-proofing can be done separately if needed., I committed the patch to trunk and branch-2. Keeping this jira open to make this change available for branch-1.

Thank you [~teledriver] for the original patch. Kihwal and Daryn, thanks for the review.

Kihwal, do you want me to commit this to branch 0.23?

, Integrated in Hadoop-trunk-Commit #3375 (See [https://builds.apache.org/job/Hadoop-trunk-Commit/3375/])
    HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas. (Revision 1448801)

     Result = SUCCESS
suresh : http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&view=rev&rev=1448801
Files : 
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/CHANGES.txt
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java
, bq. Kihwal, do you want me to commit this to branch 0.23?

Yes. Thanks Suresh., Canceling the patch to attach 0.23 patch., The merge was not straightforward. Kihwal, can you also do a quick review of 0.23 version of the patch., Integrated in Hadoop-Yarn-trunk #135 (See [https://builds.apache.org/job/Hadoop-Yarn-trunk/135/])
    HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas. (Revision 1448801)

     Result = SUCCESS
suresh : http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&view=rev&rev=1448801
Files : 
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/CHANGES.txt
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java
, Integrated in Hadoop-Hdfs-trunk #1324 (See [https://builds.apache.org/job/Hadoop-Hdfs-trunk/1324/])
    HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas. (Revision 1448801)

     Result = FAILURE
suresh : http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&view=rev&rev=1448801
Files : 
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/CHANGES.txt
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java
, Integrated in Hadoop-Mapreduce-trunk #1352 (See [https://builds.apache.org/job/Hadoop-Mapreduce-trunk/1352/])
    HDFS-4222. NN is unresponsive and loses heartbeats from DNs when configured to use LDAP and LDAP has issues. Contributed by Xiaobo Peng and Suresh Srinivas. (Revision 1448801)

     Result = SUCCESS
suresh : http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&view=rev&rev=1448801
Files : 
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/CHANGES.txt
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
* /hadoop/common/trunk/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java
, The 0.23 patch looks fine. I also tried to resolve merge conflicts and ended up with pretty much the same patch as yours. The only significant code difference seems to be in getBlockLocations()., Thanks Kihwal. I committed the patch to 0.23 branch., Many thanks to Suresh, Kihwal, and Daryn for the help. I am uploading the patch for branch-1. Please review.

I have to move the synchronized keyword from the method level to the block level. So there are many lines got reformatted. I reviewed my patch several times. It was time consuming. Thanks a lot., Integrated in Hadoop-Hdfs-0.23-Build #534 (See [https://builds.apache.org/job/Hadoop-Hdfs-0.23-Build/534/])
    HDFS-4222. Merge r1448801 from trunk (Revision 1449083)

     Result = SUCCESS
suresh : http://svn.apache.org/viewcvs.cgi/?root=Apache-SVN&view=rev&rev=1449083
Files : 
* /hadoop/common/branches/branch-0.23/hadoop-hdfs-project/hadoop-hdfs/CHANGES.txt
* /hadoop/common/branches/branch-0.23/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java
* /hadoop/common/branches/branch-0.23/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java
, [~teledriver], thanks for working branch-1 patch. +1 for the patch. I will commit it soon., I committed the patch to branch-1 as well. Thank you Xiaobo!, Thank you very much for the quick action, Suresh., Closed upon release of Hadoop 1.2.0.]