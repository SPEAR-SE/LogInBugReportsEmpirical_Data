[Thanks [~shahrs87] for reporting this. I found anther two similar places in the hdfs source code.
The one  place:
{code:title=DataStreamer.java|borderStyle=solid}
    synchronized void checkRestartingNodeDeadline(DatanodeInfo[] nodes) {
      if (restartingNodeIndex >= 0) {
        ...
        // not within the deadline
        if (Time.monotonicNow() >= restartingNodeDeadline) {
          // expired. declare the restarting node dead
          restartingNodeDeadline = 0;
          final int i = restartingNodeIndex;
          ...
{code}
Another place:
{code:title=SecondaryNameNode.java|borderStyle=solid}
  public void doWork() {
    ...
      try {
        // We may have lost our ticket since last checkpoint, log in again, just in case
        if(UserGroupInformation.isSecurityEnabled())
          UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();
        
        final long monotonicNow = Time.monotonicNow();
        final long now = Time.now();

        if (shouldCheckpointBasedOnCount() ||
            monotonicNow >= lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {
          doCheckpoint();
          ...
{code}
It will be better if we can also update these two places in this jira, :)., bq. It will be better if we can also update these two places in this jira
There are many other places in the code (in order of hundreds) where we are violating the recommendation.
I was just looking for some explanation while debugging the issue and I came across this case., Before we update all comparisons involving {{nanoTime()}} values, the javadoc identifies a specific source of overflow:
{quote}
Differences in successive calls that span greater than approximately 292 years (2 ^63^ nanoseconds) will not correctly compute elapsed time due to numerical overflow. 
{quote}

Are there other cases this protects against?, Since monotonicNow() divides System.nanoTime() by NANOSECONDS_PER_MILLISECOND, it is also incorrect if we compare two values t0 and t1 returned by monotonicNow() using t1 - t0 < 0.  The approach below MAYBE correct.
{code}
t1*NANOSECONDS_PER_MILLISECOND - t0*NANOSECONDS_PER_MILLISECOND < 0
{code}
However, it may still suffer from round off errors.]