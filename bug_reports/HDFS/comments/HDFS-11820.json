[Jira is for bug report. Please use relevant mailing list for discussions and questions.

Edit logging is almost thread safe, but not entirely. Concurrency is controlled by the rule that edit logging should happen with the name system write lock held and logSync() after releasing the lock. A successful response only goes back to the user after successful logSync()., I understand that write lock guard concurrency against concurrent write to I/O. But what to be written also needs to be correct. How useful to return successful response if it failed to write things accurately, I would rather it did not succeed so client can retry. , Write lock ensures there is only one thread calling logEdit() at any time., I beg you to read the code before commenting. The whole logic to get EditLog "singleton" instance from cache and modify its attributes is outside synchornized block and outside writeLock., bq. Thread #2 catches up, and acquires same instance of RenameOp, sets different attributes
It does not happen, because logEdit() is only called with FSNamesystem writeLock held. Even when the thread is in wait(), no other thread can call logEdit(). 

bq. I beg you to read the code before commenting. The whole logic to get EditLog "singleton" instance from cache and modify its attributes is outside synchornized block and outside writeLock.

Besides, the cache is thread local., Yes you are right, I missed those two facts. Thanks for clarification!]