[relates to HDFS-7609, HDFS-8611, It's dirty reference case on FSEditLog:

 private ThreadLocal<OpInstanceCache> cache =
      new ThreadLocal<OpInstanceCache>() {
    @Override
    protected OpInstanceCache initialValue() {
      return new OpInstanceCache();
    }
  };

If NN all handler thread initial the OpInstanceCache  instance, the the thread will use later.
Such as logUpdateBlocks:

public void logUpdateBlocks(String path, INodeFileUnderConstruction file,
      boolean toLogRpcIds) {
    UpdateBlocksOp op = UpdateBlocksOp.getInstance(cache.get())
      .setPath(path)
      .setBlocks(file.getBlocks());
    logRpcIds(op, toLogRpcIds);
    logEdit(op);
  }
 
/** Record the RPC IDs if necessary */
  private void logRpcIds(FSEditLogOp op, boolean toLogRpcIds) {
    if (toLogRpcIds) {
      op.setRpcClientId(Server.getClientId());
      op.setRpcCallId(Server.getCallId());
    }
  }

If client recover the pipeline at oncetime,so the FSEditLogOp  instance will set RpcId. Even though other UpdateBlocksOp  like addBlock whick identified as  @Idempotent,but also will record repeat RpcId at editlog.
That made standby NN IPC handler thread parking, indirectly active NN.
And we found 2.7.1 has the same problem.

 

, I checked HDFS-7398. I think ClientId/CallId will be reset after logEdit(..)., thank Walter, it's my mistake,that fixed at 2.7.1]