[
We were looking at the the namenode code around the above trace. This is what it is doing :

max = 100; // in this case
 for( iter = invalidateSet.iterator(); max > 0; max-- ) {
      it.remove();
}

invalidateSet is not actually set but ArrayList(). So if it has 500 blocks, the above loop could result in 450 blocks shifted 100 times in the array. This could be one of the things exaggerating CPU. We could use LinkedList for this and also not call it a 'Set' since that could imply to the readers that this container is a Set.

If each it.remove() resulted in a big memmove(), do you think we should have seen more Java stuff above remove() in the stack trace?

Next we should also capture pstack of the JVM also so that we can see what this is doing in JVM..

Note that changing container to LinkedList might only reduce the CPU but won't fix the bug if there is any.
, This has gone stale. The current structure within BlockManager isn't a list anymore, and we haven't seen this kinda behavior in quite a while.]