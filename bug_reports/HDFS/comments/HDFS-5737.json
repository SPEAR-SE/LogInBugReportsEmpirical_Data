[Here is a patch to fix the bug.
# The easiest way to fix this is to do another sort at the start of {{AclTransformation#copyDefaultsIfNeeded}}.
# This bug had been causing us to produce invalid default ACLs that are missing the base entries (owner, group, other).  As an extra defense, I changed the validation logic so that it requires the base entries for both access and default.  Previously, this was just enforced for access.  To do this, I rewrote this portion of the logic to use the search approach, similar to what people found more readable for {{AclTransformation#copyDefaultsIfNeeded}}.  In theory, the checks on the default ACL should never fail, because we should always copy the missing required entries from the access ACL.  However, if there is a bug, then it's better to bail earlier instead of producing an invalid default ACL that gets used later.
# Added one more test in {{TestAclTransformation}}.  This test failed before I made the fix in {{AclTransformation}}., The patch looks good to me. +1. However, there are a couple efficiency issues that can be addressed in separate jiras:

# Implement your own binary search so that (1) it supports finding in a sub list of the collection, and (2) it always returns the lowest element in the list. That way you can make finding the pivot more efficient, and you don't need to create sub lists in {{copyDefaultsIfNeeded}}.
# Since you know the pivot, you can insert the default entries at the pivot position and sort that sub list. Alternatively you can separate the ACLs into default entries and access entries, and concat them at the very end., Thanks for the review, Haohui.  I'll commit this in a moment.

bq. Implement your own binary search so that (1) it supports finding in a sub list of the collection, and (2) it always returns the lowest element in the list. That way you can make finding the pivot more efficient, and you don't need to create sub lists in copyDefaultsIfNeeded.

My understanding is that {{ArrayList#subList}} returns an alternative view over the same underlying array, just with a different offset and length to pin it within the requested range.  This would mean that there is no cost incurred for copying the underlying data, just some extra math to deal with offset calculations, so perhaps the efficiency gain would be minor.  Here is the code for {{ArrayList#subList}}:

http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/ArrayList.java#876

Agreed on point 2 though that we'd need a custom binary search variant if we want to do that.  {{Collections#binarySearch}} can't do it., I committed this to the HDFS-4685 feature branch.]