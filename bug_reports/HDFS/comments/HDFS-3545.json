[Reference in MR https://issues.apache.org/jira/browse/MAPREDUCE-4340
Reference in Hive https://issues.apache.org/jira/browse/hive-3155, Currently to fix this defect, we need to get the FileSystem object from the cache if the UGI credentials matches, but this FileSystem objects can lead to wrong token being used in setting up connections causing security related issue.  HADOOP-6564, I've looked into "fixing" this problem too, but I don't think it's solvable.  A {{UGI/Subject}} is mutable so even though two different UGI instances may appear identical at one point in time, one UGI's {{Subject}} may have altered tokens that should not be visible by other UGI instances., I've looked into the issue quite a bit further.  It's not a cache issue, but client code is misusing the filesystem.

Systems encountering OOM for the {{FileSystem}} cache are not properly calling {{FileSystem.closeAllForUGI(ugi)}}.  If {{UserGroupInformation.createRemoteUser(user)}} is called and the resulting ugi is used to obtain filesystems, then {{FileSystem.closeAllForUGI}} _must_ be invoked when the created ugi is no longer needed.  I'm preparing to do this in the NM.

Caching the UGI is fraught with peril.  Tokens will be unexpectedly shared.  Reusing a token in a cached ugi risks using an old expired token.  To compound the issue, tokens can be added but not removed from a ugi.  Thus even if a new token is obtained & added to the ugi, then it's non-deterministic whether the new token or the old expired token will be used for a connection.

There are also possible security issues related to allowing multiple jobs for a client using a union of all acquired tokens in a cached ugi.
, I'm curious to know if doing an FS.closeAllForUgi() fixes this problem. I can confirm that it did fix HIVE-3098.

A confirmation here would be a double-check for the HIVE-3098 fix., We've seen this bug recently, so I studied it a bit. 

[~daryn] While I think client is partly responsible for managing objects, fundamentally, if FileSystem object is obtained via {{FileSystem#get(final URI uri, final Configuration conf, final String user)}} in a non-secure cluster, it should not be cached at all, because each invocation of {{FileSystem#get(final URI uri, final Configuration conf, final String user)}} stores a new object in cache, and hence memory leak.]