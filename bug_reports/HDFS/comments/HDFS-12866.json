[bq. 1.1. hold the fsn write lock, disconnect the target to be deleted from its parent dir, release the lock
Many have thought about doing this. The snapshot makes it very hard., I've contemplated this exact approach for a long time and wish I did it eons ago because Kihwal is right, snapshots have made it much harder.

There's a high likelihood you will need the lock in step 2.1.  Inode based file operations.  Updating the snapshot diffs probably isn't thread-safe.   Perhaps batched locking like the block deletion might work.  Then you need to consider possible issues like incorrect quota computation if the live copy of the file is moved during the background delete of the snapshot.  Maybe I'm wrong, or maybe there are more tricky cases.

bq.  any operations on any file/dir need to check if its ancestor is deleted
Unless you have a means to avoid a traverse to root check for each block processed in an IBR/FBR, it's _not even an option_.

Stepping back, I've suggest actually profiling the NN.  Perhaps it's changed, but a major contributor to the slowness in the past was multiple subdir traversals to check permissions, compute quota, look for snapshots, etc that paled in comparison to the actual block collection.  Permission checks have been further degraded when acls are used.  It gets really bad when using an external inode attribute provider., Thanks much for the feedback [~kihwal] and [~daryn].

Yes, with snapshot, an INode won't be disconnected when it's in previous snapshot, it will be repaced with INodeRefenrence instead. So we can use a bit in the INode to indicate whether it's "disconnected" instead of physical disconnection from the parent.

Indeed I was thinking traversing to the root to check, like done in {{FSNamesystem#isFileDeleted}}, it cost some time, but we can find if an INode is disconnected, right?

Optimizing the permission checking etc would help, however, without postponing the deletion work to later, if the tree is large enough, we can still hit this problem.  Quota  computation will still be done, just not done right away. Hopefully that won't cause too much problem?

So the main issue of this approach is the cost of traversing to the root to check if any ancestor is disconnected? I wonder how bad it is. In IBR and FBR, can we assume the file exists if the INode is there? The block deletion step (step 2) will get them removed later anyways.

Thanks again.




, bq. Indeed I was thinking traversing to the root to check, like done in FSNamesystem#isFileDeleted, it cost some time, but we can find if an INode is disconnected, right?
I thought the parent was nulled for an inodeRef.WithName when deleted explicitly or implicitly as source of move.  The {{FSN#isFileDeleted}} implementation shows otherwise and is shockingly bad: looking up every ancestor child inode in its parent for an equality check.

bq. So the main issue of this approach is the cost of traversing to the root to check if any ancestor is disconnected? I wonder how bad it is.
Actually the main issue is what does a profile reveal?  Let's not make premature optimizations w/o solid analysis.

As for the traverse, making that a pervasive check throughout operations is penalizing the common case for what should be a relatively rare case (deletion of super-large directory).  Perhaps every 1-2y a massive directory is removed and stalls the NN for mins.  I want that danger removed but not at the expense of general performance.

bq. In IBR and FBR, can we assume the file exists if the INode is there?
It will be if only an ancestor is unlinked.   Don't have time to look, but I have concerns of what happens if a block slated for removal is updated and possibly added to other data structures (corrupt, excess, etc) or worse generates an edit which cannot be replayed.

]