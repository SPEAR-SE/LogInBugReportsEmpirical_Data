[The logic does look flawed.  I _think_ it may have been predicated on the belief that the login user would always equal either the current user, or the real user of a proxy ugi.  It certainly looks like the given ugi should be used in the relogin.

On an aside, it seems odd there isn't a {{UGI#relogin()}} that determines if it should use a keytab, ticket cache, etc...  Not sure why all the callers that want to relogin should have knowledge of the login method., We discovered this while testing kerberized FUSE.  Basically the auto-renewal logic doesn't work at all.

For now HDFS-3608 is our workaround (we need this workaround anyway because the FUSE user may kdestroy and re-kinit somewhere else)., Good point, Daryn, about proxy-users.

I agree we should add UGI.relogin(). If it's a proxy user, it would delegate the relogin call to its real user. Otherwise it would relogin with the appropriate credential., bq. I think it may have been predicated on the belief that the login user would always equal either the current user
Yeah the logic should have made it explicit that the relogin is attempted for the login user only (and that was the use case for which it was written). IIRC this method was intended to do just that., @Deveraj: I'm not sure I understand your response.  Do you believe the current logic is correct?  If so, it doesn't work in cases such as using a ugi from {{loginUserFromKeytabAndReturnUGI}} within a {{doAs}} to make a connection., Only the login-user is expected to have kerberos tgt and the renewal is attempted for such users. The method gives a false impression that it is trying to renew the tgt for a passed ugi. The logic should be corrected in that sense (to not take a passed ugi and instead have the method body within a getLoginUser.doAs()). Is there a good use case where we would like to renew the kerberos credentials of arbitrary users? (note for proxy-user cases, getLoginUser will return the right user)., bq. Only the login-user is expected to have kerberos tgt and the renewal is attempted for such users
That's not entirely true.  I think you might be missing the key point that the UGI api allows for multiple TGT authenticated UGIs.

bq.  Is there a good use case where we would like to renew the kerberos credentials of arbitrary users? 
Yes, it's breaking fuse.  But the bigger question is why break a usable api? A non-login UGI with a TGT can be used to open a connection and the UGI api exists to log it back in.  Why should the rpc client artificially prevent this UGI from being logged back in?

bq. note for proxy-user cases, getLoginUser will return the right user
No, not always.  The SASL code above _assumes_ the default login user is the real user of a proxy UGI.  If you create another TGT authenticated UGI and use it to create a proxy UGI, then the real user does not match the login user.
, Agree with Daryn above. The whole "login user" concept is ill-thought out IMO - it's perfectly valid for a single process to want to have different types of servers open, each acting as a different kerberos credential. (eg how we use one kerberos principal for SPNEGO authenticated HTTP and another for RPC), Clearly, I was only thinking of the use cases this method was initially coded to address (e.g. JobTracker talking to NameNode, or, other long running hdfs client users). In those cases, we have the login user as the user whose credentials need to be updated every so often. My last comment was in that context.. 

But yeah, if there are uses where other UGIs with Kerberos creds need to talk to servers, sure, please update the method as such., Do we have any update on this issue? The TGT auto-renewal doesn't work for libhdfs, which is a big limitation for applications using this c interface.]