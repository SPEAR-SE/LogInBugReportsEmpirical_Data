[First patch to fix this issue.

[~rgs]
Could you help to review this small patch? Thanks a lot., +1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12774789/ZOOKEEPER-2332-v001.diff
  against trunk revision 1715590.

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/2969//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/2969//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/2969//console

This message is automatically generated., [~liushaohui]: how did the empty txnlog happened in the first place? I am bit worried that by doing this we might introduce inconsistencies... If a txnlog is corrupted, we should just give up.

[~fpj], [~rakeshr]: thoughts?, Actually, I am very worried - not a little :-), We add a header to each txn log file, so if it is missing, then I assume the server crashed before it had a chance to write it. It might be ok to skip this file, but I need to think a bit about corner cases., [~rgs]
{quote}
how did the empty txnlog happened in the first place?
{quote}
The zookeeper server was killed after creating a new txn log file before flushing the log header to the log.
So a txn log is left without a valid header and makes the the zookeeper server fail to start.
See: FileTxnLog.java#207
{code}
            if (logStream==null) {
               if(LOG.isInfoEnabled()){
                    LOG.info("Creating new log file: log." +  
                            Long.toHexString(hdr.getZxid()));
               }
               
               logFileWrite = new File(logDir, ("log." + 
                       Long.toHexString(hdr.getZxid())));
               fos = new FileOutputStream(logFileWrite);
               logStream=new BufferedOutputStream(fos);
               oa = BinaryOutputArchive.getArchive(logStream);
               FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);
               fhdr.serialize(oa, "fileheader");
               // Make sure that the magic number is written before padding.
               logStream.flush();
               currentSize = fos.getChannel().position();
               streamsToFlush.add(fos);
            }
{code}, Thanks [~liushaohui] for working on this. Yes, an empty file would be created with the statement {{fos = new FileOutputStream(logFileWrite);}}. I'm just adding one more case [FileSnap.java#L225|https://github.com/apache/zookeeper/blob/trunk/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java#L225] of empty snapshot file creation. Skipping the empty file is an easy approach, here we need to see cases like, file is corrupted and becomes empty etc., bq. The zookeeper server was killed after creating a new txn log file before flushing the log header to the log.

This sounds like a case where we should rely on an atomicity guarantee from the file system to make sure that the new log file is committed in a consistent state.  For example:

# Create new log file named log.<zxid>.new.
# Write and flush header.
# Atomically rename log.<zxid>.new to log.<zxid>.

This would ensure that any file named log.\* that is not named log.\*.new is a valid transaction log file containing at least a complete header.  After that, the pre-existing log file padding and checksumming logic should be sufficient to protect against things like a partially serialized transaction.  At read time, the code can self-recover from prior errors by ignoring and deleting leftover "uncommitted" log.\*.new files.

I think this would be less brittle than trying to detect a bad log file at load time., bq. This sounds like a case where we should rely on an atomicity guarantee from the file system to make sure that the new log file is committed in a consistent state.
Its a good point. How about using {{org.apache.zookeeper.common.AtomicFileOutputStream}}, which will be helpful to ensure atomicity. While writing the file its using a temporary file, {{.tmp}} suffix and finally renames to original file., Yes, something similar to {{AtomicFileOutputStream}} would work well.  The current implementation of {{AtomicFileOutputStream}} isn't an exact fit for this, because the "commit" is tightly coupled to closing the file.  In this case, we'd want to commit (atomically rename) without closing the file, so that we can keep appending transactions to the open log file., +1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12774789/ZOOKEEPER-2332-v001.diff
  against trunk revision 1729259.

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3049//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3049//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3049//console

This message is automatically generated., I've seen this problem happen on a system that ran out of disk space due to other application filling up the disk. The entry for the transaction log file was created on the file system but ZooKeeper was not able to write anything into it. After the system was rebooted and disk space was released, ZooKeeper failed to start.

I think this is a two-fold problem.
# On one hand, ZooKeeper should not be creating corrupted log or snapshot files.
# On the other hand, it should not explode with an unhandled exception if it does come across an invalid log file.

Before opening a snapshot file, ZooKeeper does some quick and inexpensive validation and rejects the corrupted snapshots. It does not validate the log files and does not handle read/parse errors in case if came across a corrupted log file.

The defect is reproducible on the heads of master, branch-3.5, and branch-3.4., +1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12774789/ZOOKEEPER-2332-v001.diff
  against trunk revision cef5978969bedfe066f903834a9ea4af6d508844.

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3494//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3494//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3494//console

This message is automatically generated.]