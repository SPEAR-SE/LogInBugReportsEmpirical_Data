[zookeeper1.log ： ofs_zk1
zookeeper2.log ： ofs_zk3, I suggest that there can be more that one WorkSender in FastLeaderElection, so that network failure of some zk servers will not affect the notifications to others., I encounter the same problem. Wait for a conclusion.,  Mark, meet the same problem.    , GitHub user JonathanO opened a pull request:

    https://github.com/apache/zookeeper/pull/456

    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.

    Move sock.connect() into the async connection worker thread.
    Use initiateConnectionAsync for all connections.
    This prevents connection delays blocking notifications to other nodes.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/transferwise/zookeeper ZOOKEEPER-2930

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/zookeeper/pull/456.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #456
    
----
commit 68e327e112b0910e56b9fa2b3ba948e4179adb6b
Author: Jonathan Oddy <jonathan.oddy@...>
Date:   2018-02-02T15:33:50Z

    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.
    
    Move sock.connect() into the async connection worker thread.
    Use initiateConnectionAsync for all connections.
    This prevents connection delays blocking notifications to other nodes.

----
, So, I think what happens is, if the 2nd node in the list dies in a way that causes new connections to time out then the notification messages to the 3rd node are delayed by >=5s while those to the 1st node are delivered on time. (sendNotifications() queues a notification to all three nodes (including the local node), in order, and toSend() blocks during sending the message to the 2nd node.)

This 5s delay means that if the 3rd node is elected, it will see the election complete >= 5s after the 1st node does. The 1st node attempts to connect to the 3rd on the leader port 5 times with a 1s delay (both hard coded) but, since the 3rd node hasn't seen the election complete, it hasn't started listening on that port yet. Unless you're very lucky with timing, the 1st node will give up and start a new election round before the 3rd realises that it has been elected. The 3rd node then sits there for initLimit before going back to the LOOKING state, leaving you with a broken cluster for at least initLimit.

My patch attempts to fix this by making the entire process of establishing a connection async, avoiding it blocking toSend()., Github user JonathanO commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/456#discussion_r166036745
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---
    @@ -689,15 +669,15 @@ synchronized void connectOne(long sid){
                 Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();
                 if (lastCommittedView.containsKey(sid)) {
                     knownId = true;
    -                if (connectOne(sid, lastCommittedView.get(sid).electionAddr))
    -                    return;
    --- End diff --
    
    This part of the change isn't quite right since it relied on connectOne returning false on an IOException calling sock.connect(). We will no longer attempt to use lastProposedView.get(sid).electionAddr in the case that a connection using the lastCommittedView failed and the electionAddr has changed. I don't know what effect this will have. Maybe I need to move this condition into the async connection mechanism too?
, GitHub user JonathanO opened a pull request:

    https://github.com/apache/zookeeper/pull/465

    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.

    Backported to 3.4 from the ZOOKEEPER-2930 branch.
    
    Move sock.connect() into the async connection worker thread.
    Moved a load of connectOne(sid) into the async connection worker thread.
    Use use the async connection worker for all connections.
    This prevents connection delays blocking notifications to other nodes.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/transferwise/zookeeper branch-3.4-ZOOKEEPER-2930

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/zookeeper/pull/465.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #465
    
----
commit ca05df6049e3282fef9fd3f34d07337011b5f4f6
Author: Jonathan Oddy <jonathan.oddy@...>
Date:   2018-02-15T12:22:24Z

    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.
    
    Backported from 3.5.
    
    Move sock.connect() into the async connection worker thread.
    Moved a load of connectOne(sid) into the async connection worker thread.
    Use use the async connection worker for all connections.
    This prevents connection delays blocking notifications to other nodes.

----
, Github user fpj commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/456#discussion_r168620297
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---
    @@ -318,76 +318,167 @@ public Thread newThread(Runnable r) {
          */
         public void testInitiateConnection(long sid) throws Exception {
             LOG.debug("Opening channel to server " + sid);
    -        Socket sock = new Socket();
    -        setSockOpts(sock);
    -        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
    -        initiateConnection(sock, sid);
    +        initiateConnection(sid, self.getVotingView().get(sid).electionAddr);
    +    }
    +
    +    private Socket openChannel(long sid, InetSocketAddress electionAddr) {
    +        LOG.debug("Opening channel to server " + sid);
    +        try {
    +            final Socket sock = new Socket();
    +            setSockOpts(sock);
    +            sock.connect(electionAddr, cnxTO);
    +            LOG.debug("Connected to server " + sid);
    +            return sock;
    +        } catch (UnresolvedAddressException e) {
    +            // Sun doesn't include the address that causes this
    +            // exception to be thrown, also UAE cannot be wrapped cleanly
    +            // so we log the exception in order to capture this critical
    +            // detail.
    +            LOG.warn("Cannot open channel to " + sid
    +                    + " at election address " + electionAddr, e);
    +            throw e;
    +        } catch (IOException e) {
    +            LOG.warn("Cannot open channel to " + sid
    +                            + " at election address " + electionAddr,
    +                    e);
    +            return null;
    +        }
         }
     
         /**
          * If this server has initiated the connection, then it gives up on the
          * connection if it loses challenge. Otherwise, it keeps the connection.
          */
    -    public void initiateConnection(final Socket sock, final Long sid) {
    +    public boolean initiateConnection(final Long sid, InetSocketAddress electionAddr) {
             try {
    -            startConnection(sock, sid);
    -        } catch (IOException e) {
    -            LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection",
    -                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);
    -            closeSocket(sock);
    -            return;
    +            Socket sock = openChannel(sid, electionAddr);
    +            if (sock != null) {
    +                try {
    +                    startConnection(sock, sid);
    +                } catch (IOException e) {
    +                    LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection",
    +                            new Object[]{sid, sock.getRemoteSocketAddress()}, e);
    +                    closeSocket(sock);
    +                }
    +                return true;
    +            } else {
    +                return false;
    +            }
    +        } finally {
    +            inprogressConnections.remove(sid);
             }
         }
     
    -    /**
    -     * Server will initiate the connection request to its peer server
    -     * asynchronously via separate connection thread.
    -     */
    -    public void initiateConnectionAsync(final Socket sock, final Long sid) {
    +    synchronized private void connectOneAsync(final Long sid, final ZooKeeperThread connectorThread) {
    +        if (senderWorkerMap.get(sid) != null) {
    +            LOG.debug("There is a connection already for server " + sid);
    +            return;
    +        }
             if(!inprogressConnections.add(sid)){
                 // simply return as there is a connection request to
                 // server 'sid' already in progress.
                 LOG.debug("Connection request to server id: {} is already in progress, so skipping this request",
                         sid);
    -            closeSocket(sock);
                 return;
             }
             try {
    -            connectionExecutor.execute(
    -                    new QuorumConnectionReqThread(sock, sid));
    +            connectionExecutor.execute(connectorThread);
                 connectionThreadCnt.incrementAndGet();
             } catch (Throwable e) {
                 // Imp: Safer side catching all type of exceptions and remove 'sid'
                 // from inprogress connections. This is to avoid blocking further
                 // connection requests from this 'sid' in case of errors.
                 inprogressConnections.remove(sid);
                 LOG.error("Exception while submitting quorum connection request", e);
    -            closeSocket(sock);
             }
         }
     
    +    /**
    +     * Try to establish a connection to server with id sid using its electionAddr.
    +     *
    +     * Server will initiate the connection request to its peer server
    +     * asynchronously via separate connection thread.
    +     *
    +     *  @param sid  server id
    +     *  @param electionAddr election address
    +     */
    +    private void connectOne(final Long sid, InetSocketAddress electionAddr) {
    +        connectOneAsync(sid, new QuorumConnectionReqThread(sid, electionAddr));
    +    }
    +
    +    /**
    +     * Try to establish a connection to server with id sid.
    +     *
    +     * Server will initiate the connection request to its peer server
    +     * asynchronously via separate connection thread.
    +     *
    +     *  @param sid  server id
    +     */
    +    public void connectOne(final Long sid) {
    +        connectOneAsync(sid, new QuorumConnectionReqBySidThread(sid));
    +    }
    +
         /**
          * Thread to send connection request to peer server.
          */
    -    private class QuorumConnectionReqThread extends ZooKeeperThread {
    -        final Socket sock;
    +    private class QuorumConnectionReqBySidThread extends ZooKeeperThread {
             final Long sid;
    -        QuorumConnectionReqThread(final Socket sock, final Long sid) {
    +
    +        QuorumConnectionReqBySidThread(final Long sid) {
                 super("QuorumConnectionReqThread-" + sid);
    -            this.sock = sock;
                 this.sid = sid;
             }
     
             @Override
             public void run() {
    -            try{
    -                initiateConnection(sock, sid);
    -            } finally {
    -                inprogressConnections.remove(sid);
    +            synchronized (self.QV_LOCK) {
    +                boolean knownId = false;
    +                // Resolve hostname for the remote server before attempting to
    +                // connect in case the underlying ip address has changed.
    +                self.recreateSocketAddresses(sid);
    +                Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();
    +                QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();
    +                Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();
    +                if (lastCommittedView.containsKey(sid)) {
    +                    knownId = true;
    +                    if (initiateConnection(sid, lastCommittedView.get(sid).electionAddr)) {
    +                        return;
    +                    }
    +                }
    +                if (lastSeenQV != null && lastProposedView.containsKey(sid)
    +                        && (!knownId || (lastProposedView.get(sid).electionAddr !=
    +                        lastCommittedView.get(sid).electionAddr))) {
    +                    knownId = true;
    +                    if (initiateConnection(sid, lastProposedView.get(sid).electionAddr)) {
    +                        return;
    +                    }
    +                }
    +                if (!knownId) {
    +                    LOG.warn("Invalid server id: " + sid);
    +                    return;
    +                }
                 }
             }
         }
     
    +    /**
    +     * Thread to send connection request to peer server.
    +     */
    +    private class QuorumConnectionReqThread extends ZooKeeperThread {
    --- End diff --
    
    Since we are making this change to run the connection establishment on a separate thread, I wonder if it would make sense to use an executor rather than instantiate a thread each time. What do you think?
, Github user fpj commented on the issue:

    https://github.com/apache/zookeeper/pull/456
  
    I have also tested this PR a bit locally.
, Github user JonathanO commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/456#discussion_r169910520
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---
    @@ -318,76 +318,167 @@ public Thread newThread(Runnable r) {
          */
         public void testInitiateConnection(long sid) throws Exception {
             LOG.debug("Opening channel to server " + sid);
    -        Socket sock = new Socket();
    -        setSockOpts(sock);
    -        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
    -        initiateConnection(sock, sid);
    +        initiateConnection(sid, self.getVotingView().get(sid).electionAddr);
    +    }
    +
    +    private Socket openChannel(long sid, InetSocketAddress electionAddr) {
    +        LOG.debug("Opening channel to server " + sid);
    +        try {
    +            final Socket sock = new Socket();
    +            setSockOpts(sock);
    +            sock.connect(electionAddr, cnxTO);
    +            LOG.debug("Connected to server " + sid);
    +            return sock;
    +        } catch (UnresolvedAddressException e) {
    +            // Sun doesn't include the address that causes this
    +            // exception to be thrown, also UAE cannot be wrapped cleanly
    +            // so we log the exception in order to capture this critical
    +            // detail.
    +            LOG.warn("Cannot open channel to " + sid
    +                    + " at election address " + electionAddr, e);
    +            throw e;
    +        } catch (IOException e) {
    +            LOG.warn("Cannot open channel to " + sid
    +                            + " at election address " + electionAddr,
    +                    e);
    +            return null;
    +        }
         }
     
         /**
          * If this server has initiated the connection, then it gives up on the
          * connection if it loses challenge. Otherwise, it keeps the connection.
          */
    -    public void initiateConnection(final Socket sock, final Long sid) {
    +    public boolean initiateConnection(final Long sid, InetSocketAddress electionAddr) {
             try {
    -            startConnection(sock, sid);
    -        } catch (IOException e) {
    -            LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection",
    -                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);
    -            closeSocket(sock);
    -            return;
    +            Socket sock = openChannel(sid, electionAddr);
    +            if (sock != null) {
    +                try {
    +                    startConnection(sock, sid);
    +                } catch (IOException e) {
    +                    LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection",
    +                            new Object[]{sid, sock.getRemoteSocketAddress()}, e);
    +                    closeSocket(sock);
    +                }
    +                return true;
    +            } else {
    +                return false;
    +            }
    +        } finally {
    +            inprogressConnections.remove(sid);
             }
         }
     
    -    /**
    -     * Server will initiate the connection request to its peer server
    -     * asynchronously via separate connection thread.
    -     */
    -    public void initiateConnectionAsync(final Socket sock, final Long sid) {
    +    synchronized private void connectOneAsync(final Long sid, final ZooKeeperThread connectorThread) {
    +        if (senderWorkerMap.get(sid) != null) {
    +            LOG.debug("There is a connection already for server " + sid);
    +            return;
    +        }
             if(!inprogressConnections.add(sid)){
                 // simply return as there is a connection request to
                 // server 'sid' already in progress.
                 LOG.debug("Connection request to server id: {} is already in progress, so skipping this request",
                         sid);
    -            closeSocket(sock);
                 return;
             }
             try {
    -            connectionExecutor.execute(
    -                    new QuorumConnectionReqThread(sock, sid));
    +            connectionExecutor.execute(connectorThread);
                 connectionThreadCnt.incrementAndGet();
             } catch (Throwable e) {
                 // Imp: Safer side catching all type of exceptions and remove 'sid'
                 // from inprogress connections. This is to avoid blocking further
                 // connection requests from this 'sid' in case of errors.
                 inprogressConnections.remove(sid);
                 LOG.error("Exception while submitting quorum connection request", e);
    -            closeSocket(sock);
             }
         }
     
    +    /**
    +     * Try to establish a connection to server with id sid using its electionAddr.
    +     *
    +     * Server will initiate the connection request to its peer server
    +     * asynchronously via separate connection thread.
    +     *
    +     *  @param sid  server id
    +     *  @param electionAddr election address
    +     */
    +    private void connectOne(final Long sid, InetSocketAddress electionAddr) {
    +        connectOneAsync(sid, new QuorumConnectionReqThread(sid, electionAddr));
    +    }
    +
    +    /**
    +     * Try to establish a connection to server with id sid.
    +     *
    +     * Server will initiate the connection request to its peer server
    +     * asynchronously via separate connection thread.
    +     *
    +     *  @param sid  server id
    +     */
    +    public void connectOne(final Long sid) {
    +        connectOneAsync(sid, new QuorumConnectionReqBySidThread(sid));
    +    }
    +
         /**
          * Thread to send connection request to peer server.
          */
    -    private class QuorumConnectionReqThread extends ZooKeeperThread {
    -        final Socket sock;
    +    private class QuorumConnectionReqBySidThread extends ZooKeeperThread {
             final Long sid;
    -        QuorumConnectionReqThread(final Socket sock, final Long sid) {
    +
    +        QuorumConnectionReqBySidThread(final Long sid) {
                 super("QuorumConnectionReqThread-" + sid);
    -            this.sock = sock;
                 this.sid = sid;
             }
     
             @Override
             public void run() {
    -            try{
    -                initiateConnection(sock, sid);
    -            } finally {
    -                inprogressConnections.remove(sid);
    +            synchronized (self.QV_LOCK) {
    +                boolean knownId = false;
    +                // Resolve hostname for the remote server before attempting to
    +                // connect in case the underlying ip address has changed.
    +                self.recreateSocketAddresses(sid);
    +                Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();
    +                QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();
    +                Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();
    +                if (lastCommittedView.containsKey(sid)) {
    +                    knownId = true;
    +                    if (initiateConnection(sid, lastCommittedView.get(sid).electionAddr)) {
    +                        return;
    +                    }
    +                }
    +                if (lastSeenQV != null && lastProposedView.containsKey(sid)
    +                        && (!knownId || (lastProposedView.get(sid).electionAddr !=
    +                        lastCommittedView.get(sid).electionAddr))) {
    +                    knownId = true;
    +                    if (initiateConnection(sid, lastProposedView.get(sid).electionAddr)) {
    +                        return;
    +                    }
    +                }
    +                if (!knownId) {
    +                    LOG.warn("Invalid server id: " + sid);
    +                    return;
    +                }
                 }
             }
         }
     
    +    /**
    +     * Thread to send connection request to peer server.
    +     */
    +    private class QuorumConnectionReqThread extends ZooKeeperThread {
    --- End diff --
    
    I considered it, especially as the QuorumConnectionReqBySidThread case (and the backport to 3.4 #465) are effectively run serially. It just seemed consistent with the existing approach to stick with creating a thread for every new connection. There shouldn't be large numbers of them being created, so I figured it should be fine.
, I hope this PB can be fix in version 3.4.X, since 3.4.X is the stable version., PR #465 contains the backport of my fix to 3.4.x., Github user JonathanO commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/456#discussion_r172802731
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---
    @@ -318,76 +318,167 @@ public Thread newThread(Runnable r) {
          */
         public void testInitiateConnection(long sid) throws Exception {
             LOG.debug("Opening channel to server " + sid);
    -        Socket sock = new Socket();
    -        setSockOpts(sock);
    -        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
    -        initiateConnection(sock, sid);
    +        initiateConnection(sid, self.getVotingView().get(sid).electionAddr);
    +    }
    +
    +    private Socket openChannel(long sid, InetSocketAddress electionAddr) {
    +        LOG.debug("Opening channel to server " + sid);
    +        try {
    +            final Socket sock = new Socket();
    +            setSockOpts(sock);
    +            sock.connect(electionAddr, cnxTO);
    +            LOG.debug("Connected to server " + sid);
    +            return sock;
    +        } catch (UnresolvedAddressException e) {
    +            // Sun doesn't include the address that causes this
    +            // exception to be thrown, also UAE cannot be wrapped cleanly
    +            // so we log the exception in order to capture this critical
    +            // detail.
    +            LOG.warn("Cannot open channel to " + sid
    +                    + " at election address " + electionAddr, e);
    +            throw e;
    +        } catch (IOException e) {
    +            LOG.warn("Cannot open channel to " + sid
    +                            + " at election address " + electionAddr,
    +                    e);
    +            return null;
    +        }
         }
     
         /**
          * If this server has initiated the connection, then it gives up on the
          * connection if it loses challenge. Otherwise, it keeps the connection.
          */
    -    public void initiateConnection(final Socket sock, final Long sid) {
    +    public boolean initiateConnection(final Long sid, InetSocketAddress electionAddr) {
             try {
    -            startConnection(sock, sid);
    -        } catch (IOException e) {
    -            LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection",
    -                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);
    -            closeSocket(sock);
    -            return;
    +            Socket sock = openChannel(sid, electionAddr);
    +            if (sock != null) {
    +                try {
    +                    startConnection(sock, sid);
    +                } catch (IOException e) {
    +                    LOG.error("Exception while connecting, id: {}, addr: {}, closing learner connection",
    +                            new Object[]{sid, sock.getRemoteSocketAddress()}, e);
    +                    closeSocket(sock);
    +                }
    +                return true;
    +            } else {
    +                return false;
    +            }
    +        } finally {
    +            inprogressConnections.remove(sid);
             }
         }
     
    -    /**
    -     * Server will initiate the connection request to its peer server
    -     * asynchronously via separate connection thread.
    -     */
    -    public void initiateConnectionAsync(final Socket sock, final Long sid) {
    +    synchronized private void connectOneAsync(final Long sid, final ZooKeeperThread connectorThread) {
    +        if (senderWorkerMap.get(sid) != null) {
    +            LOG.debug("There is a connection already for server " + sid);
    +            return;
    +        }
             if(!inprogressConnections.add(sid)){
                 // simply return as there is a connection request to
                 // server 'sid' already in progress.
                 LOG.debug("Connection request to server id: {} is already in progress, so skipping this request",
                         sid);
    -            closeSocket(sock);
                 return;
             }
             try {
    -            connectionExecutor.execute(
    -                    new QuorumConnectionReqThread(sock, sid));
    +            connectionExecutor.execute(connectorThread);
                 connectionThreadCnt.incrementAndGet();
             } catch (Throwable e) {
                 // Imp: Safer side catching all type of exceptions and remove 'sid'
                 // from inprogress connections. This is to avoid blocking further
                 // connection requests from this 'sid' in case of errors.
                 inprogressConnections.remove(sid);
                 LOG.error("Exception while submitting quorum connection request", e);
    -            closeSocket(sock);
             }
         }
     
    +    /**
    +     * Try to establish a connection to server with id sid using its electionAddr.
    +     *
    +     * Server will initiate the connection request to its peer server
    +     * asynchronously via separate connection thread.
    +     *
    +     *  @param sid  server id
    +     *  @param electionAddr election address
    +     */
    +    private void connectOne(final Long sid, InetSocketAddress electionAddr) {
    +        connectOneAsync(sid, new QuorumConnectionReqThread(sid, electionAddr));
    +    }
    +
    +    /**
    +     * Try to establish a connection to server with id sid.
    +     *
    +     * Server will initiate the connection request to its peer server
    +     * asynchronously via separate connection thread.
    +     *
    +     *  @param sid  server id
    +     */
    +    public void connectOne(final Long sid) {
    +        connectOneAsync(sid, new QuorumConnectionReqBySidThread(sid));
    +    }
    +
         /**
          * Thread to send connection request to peer server.
          */
    -    private class QuorumConnectionReqThread extends ZooKeeperThread {
    -        final Socket sock;
    +    private class QuorumConnectionReqBySidThread extends ZooKeeperThread {
             final Long sid;
    -        QuorumConnectionReqThread(final Socket sock, final Long sid) {
    +
    +        QuorumConnectionReqBySidThread(final Long sid) {
                 super("QuorumConnectionReqThread-" + sid);
    -            this.sock = sock;
                 this.sid = sid;
             }
     
             @Override
             public void run() {
    -            try{
    -                initiateConnection(sock, sid);
    -            } finally {
    -                inprogressConnections.remove(sid);
    +            synchronized (self.QV_LOCK) {
    +                boolean knownId = false;
    +                // Resolve hostname for the remote server before attempting to
    +                // connect in case the underlying ip address has changed.
    +                self.recreateSocketAddresses(sid);
    +                Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();
    +                QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();
    +                Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();
    +                if (lastCommittedView.containsKey(sid)) {
    +                    knownId = true;
    +                    if (initiateConnection(sid, lastCommittedView.get(sid).electionAddr)) {
    +                        return;
    +                    }
    +                }
    +                if (lastSeenQV != null && lastProposedView.containsKey(sid)
    +                        && (!knownId || (lastProposedView.get(sid).electionAddr !=
    +                        lastCommittedView.get(sid).electionAddr))) {
    +                    knownId = true;
    +                    if (initiateConnection(sid, lastProposedView.get(sid).electionAddr)) {
    +                        return;
    +                    }
    +                }
    +                if (!knownId) {
    +                    LOG.warn("Invalid server id: " + sid);
    +                    return;
    +                }
                 }
             }
         }
     
    +    /**
    +     * Thread to send connection request to peer server.
    +     */
    +    private class QuorumConnectionReqThread extends ZooKeeperThread {
    --- End diff --
    
    Are you OK with this approach, or would you prefer me to change it?
]