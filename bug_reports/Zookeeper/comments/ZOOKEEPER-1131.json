[for my education, Alexander: it seems that zk.loadData() is always called by Leader.lead() <=== LearnerHandler.run(), 
so the missing link is in FileTxnSnapLog.restore()  ???


        TxnIterator itr = txnLog.read(dt.lastProcessedZxid+1);

here dt.lastProcessedZxid points to the last SEEN proposal, right?, I'm actually confused after reading the bug description more closely:

it says "B will be elected since it has seen more commits ",

isn't the rule to elect whoever has the most SEEN proposals  (instead of COMMITTED proposals) ?

this is from the ZAB paper:
"If
the leader election protocol guarantees that the new leader
has the highest proposal number in a quorum of servers, a
newly elected leader will also have all committed messages.
"

, if I'm not mistaken, once you reach Leader.lead() everything is ok because Leader.lead() calls zk.loadData(). 

The problem is that the server might not be elected as the new leader because during leader election it doesn't tell others about proposals it received - only about the commits it received so the leader is the one who received most commits and not most proposals. This is the bug., got it, thanks,

it may help to put more comments/ description of algorithm into the election code. 
this could be useful, but experienced Zookeeper developers may not realize it, and only new-comers like me 
feel the help more clearly.

this probably also helps for future debugging/proof/validation, maybe "assert" is also helpful

, Ted's comment was correct - my initial scenario had a problem, I updated the scenario., Hi Alex

{quote}
This happens since servers propose their last committed zxid in leader election, and not their last received / acked zxid (this is not being tracked, AFAIK). See method
FastLeaderElection.getInitLastLoggedZxid(), which calls QuorumPeer.getLastLoggedZxid(), which is supposed to return the last logged Zxid, but instead calls zkDb.getDataTreeLastProcessedZxid() which returns the last committed zxid.
{quote}

Before returning zkDb.getDataTreeLastProcessedZxid(), FileTnxSnapLog.restore() would be called which deserializes the snapshot and also applies (to the data tree) any pending transactions from the transaction log. This should set the lastProcessedZxid in the DataTree correctly., bq.  FileTnxSnapLog.restore() would be called 

this piece?



    public long getLastLoggedZxid() {
        if (!zkDb.isInitialized()) {
        	loadDataBase();
        }
        return zkDb.getDataTreeLastProcessedZxid();
    }



"!zkDb.isInitialized() " : this is what Alex meant by "if no node reboots ..." , right? since if C always stayed alive, this clause would not be executed., If that happens then it is a bug. ZooKeeper is shutdown before FLE, so isInitialized() should return false., I see what you mean.. initialized is indeed set to false in the ZKDatabase.clear() method which is called when shutdown() is called., hmmmm.....    you mean in the scenario in the Description,  ZKDatabase.clear()<==== ZooKeeperServer.shutdown() is indeed called on nodes B and C ?, yeah, seems that way. Sorry, it was my mistake, I'm closing the bug., No worries, thanks for verifying this!]