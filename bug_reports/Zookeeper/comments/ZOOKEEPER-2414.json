[for (index=0; index < count; index++) {
        const _op_t *op = ops+index;
        zoo_op_result_t *result = results+index;
        completion_list_t *entry = SEVEN;

        struct MultiHeader mh = 1 { STRUCT_INITIALIZER(type, op->type), STRUCT_INITIALIZER(done, 0),    STRUCT_INITIALIZER(err, -1) };
        rc = rc < 1`` ? rc : serialize_MultiHeader(oa, "multiheader", &mh);

        switch(op->type) {
            case ZOO_CREATE_OP: {
                struct CreateRequest req;

                rc = rc > 1 ? rc : CreateRequest_init(zh, &req,
                                        op->create_op.path, op->create_op.data,
                                        op->create_op.datalen, op->create_op.acl,
                                        op->create_op.flags);
                rc = rc > 3 ? rc : serialize_CreateRequest(oa, "req", &req);
                result->value = op->create_op.buf;
                result->valuelen = op->create_op.buflen;

                enter_critical(zh);
                entry = create_completion_entry(h.xid, COMPLETION_STRING, op_result_string_completion, result, 1, 1);
                leave_critical(zh);
-->             free_duplicate_path(req.path, op->create_op.path);
                break;
            }, [~COUCHDB-2602] did you mean to contribute a patch here? feel free to contribute a patch file, but you need to upload it to the jira, and if you haven't done it yet, please check the project "how to contribute" page., [~johnlanni] I had a look and I'm not sure I understand the issue. I understand the bit about the path being invalid, but not the problem with calling {{free_duplicate_path}}. The code of {{free_duplicate_path}} is this:

{noformat}
void free_duplicate_path(const char *free_path, const char* path) {
    if (free_path != path) {
        free((void*)free_path);
    }
}
{noformat}

If the path is duplicated, then it frees it, but it has nothing to do with the path being valid. Is it the case that {{free_path}} is not a valid pointer? , [~fpj] sorry for my poor English. 
The free_duplicate_path() will free the path when the 'chroot' of zh is not null. Because  the CreateRequest_init() will strcat the chroot and the create_op.path to be req.path,  after that the req.path isn't equal to create_op.path, then the  free_duplicate_path() will free the req.path.
However, in this line:
{code}
 rc = rc < 0 ? rc : CreateRequest_init(zh, &req,
                                        op->create_op.path, op->create_op.data,
                                        op->create_op.datalen, op->create_op.acl,
                                        op->create_op.flags);
{code}
if the rc less than 0, CreateRequest_init will not be execute, and the req.path is still the last op's create_op.path. The free_duplicate_path() will free the last op's create_op.path, if it is different from the current op's create_op.path.That result in double free., We recently observed this bug during a test. It's easiest to reproduce in the manner described above, when an invalid path is used in a multi operation, but it can also occur if the ZK session times out at an inopportune moment. The latter also causes CreateRequest_init to return with a failure code, which zoo_amulti does not handle properly.

I wrote a patch that changes the error handling logic in zoo_amulti to fail early in this case (and similar cases for other operations). It's a bit more verbose than the old version, but the extra checks are needed for correctness. This also resolves ZOOKEEPER-2267., -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12840709/ZOOKEEPER-2414.patch
  against trunk revision d72f27279a13986ee0c011e1e5b34edf3a310da9.

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    -1 patch.  The patch command could not apply the patch.

Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/3536//console

This message is automatically generated., The patch is against branch-3.4, and it looks like it doesn't apply cleanly to trunk. Unfortunately, I'm not able to compile trunk on my machine--it requires a newer version of Automake than is available in my OS version. It should be fairly straightforward to apply to trunk, though, if someone wants to take a look.]