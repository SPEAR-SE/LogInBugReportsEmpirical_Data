[what is different between the quorum sync and 'empty' set ?
 
there is another problem that sync is a async, we ignore the result usually. If we connect to another server before get the response,  the followed read may get a stale value., Hi,

Its pretty much the same as an empty write, and perhaps an easy way to implement it without introducing a new operation. 
Unlike writes, I don't think we want to log the syncs. Anyway, users can currently do "write + read" instead of "sync + read" to get strong semantics.

Good point about the connection change. Yes, this is a problem. I'm not sure how this is implemented exactly, but intuitively we need the client to update its last-seen-zxid once the sync completes. This way if the connection change happens after the sync completes the client will only connect to someone at least as up-to-date as the sync. And if the connection switch happens before the sync completes then the sync will fail, which is also fine.

Alex , sync is an asynchronous operation, we usually ignore the result. we may need a multi-op to make it atomic., I don't think it matters whether its synchronous or asynchronous. I'm not suggesting that sync returns a value, so you can continue ignoring the result. I'm only proposing to change how sync is implemented internally. Following the sync the user will still invoke a read just like now. 

BTW, an alternative (which I think you're referring to) is to create a "strong read" that will return a value and will be atomic, but that doesn't solve the problem of sync. It can also be implemented using a multiop of sync+read as I think you're implying.

, Sorry, it has nothing to do with correctness. What I want to tell is we may need more codes to achieve a really "strong read".]