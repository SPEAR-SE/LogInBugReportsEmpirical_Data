[It seems to me that there are two unnecessary synchronized blocks: one on sendTo() for the call to initiateConnection, and second upon a new connection and subsequent call to receiveConnection. Both methods synchronize again on senderWorkerMap when it is time to update the bookkeeping information on the connections. By removing these two, we prevent the problem pointed out in this jira. I have tested, and it seems to work, and logic also seems to work to me.

I will postpone submitting a patch because I'd like to have a patch for 127 reviewed and committed first. , What happens when two peers initiate connections to each other simultaneously without a mutex between initiateConnection and receiveConnection?

If the challenges are not equal one peer will win and the other will lose. On the winning peer, the original call to initiateConnection will commit its connection, and on the same server receiveConnection will call initiateConnection, creating a second connection.

If they are in fact equal then the challenge will be modified thread-unsafely, creating a race condition with the other executing thread where the challenge value could change at any point during either initiateConnection or receiveConnection, which would break the protocol.

In addition, there are points within these two methods where synchronized blocks would need to be added around senderWorkerMap, or it would need to become a ConcurrentHashMap.

Does this analysis sound correct?, Thanks for the analysis, Austin.

The first case is correct, but if there are two initiated connections, then either one will remain or none. In the former case, we are fine. In the latter case, peers will eventually try again once they receive a new message to send. It is true that in the worst case, the peers may be be forever trying to open a connection to each other, but the probability of that happening is low enough if there is enough timing variability.The alternative to avoid simultaneous attempts to establish a connection between pairs of peers is to impose a pre-defined order. Doing this is inefficient because peers often show up for leader election at different times, if they show up at all, and the peer responsible for starting a connection would have to keep retrying periodically forever.

In any case, it is not possible to guarantee termination for leader election in asynchronous systems, and QuorumCnxManager is part of the leader election code, so such anomalous runs are expected to happen. 

For the second case, there is a second redundant synchronized block inside each of the calls (initiateConnection and  receiveConnection). These guards guarantee that information pertinent to connections is updated in a thread-safe manner. At least, that's what they should do.

It is probably a good idea to use ConcurrentHashMap for senderWorkerMap as you propose.

Finally, I have opened another JIRA (141), to replace the random challenge with the server id, which is supposed to be unique. Although the probability of the challenges being the same is supposedly low, we can remove any doubt with such a change., Flavio, could you update the server java code with a summary of this JIRA as a comment? Perhaps as part of a class javadoc so that it will show up in the generated javadoc html., A proposed solution to this problem is implemented in the patch of JIRA 127., This issue has been resolved by the patch of 127, which has been committed., 3.0.0 has been released, closing issues.]