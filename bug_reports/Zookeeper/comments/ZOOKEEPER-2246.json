[Yes, a timeout of zero is interpreted as an infinite timeout. I'm not seeing any specific reason for waiting infinitely. IMHO, timeout could be {{self.tickTime * self.syncLimit}} similar to SendWorker thread.
{code}
     // OK to wait until socket disconnects while reading.
     sock.setSoTimeout(0);
{code}, Java doc for SO_TIMEOUT http://bit.ly/1LjGGVq implies that this timeout is only for blocking calls and does not apply for send() aka writes., Plainly removing  sock.setSoTimeout(0) from http://s.apache.org/TfI has the unintended consequence of shutting down both the RecvWorker and SendWorker threads for all cases. Seems like current code is designed to  keep the socket alive (and threads to keep running) so as to reuse this channel to communicate again with the the peer node which still alive but needs to redo leader election.

I could not reproduce any issue if threads shutdown after the timeout since new threads are created for next iteration of leader election. I rather would like to reuse the threads and the channel hence I propose the following approach.

The alternative I suggest is to still remove setSoTimeout(0) from here: http://s.apache.org/TfI  , also enable SO_KEEPALIVE via setKeepAlive() on this socket and do not consider it an error when timeout occurs here: http://bit.ly/1JHIdVY but consider it an error when it happens here: http://bit.ly/1NTjQ9R

This means that users can play with keep alive timeouts for TCP sockets to quicken TCP socket failures propagating to user-space and zookeeper also resets the socket if it detects other side is not responding when it knows it needs a response within some bounded time.

Ideally I wish there is some userspace pings of every socket channel between zookeeper nodes to detect dead channels quickly. Seems like one exists for sockets that do Follow/Lead after leader election is done but not for this?. Such a feature could be added with care towards making it backward compatible., ZOOKEEPER-2080 seems tightly related to this.

https://issues.apache.org/jira/browse/ZOOKEEPER-2080?focusedCommentId=14740513&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14740513
, ZOOKEEPER-2246: quorum connection manager takes a long time to shut down
    
    Enable SO_TIMEOUT and SO_KEEPALIVE for the socket.
    Do not close the socket on a read timeout for reading the header of the msg.
    
    Patch submitted by VMWare Inc., Hi [~pmvmware], +1 for your great patch.

Unfortunately I can still hit ZOOKEEPER-2080 with your patch.

I consider this is because the socket is still uninterruptible, and 
{{java.nio.channels.SocketChannel}} (which is interruptible) looks better than plain old {{java.net.Socket}}.

If you have a different opinion about interruption handling, please let me know.

Thanks, Hi [~pmvmware], +1 for your great patch.

Unfortunately I can still hit ZOOKEEPER-2080 with your patch.

I consider this is because the socket is still uninterruptible, and 
{{java.nio.channels.SocketChannel}} (which is interruptible) looks better than plain old {{java.net.Socket}}.

If you have a different opinion about interruption handling, please let me know.

Thanks, Hi Akihiro,

Thanks for looking at the patch. Reading up on SocketChannel and InputStream/OutputStream you are correct about better interrupt-ability of SocketChannel while performing read/write operations.

However looking at the code of RecvWorker/SendWorker/Listener and Halt() in QCM class it seems like CloseSocket() is called for all paths before calling thread.interrupt(). And since both read() and write() operations throw IOException when socket is already closed I think a blocking read() should throw an exception if socket is closed. Hence the shutdown of these threads seems safe as far finish() , halt() code paths are concerned. 

I tried to look at logs from [ZOOKEEPER-2080|https://issues.apache.org/jira/browse/ZOOKEEPER-2080] and I am unable to reach any conclusion on using SocketChannel could solve the problem or that is even the root cause of that issue. I will continue to look at it more closely.

I can however modify the patch to use SocketChannel instead of InputStream/OutputStream and perhaps you can help try to reproduce it with that?.

Let me know.
thanks
Powell., Hi, [~pmvmware]

Yes, you got a point.

Actually, I found old ZooKeeper (< 3.4.0) had used blocking-mode {{java.nio.channels.SocketChannel}}.
However, it has been replaced to {{java.net.Socket}} since [{{b6e612}}|https://github.com/apache/zookeeper/commit/b6e612a6a075ed1dc44addafc480c20ff972b54a] (17 Nov 2010) so as to support {{SO_TIMEOUT}}. (ZOOKEEPER-900)
(It is possible to support {{SO_TIMEOUT}} in {{java.nio.channels.SocketChannel}}, but needs an eccentric trick: https://technfun.wordpress.com/2009/01/29/networking-in-java-non-blocking-nio-blocking-nio-and-io/)

Note that there has been 5 years of strong desire for drastic refactoring of QCM  (ZOOKEEPER-901), but it might take a time to get resolved.

So I suggest to merge the patch, and call it a day for the moment.

Thanks!]