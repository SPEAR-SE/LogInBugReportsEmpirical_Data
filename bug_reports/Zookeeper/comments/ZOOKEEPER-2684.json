[From these logs it is difficult to know what's going on besides that some reordering is happening somewhere. It would be good to find out where exactly this happens. It would be interesting for example to see what is the cxid order in which the leader commits these operations (you can print their zxid)., The ZK as is lacks pretty much any live debuggability so that's all it logged. I did add temporary logs to the code base and was fortunately able to repro albeit with dismal performances. I was going to put the detailed logs in the comment following this but sounds like you would like to see them in the description (which I was going to just use as a description of the problem instead of an analysis and solution). I am still debating on a proper fix (I have two less than perfect solutions) and thinking of adding a more compelling test than the test I have now but it's kinda tricky. I will put in more details and possibly the solution tomorrow if I figure out how to do the github thing,  stay tuned., Hi Ryan, I didn't mean to rush you. Putting the logs in the comments sounds just fine., Sounds good, btw, is this the recommended way to communicate (through comments)?, yes, I think so, Hi Ryan, is it possible that the reason you see this type of bad behavior is because it wasn't examined before in the commit processor? i.e., it's a new error message that we added in order to notify that commit messages don't follow their client order. 
I wonder, can you to add to an un-patched version the same error message? (and see if you get that error) 
e.g., before [this|https://github.com/apache/zookeeper/commit/9fc632c4f0a340b0a00ec6dff39c7b454c802822?diff=split#diff-5cc688a027068714af01b0ad4d292fe5L223] point, add something like        

if (pending != null && pending.sessionId == request.sessionId && pending.cxid > request.cxid) 
 LOG.error("Got cxid 0x " + Long.toHexString(request.cxid) + " expected 0x" + Long.toHexString(pending.cxid) + " for client session id " + Long.toHexString(request.sessionId));
 throw new IOException("Error: unexpected cxid for" + "client session");
, Hi, Kfir,  I think you are getting to the point. (I don't need to add the log, I knew what happened) The unpatched version just pass that request to the next processor while this patch throw an exception. I am pasting the exact reason below to save you more guess time :), While I am at it, let me paste the enhanced log of a repo.

The problem was created when there is a session move. When a session just moved, the new processor starts to get requests from the session so it will crash when a commit coming from previous session handler comes.  Here are the logs from on repro

Learner A  got the session 0x100186ea825fa45 starting from cxid 0xfb6 
/var/log/zookeeper/zookeeper-info.log.65:2017-02-06 20:56:03,635 - INFO  [FollowerRequestProcessor:0] - Processing request:: sessionid:0x100186ea825fa45 type:create cxid:0xfb6 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
/var/log/zookeeper/zookeeper-info.log.65:2017-02-06 20:56:03,636 - INFO  [FollowerRequestProcessor:0] - Processing request:: sessionid:0x100186ea825fa45 type:delete cxid:0xfb7 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1301965514
/var/log/zookeeper/zookeeper-info.log.65:2017-02-06 20:56:03,636 - INFO  [FollowerRequestProcessor:0] - Processing request:: sessionid:0x100186ea825fa45 type:create cxid:0xfb8 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
/var/log/zookeeper/zookeeper-info.log.65:2017-02-06 20:56:04,123 - INFO  [QuorumPeer[myid=0](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x100186ea825fa45 type:error cxid:0xfb5 zxid:0x8e06e60288 txntype:-1 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.65:2017-02-06 20:56:04,123 - ERROR [CommitProcessor:0] - Got request sessionid:0x100186ea825fa45 type:error cxid:0xfb5 zxid:0x8e06e60288 txntype:-1 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.65: expected request sessionid:0x100186ea825fa45 type:create cxid:0xfb6 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
/var/log/zookeeper/zookeeper-info.log.65: for client session id 0x100186ea825fa45


follower B that processed 0xfb5 and got session 0x100186ea825fa45 closed after 0Xfb5
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:34,234 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:delete cxid:0xfb0 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1301965515
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:34,345 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:create cxid:0xfb1 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:34,659 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:delete cxid:0xfae zxid:0x8e06e3c727 txntype:2 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:34,659 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:create cxid:0xfaf zxid:0x8e06e3c728 txntype:1 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:34,664 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:delete cxid:0xfb2 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1301965516
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:34,764 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:create cxid:0xfb3 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:35,056 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:delete cxid:0xfb4 zxi
d:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1301965517
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:35,363 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:delete cxid:0xfb0 zxid:0x8e06e3d4bc txntype:2 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:35,465 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:create cxid:0xfb1 zxid:0x8e06e3d718 txntype:1 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:35,804 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:delete cxid:0xfb2 zxid:0x8e06e3de59 txntype:2 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:35,882 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:create cxid:0xfb3 zxid:0x8e06e3dfe6 txntype:1 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:55:36,150 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x1001
86ea825fa45 type:delete cxid:0xfb4 zxid:0x8e06e3e4c8 txntype:2 reqpath:n/a
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:56:03,132 - WARN  [NIOWorkerThread-16] - Unable to read additional data from client sessionid 0x100186ea825fa45, likely clie
nt has closed socket
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:56:03,136 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:create cxid:0xfb5 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
/var/log/zookeeper/zookeeper-info.log.67:2017-02-06 20:56:04,123 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x100186ea825fa45 type:error cxid:0xfb5 zxid:0x8e06e60288 txntype:-1 reqpath:n/a

2017-02-06 20:56:03,136 - INFO  [FollowerRequestProcessor:4] - Processing request:: sessionid:0x100186ea825fa45 type:create cxid:0xfb5 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_
2017-02-06 20:56:04,123 - INFO  [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x100186ea825fa45 type:error cxid:0xfb5 zxid:0x8e06e60288 txntype:-1 reqpath:n/a

the leader got 0xfb5 first
2017-02-06 20:56:04,122 - INFO  [ProcessThread(sid:1 cport:-1):] - Leader proposing: sessionid:0x100186ea825fa45 type:create cxid:0xfb5 zxid:0x8e06e60288 txntype:-1 reqpath:n/a
2017-02-06 20:56:04,122 - INFO  [LearnerHandler-/10.40.89.122:42232] - Commit a proposal: sessionid:0x100186ea825fa45 type:create cxid:0xfb5 zxid:0x8e06e60288 txntype:-1 reqpath:n/a

and then 0xfb6
2017-02-06 20:56:04,610 - INFO  [ProcessThread(sid:1 cport:-1):] - Leader proposing: sessionid:0x100186ea825fa45 type:create cxid:0xfb6 zxid:0x8e06e60bfb txntype:1 reqpath:n/a
2017-02-06 20:56:04,611 - INFO  [LearnerHandler-/10.40.91.124:52180] - Commit a proposal: sessionid:0x100186ea825fa45 type:create cxid:0xfb6 zxid:0x8e06e60bfb txntype:1 reqpath:n/a

So there is no out of order commit but the session queue in the commitProcessor gets created before the last commit from previous session life comes., Hi Ryan,

Thanks for the analysis! How about throwing an exception only in case we see a cxid > what we expected, and only logging if we see something smaller than expected ?

Thanks,
Alex, + to what Alex wrote - handle the case of < as a remote session commit. 
I.e., something like these changes:

[here|https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java#L256] change the "!=" to ">".

and [here|https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java#L255] need to "peek" instead of "poll".

and [here|https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java#L271] need to add 

"if (request.cxid == topPending.cxid) {
sessionQueue.poll();"
and the rest of the local request processing up until [this|https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java#L274] line., Alex, yes, I think the solution is pretty much along this line after we know what leads to this crash.

Kfir, I am sorry that I can't really make out exactly what those "this" links point to, can you put a line number somewhere?

In any case, I have a fix along the line of knowing the first CXid of the session this server sees and only does the comparison to queue head when it's larger than that. I am testing it internally and also trying to figure out how to do that github and "pull request" thing if I am happy with the result. I am still working on a test case that can repro this reliably and being unsuccessful so far., newbie questions, there seems to be two git remote ( https://github.com/apache/zookeeper.git and https://git-wip-us.apache.org/repos/asf/zookeeper.git), which one should I pick?
Which branch should I base on? My understanding is that this is in 3.6 but there is no 3.6 branch, does this mean I will patch it on top of master?, Please use https://github.com/apache/zookeeper - fork it and you can create pull request.
branch master is for 3.6 so yes, patch on top of master., btw more info on https://cwiki.apache.org/confluence/display/ZOOKEEPER/HowToContribute (section Pull requests via github), Ryan, sorry for the mess I wrote, I'll write it again as a patch so that we'll see we're on the same page (I'll try to write a unit test that cover the case you identified)., Hi, Michael,  the link you and Alex gave me has the "git clone https://git-wip-us.apache.org/repos/asf/zookeeper.git"  as the first command, that's why I was confused, I guess I will go through the github route. Thanks for the clarification.
 , Hi, Kfir, I have a unit case and it's not bad. The problem is to come up with a quorum based test., Hi Ryan, do you mean that you want  to test it on several running servers? 
I think you can modify the system test (or the upgraded one here - https://issues.apache.org/jira/browse/ZOOKEEPER-2023) by making clients to change server every couple of writes. 
If this is what you need I can add it as well to 2023. 
I'm also attaching a patch, let me know if you agree with it. , Hi, Kfir, when I say a quorum based test I mean a test class that extends the QuorumBase class.

as for your patch, the biggest question for me is that how does it check that the commit is not duplicated? The request could have been processed in the queue before. On a high level, I am not sure what piece of code ensures that won't happen (I assume in the lead code but I don't know on top of my head). My approach is to remember the first CXid ever appeared but it's kinda messy. If you can point me to that code guarantee no duplication and no reorder then I think I would be happy to not be so strict here in the commitProcessor

, [~nerdyyatrice] The wiki page was a little bit out dated - I just updated the page https://cwiki.apache.org/confluence/display/ZOOKEEPER/HowToContribute hopefully will create less confusions for new contributors., [~nerdyyatrice], can you please describe the scenario in which the same request is processed in the queue twice? 

As I see it, if a request r is received from a local client, then r is added to the queue (note that r was already sent to the leader prior to that point).

Once a commit arrives from the leader, r is processed, and r won't be back to the queue, regardless of a possible client disconnection (AFAIK, the connection is only needed at the end of the line, when some kind of result is returned).

Now, lets say the client gets disconnected at some point in the time frame above while r is processed, and connects to some server (same server or different). 

If a commit arrives to a different server, r will be processed as if it belongs to a remote client, i.e., we will only perform the update, without using the connection. I'm not sure that after disconnection ZK is required to inform the client's new session on his past actions.. (but I guess it can also be fixed if needed).
If a commit arrives and r is in the queue waiting for it, then it is processed as if it belongs to a local connected client, but eventually the connection handle will show that that connection ended, (if I remember the code correctly), so nothing to report, but ZK continue as usual. 

Note that if a client writes something with lower cxid than r, the commit processor doesn't track such a behavior, i.e., it is possible that the next head after r will have lower cxid than r. We only care about the order of commits that we receive from the leader, and that order can't be changed, because it is based on the network protocol order of messages (i.e., if r was already sent to the leader, than clearly r is committed prior to any new message of the same client). 

Bottom line, it seems like r is processed only once per processor. What am I missing?, Kfir Lev-Ari, no, you are not missing anything. I just wondered how does ZK guarantee that the same request won't be send to the commit processor twice as a lot of strange things can happen in a distributed system. I would like to add a check in the commit processor but my implementation is a bit messier than I like, otherwise I think it won't hurt even if this never happens., Oh, I see. Well, the leader is the one that sends commit messages (i.e., saying that an update should be committed). 
Unless I'm mistaken, based on ZAB (i.e., ZK's consensus algorithm), leaders wouldn't send commit of the same message twice. I'm not sure about the exact locations in the code that you can read in order to validate it (here is a link about ZAB - https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab1.0)., If I understand the concern correctly, you're worried that we'd consider a duplicate request as legitimate because it has op cxid < queued cxid like in the session migration case. I agree that if something goes wrong that's possible. But, I think we should just log this when it happens, maybe Log.warn. This is very similar
to what is done in other parts of ZooKeeper, see for example Follower.java  when the follower gets a proposal which it doesn't expect. 

It is also somewhat related to ZooKeeper-22 Jira, which is about identifying whether a client's operation has been executed or not. I don't think we want to tackle it here., Sounds good to me. I will change my implementation then. I am still trying to figure out the github thing so please go ahead with the patch if I don't get time to do a pull request (which is not the same as doing a patch here, I guess?), k, I followed the instruction and (I think) submitted a pull request https://github.com/apache/zookeeper/pull/167. What's next?, Github user shralex commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/167#discussion_r100486359
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -251,27 +252,29 @@ public void run() {
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
    +                        Request topPending = sessionQueue.peekFirst();
                             // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                        // we can get commit requests for requests before we even get this session
    +                        //(see ZOOKEEPER-2684). We will just pass those commits to the next processor.
    +                        if(request.cxid < topPending.cxid) {
    +                            LOG.warn("Got commit request " + request
    +                                + " that is less than our queue head " + topPending);
    +                        } else {
    +                            topPending = sessionQueue.poll();
    --- End diff --
    
    Do you mind separating the if into 3 cases instead of 2 ? here's a suggestion:
    if ( < )
        // comment here about this case, pointing to the JIRA.
       Log.warn
    else if ( > )
       Log error, throw exception
    else
       poll and do what the old code does.
, Github user shralex commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/167#discussion_r100486141
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -251,27 +252,29 @@ public void run() {
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
    +                        Request topPending = sessionQueue.peekFirst();
                             // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                        // we can get commit requests for requests before we even get this session
    +                        //(see ZOOKEEPER-2684). We will just pass those commits to the next processor.
    +                        if(request.cxid < topPending.cxid) {
    +                            LOG.warn("Got commit request " + request
    --- End diff --
    
    This isn't as informative as the other messsege. Could you please use the same message format in both ?
, Github user shralex commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/167#discussion_r100486459
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -251,27 +252,29 @@ public void run() {
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
    +                        Request topPending = sessionQueue.peekFirst();
                             // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                        // we can get commit requests for requests before we even get this session
    +                        //(see ZOOKEEPER-2684). We will just pass those commits to the next processor.
    --- End diff --
    
    please remove the new comments from here and add them inside the if, where this case is handled.
, Unfortunately, this is only half of the story. I tested the build and see the following crash

atla-cbo-26-sr4.prod.twttr.net:  2017-02-14 17:55:42,323 - ERROR [CommitProcessor:4] - Severe unrecoverable error, from thread : CommitProcessor:4
atla-cbo-26-sr4.prod.twttr.net:  org.apache.zookeeper.KeeperException$RuntimeInconsistencyException: KeeperErrorCode = RuntimeInconsistency
atla-cbo-26-sr4.prod.twttr.net:  	at org.apache.zookeeper.server.quorum.CommitProcessor.run(CommitProcessor.java:276)
atla-cbo-26-sr4.prod.twttr.net:  2017-02-14 18:12:25,515 - ERROR [CommitProcessor:4] - Got request sessionid:0x40069edcb5b7b7f type:create cxid:0x36 zxid:0x38205009d26 txntype:1 reqpath:n/a
atla-cbo-26-sr4.prod.twttr.net:   but we are expecting request sessionid:0x40069edcb5b7b7f type:delete cxid:0x30 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1759491424
atla-cbo-26-sr4.prod.twttr.net:  


Stay tuned, I am adding back the verbose logs and will report on what I found, From what I understand, seems like a session starts a connection with a smaller cxid than it had in a previous connection?, so here is what actually happened

On the server A, the request is processed right after the session connection is closed and the request is forwarded to the lead

investigate.log:2017-02-14 23:30:50,373 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getData cxid:0x14 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1775503086
investigate.log:2017-02-14 23:30:54,327 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getData cxid:0x15 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1775503083
investigate.log:2017-02-14 23:30:57,888 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getData cxid:0x16 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1775503084
investigate.log:2017-02-14 23:31:01,583 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getData cxid:0x17 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1775493180
investigate.log:2017-02-14 23:31:04,867 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getData cxid:0x18 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1775493181
investigate.log:2017-02-14 23:31:08,150 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getData cxid:0x19 zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1775985079
investigate.log:2017-02-14 23:31:12,672 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:getChildren2 cxid:0x1a zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen
investigate.log:2017-02-14 23:31:17,293 - WARN [NIOWorkerThread-16] - Exception causing close of session 0x4006b1b17808b0c: Broken pipe
investigate.log:2017-02-14 23:31:17,297 - INFO [FollowerRequestProcessor:4] - Processing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1776069644
investigate.log:2017-02-14 23:31:21,816 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x27 zxid:0x385012a1e94 txntype:2 reqpath:n/a
investigate.log:2017-02-14 23:31:21,816 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x28 zxid:0x385012a1e95 txntype:1 reqpath:n/a
investigate.log:2017-02-14 23:31:21,816 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x29 zxid:0x385012a1e96 txntype:2 reqpath:n/a
investigate.log:2017-02-14 23:31:21,816 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x2a zxid:0x385012a1e98 txntype:1 reqpath:n/a
investigate.log:2017-02-14 23:31:21,817 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x2b zxid:0x385012a1e9b txntype:2 reqpath:n/a
investigate.log:2017-02-14 23:31:21,817 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x2c zxid:0x385012a1e9c txntype:1 reqpath:n/a
investigate.log:2017-02-14 23:31:21,818 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x2d zxid:0x385012a1ea1 txntype:2 reqpath:n/a
investigate.log:2017-02-14 23:31:21,822 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x2e zxid:0x385012a1eb8 txntype:1 reqpath:n/a
investigate.log:2017-02-14 23:31:21,824 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x2f zxid:0x385012a1ec0 txntype:2 reqpath:n/a
investigate.log:2017-02-14 23:31:21,833 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x30 zxid:0x385012a1ee9 txntype:1 reqpath:n/a
investigate.log:2017-02-14 23:31:22,048 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:error cxid:0x1b zxid:0x385012a2156 txntype:-1 reqpath:n/a
investigate.log:2017-02-14 23:31:22,690 - ERROR [CommitProcessor:4] - Got request sessionid:0x4006b1b17808b0c type:delete cxid:0x27 zxid:0x385012a1e94 txntype:2 reqpath:n/a
investigate.log: but we are expecting request sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0xfffffffffffffffe txntype:unknown reqpath:/loadgen/load_1776069644
investigate.log:2017-02-14 23:32:39,172 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x4c zxid:0x385012b34fa txntype:1 reqpath:n/a
investigate.log:2017-02-14 23:32:48,677 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x4e zxid:0x385012b6c31 txntype:2 reqpath:n/a
investigate.log:2017-02-14 23:32:54,580 - INFO [QuorumPeer[myid=4](plain=/0:0:0:0:0:0:0:0:2181)(secure=disabled)] - Committing request:: se


while on the lead side, the requests are arrived out of order (in terms of Cxid) 

2017-02-14 23:31:21,822 - INFO [LearnerHandler-/10.45.111.116:53431] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x2e zxid:0x385012a1eb8 txntype:1 reqpath:n/a
2017-02-14 23:31:21,824 - INFO [LearnerHandler-/10.45.111.116:53431] - Commit a proposal: sessionid:0x4006b1b17808b0c type:delete cxid:0x2f zxid:0x385012a1ec0 txntype:2 reqpath:n/a
2017-02-14 23:31:21,824 - INFO [LearnerHandler-/10.45.111.116:53431] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x2f zxid:0x385012a1ec0 txntype:2 reqpath:n/a
2017-02-14 23:31:21,833 - INFO [LearnerHandler-/10.45.111.116:53431] - Commit a proposal: sessionid:0x4006b1b17808b0c type:create cxid:0x30 zxid:0x385012a1ee9 txntype:1 reqpath:n/a
2017-02-14 23:31:21,833 - INFO [LearnerHandler-/10.45.111.116:53431] - Committing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x30 zxid:0x385012a1ee9 txntype:1 reqpath:n/a
2017-02-14 23:31:21,999 - DEBUG [ProcessThread(sid:1 cport:-1):] - Got user-level KeeperException when processing sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0x385012a2156 txntype:-1 reqpath:/loadgen/load_1776069644 Error Path:null Error:KeeperErrorCode = Session moved
investigate.log.1:2017-02-14 23:31:21,999 - INFO [ProcessThread(sid:1 cport:-1):] - Processing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0x385012a2156 txntype:-1 reqpath:/loadgen/load_1776069644
investigate.log.1:2017-02-14 23:31:21,999 - INFO [ProcessThread(sid:1 cport:-1):] - Leader proposing: sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0x385012a2156 txntype:-1 reqpath:/loadgen/load_1776069644
investigate.log.1:2017-02-14 23:31:22,048 - INFO [LearnerHandler-/10.45.112.127:53292] - Commit a proposal: sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0x385012a2156 txntype:-1 reqpath:/loadgen/load_1776069644
investigate.log.1:2017-02-14 23:31:22,048 - INFO [LearnerHandler-/10.45.112.127:53292] - Committing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x1b zxid:0x385012a2156 txntype:-1 reqpath:/loadgen/load_1776069644
2017-02-14 23:31:26,728 - INFO [ProcessThread(sid:1 cport:-1):] - Processing request:: sessionid:0x4006b1b17808b0c type:delete cxid:0x32 zxid:0x385012a3bd0 txntype:2 reqpath:n/a
2017-02-14 23:31:26,728 - INFO [ProcessThread(sid:1 cport:-1):] - Leader proposing: sessionid:0x4006b1b17808b0c type:delete cxid:0x32 zxid:0x385012a3bd0 txntype:2 reqpath:n/a
2017-02-14 23:31:26,728 - INFO [ProcessThread(sid:1 cport:-1):] - Processing request:: sessionid:0x4006b1b17808b0c type:create cxid:0x33 zxid:0x385012a3bd1 txntype:1 reqpath:n/a

Ideally, I would like to check if the server still owns the session (has a connection open) but it seems there is no easy way to check that. Any thoughts? The worst case is just be like the un-patched version to not check at all..., Good catch!
About testing if the connection is still open - I think that the following scenario is possible:
1. a client C disconnects from server A.
2. C sends some requests via server B
3. C disconnects from B and returns to A. 

In that scenario, we'll see that C has an open connection, but still we'll receive (at A) the messages from B with higher cxid.
IMHO, we should just remove the check, i.e., only attach the connection info if it is equal to the pending commit we see, (as in the original version)., That's what I thought too. I submitted the new change but the test failed at random places. How can I rekick this build?
, Hi Ryan, any updates regarding your patch?, [~nerdyyatrice] ping, Sorry, didn't follow this after my previous submission got stuck. Just kicked another round and still not sure what's next., Github user hanm commented on the issue:

    https://github.com/apache/zookeeper/pull/167
  
    ZOOKEEPER-2684 kick jenkins bot
, Github user hanm commented on the issue:

    https://github.com/apache/zookeeper/pull/167
  
    @nerdyyatrice I don't see Jenkins pre-commit build is kicked off for your patch. I think a combination of these should kick the build bot:
    * Put string "ZOOKEEPER-2684" in pull request title. The bot running a script that looks for JIRA number.
    * And, after update title, close and reopen this pull request. This should again trigger a pre-commit build.
    Do you mind do these so we can sign off this pull request from jenkins?
, Github user nerdyyatrice closed the pull request at:

    https://github.com/apache/zookeeper/pull/167
, GitHub user nerdyyatrice reopened a pull request:

    https://github.com/apache/zookeeper/pull/167

    ZOOKEEPER-2684 commitProcessor does not crash when an unseen commit somes

    commitProcessor with the zookeeper-2024 improvement patch throws an exception when it sees a commit request that is not at the queue head.  It turned out that it is actually a valid case when there is session movement. After discussion with the community, I submit this pull request to mitigate this issue by passing those commits to the next processor instead.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/nerdyyatrice/zookeeper zookeeper-2684

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/zookeeper/pull/167.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #167
    
----
commit 423e385038d055b034a71e91a503ff31532e84a2
Author: rzhang <rzhang@twitter.com>
Date:   2017-02-10T01:33:23Z

    commitProcessor does not crash when an unseen commit somes

commit cde12800a4ddecce26d41a4870cd19ae8d7e6f15
Author: rzhang <rzhang@twitter.com>
Date:   2017-02-10T02:24:19Z

    commitProcessor does not crash when an unseen commit somes

commit 0f7c2e815c3744d8088f12b6e802365ab164ff9a
Author: rzhang <rzhang@twitter.com>
Date:   2017-02-16T20:53:56Z

    remove the exception in the commit processor as commit requests can arrive out of order in terms of CXid

commit d80b715620bbbef173be4acbeb022892ff13934d
Author: rzhang <rzhang@twitter.com>
Date:   2017-02-16T20:59:34Z

    Merge branch 'zookeeper-2684' of https://github.com/nerdyyatrice/zookeeper into zookeeper-2684

commit 61f4764b51c92d93cdf5b63ab617efa41e1ee44c
Author: rzhang <rzhang@twitter.com>
Date:   2017-02-16T23:45:06Z

    adjust the test and to re-kick the submit

commit 5191fa83eb88967e91fc7df4c18a106369b0dd0c
Author: rzhang <rzhang@twitter.com>
Date:   2017-04-21T00:18:51Z

     ZOOKEEPER-2684: Fix a crashing bug in the mixed workloads commit processor

commit fde3b0eba781361e5775445ecc6cfd20efe71f05
Author: rzhang <rzhang@twitter.com>
Date:   2017-04-21T22:38:07Z

    ZOOKEEPER-2684: Fix a crashing bug in the mixed workloads commit processor

----
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/739//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/739//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/739//console

This message is automatically generated., Github user hanm commented on the issue:

    https://github.com/apache/zookeeper/pull/167
  
    @nerdyyatrice I see you've closed / reopened this PR, and the build bot is kicked off as expected.  There is the same test failure in pre-commit build: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/739/testReport/junit/org.apache.zookeeper.server.quorum/CommitProcessorConcurrencyTest/noCrashOnCommittedRequestsOfUnSeenRequestTest/. We should get this fixed before merging this PR.
    
    I'll try reviewing this patch in detail to understand what goes wrong here.
, Github user nerdyyatrice commented on the issue:

    https://github.com/apache/zookeeper/pull/167
  
    I can’t repro it on my laptop so I tried to see if it can pass on the machine. I will look into code in more detail. 
    
    > On May 23, 2017, at 9:15 PM, Michael Han <notifications@github.com> wrote:
    > 
    > @nerdyyatrice <https://github.com/nerdyyatrice> I see you've closed / reopened this PR, and the build bot is kicked off as expected. There is the same test failure in pre-commit build: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/739/testReport/junit/org.apache.zookeeper.server.quorum/CommitProcessorConcurrencyTest/noCrashOnCommittedRequestsOfUnSeenRequestTest/ <https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/739/testReport/junit/org.apache.zookeeper.server.quorum/CommitProcessorConcurrencyTest/noCrashOnCommittedRequestsOfUnSeenRequestTest/>. We should get this fixed before merging this PR.
    > 
    > I'll try reviewing this patch in detail to understand what goes wrong here.
    > 
    > —
    > You are receiving this because you were mentioned.
    > Reply to this email directly, view it on GitHub <https://github.com/apache/zookeeper/pull/167#issuecomment-303613061>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ALGPjMle9unhxIR4OqgDteDFY_uCDzcLks5r867ygaJpZM4L85T6>.
    > 
    

, Github user fpj commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/167#discussion_r121006265
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -254,24 +254,23 @@ public void run() {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // we can get commit requests that is not at the queue head when 
    +                            // session moves (see ZOOKEEPER-2684). We will just pass the 
    +                            // commit to the next processor and put the pending back with
    +                            // a warning, we should not see this often under normal load
    +                            LOG.warn("Got request " + request + 
    +                                " but we are expecting request " + topPending);
    +                            sessionQueue.addFirst(topPending);
    +                        } else {                            
    --- End diff --
    
    Is it the case that for a given session, once we execute the else block once, executing the if block would be incorrect? If so, would it make sense to have a flag per session indicating that the else block has not been executed for the session? It might not even be a flag per session, but perhaps a set of session ids instead that we remove from once we execute the else block.   
, GitHub user kfirlevari opened a pull request:

    https://github.com/apache/zookeeper/pull/411

    ZOOKEEPER-2684 Fix a crashing bug in the mixed workloads commit processor

    We wish to fix this long-standing issue in the code.
    Note that the previous commit processor algorithm had the same approach (as the one suggested in this fix) when dealing with a request that has a different cxid than session's expected one (see [here](https://github.com/apache/zookeeper/commit/9fc632c4f0a340b0a00ec6dff39c7b454c802822#diff-5cc688a027068714af01b0ad4d292fe5L238)).
    
    This fix is based on the code from https://github.com/apache/zookeeper/pull/167, following the discussion in https://issues.apache.org/jira/browse/ZOOKEEPER-2684 .

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/kfirlevari/zookeeper ZOOKEEPER-2684

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/zookeeper/pull/411.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #411
    
----
commit 7e67982430d1f88fc50a6e60aceb168851a4c88c
Author: Kfir Lev-Ari <klevari@apple.com>
Date:   2017-10-30T10:29:58Z

    ZOOKEEPER-2684 Fix a crashing bug in the mixed workloads commit processor

----
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1126//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1126//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1126//console

This message is automatically generated., Github user kfirlevari commented on the issue:

    https://github.com/apache/zookeeper/pull/411
  
    The build failed because _testNodeDataChanged_ failed (a test that doesn't seem related to the current change). 
    It seems like zk2.create at line 122 ([WatchEventWhenAutoResetTest.java](https://github.com/apache/zookeeper/blob/master/src/java/test/org/apache/zookeeper/test/WatchEventWhenAutoResetTest.java#L122)) is taking too long, and therefore we receive the NodeDeleted event instead of the expected NodeDataChanged (locally on my machine it didn't fail). I guess adding some kind of sleep prior to line 124 should solve this issue?
, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/411
  
    @kfirlevari yeah, that's an outstanding flaky test.
    Here's the jira about it: https://issues.apache.org/jira/browse/ZOOKEEPER-2807
    
    Amend your latest commit to trigger another Jenkins build.
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1130//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1130//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1130//console

This message is automatically generated., Github user shralex commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r147854385
  
    --- Diff: src/java/test/org/apache/zookeeper/server/quorum/CommitProcessorConcurrencyTest.java ---
    @@ -376,4 +377,123 @@ public void noStarvationOfReadRequestsTest() throws Exception {
                         !processedRequests.contains(r));
             }
         }
    +
    +    /**
    +     * In the following test, we verify that we can handle the case that we got a commit
    +     * of a request we never seen since the session that we just established. This can happen
    +     * when a session is just established and there is request waiting to be committed in the
    +     * in the session queue but it sees a commit for a request that belongs to the previous connection.
    +     */
    +    @Test(timeout = 1000)
    +    public void noCrashOnCommittedRequestsOfUnseenRequestTest() throws Exception {
    +        final String path = "/noCrash/OnCommittedRequests/OfUnseenRequestTest";
    +        final int numberofReads = 10;
    +        final int sessionid = 0x123456;
    +        final int firstCXid = 0x100;
    +        int readReqId = firstCXid;
    +        processor.stoppedMainLoop = true;
    +        HashSet<Request> localRequests = new HashSet<Request>();
    +        // queue the blocking write request to queuedRequests
    +        Request firstCommittedReq = newRequest(
    +                new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE,
    +                        CreateMode.PERSISTENT_SEQUENTIAL.toFlag()),
    +                OpCode.create, sessionid, readReqId++);
    +        processor.queuedRequests.add(firstCommittedReq);
    +        localRequests.add(firstCommittedReq);
    +
    +        // queue read requests to queuedRequests
    +        for (; readReqId <= numberofReads+firstCXid; ++readReqId) {
    +            Request readReq = newRequest(new GetDataRequest(path, false),
    +                    OpCode.getData, sessionid, readReqId);
    +            processor.queuedRequests.add(readReq);
    +            localRequests.add(readReq);
    +        }
    +
    +        //run once
    +        Assert.assertTrue(processor.queuedRequests.containsAll(localRequests));
    +        processor.initThreads(numberofReads* 2);
    +        processor.run();
    +
    +        //We verify that the processor is waiting for the commit
    +        Assert.assertTrue(processedRequests.isEmpty());
    +
    +        // We add a commit that belongs to the same session but with smaller cxid,
    +        // i.e., commit of an update from previous connection of this session.
    +        Request preSessionCommittedReq = newRequest(
    +                new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE,
    +                        CreateMode.PERSISTENT_SEQUENTIAL.toFlag()),
    +                OpCode.create, sessionid, firstCXid - 2);
    +        processor.committedRequests.add(preSessionCommittedReq);
    +        processor.committedRequests.add(firstCommittedReq);
    +        processor.run();
    +
    +        //We verify that the commit processor processed the old commit prior to the newer messages
    +        Assert.assertTrue(processedRequests.peek() == preSessionCommittedReq);
    +
    +        processor.run();
    +
    +        //We verify that the commit processor handle all messages.
    +        Assert.assertTrue(processedRequests.containsAll(localRequests));
    +    }
    +
    +    /**
    +     * In the following test, we verify if we handle the case in which we get a commit
    +     * for a request that has higher Cxid than the one we are waiting. This can happen
    +     * when a session connection is lost but there is a request waiting to be committed in the
    +     * session queue. However, since the session has moved, new requests can get to
    +     * the leader out of order. Hence, the commits can also arrive "out of order" w.r.t. cxid.
    +     * We should commit the requests according to the order we receive from the leader, i.e., wait for the relevant commit.
    --- End diff --
    
    1) I think its worth while explaining the two scenarios in the CommitProcessor.java comments. I mean how its possible to get higher cxid and lower cxid from leader compared to what you expect. Including the part where requests may reach the leader out of cxid order if session is moved. 
    
    2) I wonder if in this case (receiving higher cxid from leader) we should also empty the local pending requests ? What's the value of keeping the requests in the local queue ?
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r147883484
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -255,24 +255,23 @@ public void run() {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // we can get commit requests that are not at the queue head after
    +                            // a session moved (see ZOOKEEPER-2684). We will just pass the
    +                            // commit to the next processor and put the pending back with
    +                            // a warning, we should not see this often under normal load
    +                            LOG.warn("Got request " + request +
    +                                    " but we are expecting request " + topPending);
    +                            sessionQueue.addFirst(topPending);
    +                        } else {
    +                            /*
    +                             * We want to send our version of the request. the
    +                             * pointer to the connection in the request
    +                             */
    +                            topPending.setHdr(request.getHdr());
    --- End diff --
    
    Would you mind explaining why we normally want to send our version of the request and why it is ok not to in this case?
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r147854977
  
    --- Diff: src/java/test/org/apache/zookeeper/server/quorum/CommitProcessorConcurrencyTest.java ---
    @@ -376,4 +377,123 @@ public void noStarvationOfReadRequestsTest() throws Exception {
                         !processedRequests.contains(r));
             }
         }
    +
    +    /**
    +     * In the following test, we verify that we can handle the case that we got a commit
    +     * of a request we never seen since the session that we just established. This can happen
    +     * when a session is just established and there is request waiting to be committed in the
    +     * in the session queue but it sees a commit for a request that belongs to the previous connection.
    --- End diff --
    
    typo: "in the in the"
, Github user kfirlevari commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148014302
  
    --- Diff: src/java/test/org/apache/zookeeper/server/quorum/CommitProcessorConcurrencyTest.java ---
    @@ -376,4 +377,123 @@ public void noStarvationOfReadRequestsTest() throws Exception {
                         !processedRequests.contains(r));
             }
         }
    +
    +    /**
    +     * In the following test, we verify that we can handle the case that we got a commit
    +     * of a request we never seen since the session that we just established. This can happen
    +     * when a session is just established and there is request waiting to be committed in the
    +     * in the session queue but it sees a commit for a request that belongs to the previous connection.
    +     */
    +    @Test(timeout = 1000)
    +    public void noCrashOnCommittedRequestsOfUnseenRequestTest() throws Exception {
    +        final String path = "/noCrash/OnCommittedRequests/OfUnseenRequestTest";
    +        final int numberofReads = 10;
    +        final int sessionid = 0x123456;
    +        final int firstCXid = 0x100;
    +        int readReqId = firstCXid;
    +        processor.stoppedMainLoop = true;
    +        HashSet<Request> localRequests = new HashSet<Request>();
    +        // queue the blocking write request to queuedRequests
    +        Request firstCommittedReq = newRequest(
    +                new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE,
    +                        CreateMode.PERSISTENT_SEQUENTIAL.toFlag()),
    +                OpCode.create, sessionid, readReqId++);
    +        processor.queuedRequests.add(firstCommittedReq);
    +        localRequests.add(firstCommittedReq);
    +
    +        // queue read requests to queuedRequests
    +        for (; readReqId <= numberofReads+firstCXid; ++readReqId) {
    +            Request readReq = newRequest(new GetDataRequest(path, false),
    +                    OpCode.getData, sessionid, readReqId);
    +            processor.queuedRequests.add(readReq);
    +            localRequests.add(readReq);
    +        }
    +
    +        //run once
    +        Assert.assertTrue(processor.queuedRequests.containsAll(localRequests));
    +        processor.initThreads(numberofReads* 2);
    +        processor.run();
    +
    +        //We verify that the processor is waiting for the commit
    +        Assert.assertTrue(processedRequests.isEmpty());
    +
    +        // We add a commit that belongs to the same session but with smaller cxid,
    +        // i.e., commit of an update from previous connection of this session.
    +        Request preSessionCommittedReq = newRequest(
    +                new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE,
    +                        CreateMode.PERSISTENT_SEQUENTIAL.toFlag()),
    +                OpCode.create, sessionid, firstCXid - 2);
    +        processor.committedRequests.add(preSessionCommittedReq);
    +        processor.committedRequests.add(firstCommittedReq);
    +        processor.run();
    +
    +        //We verify that the commit processor processed the old commit prior to the newer messages
    +        Assert.assertTrue(processedRequests.peek() == preSessionCommittedReq);
    +
    +        processor.run();
    +
    +        //We verify that the commit processor handle all messages.
    +        Assert.assertTrue(processedRequests.containsAll(localRequests));
    +    }
    +
    +    /**
    +     * In the following test, we verify if we handle the case in which we get a commit
    +     * for a request that has higher Cxid than the one we are waiting. This can happen
    +     * when a session connection is lost but there is a request waiting to be committed in the
    +     * session queue. However, since the session has moved, new requests can get to
    +     * the leader out of order. Hence, the commits can also arrive "out of order" w.r.t. cxid.
    +     * We should commit the requests according to the order we receive from the leader, i.e., wait for the relevant commit.
    --- End diff --
    
    Regarding 2 - I've answered the question also in the new comments. I think we shouldn't empty the queue because it is possible that the session returned to us (i.e., moved back). It does no harm to keep the old requests, given that the cnxn handle in the old request shows that the old connection is closed.
, Github user kfirlevari commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148014452
  
    --- Diff: src/java/test/org/apache/zookeeper/server/quorum/CommitProcessorConcurrencyTest.java ---
    @@ -376,4 +377,123 @@ public void noStarvationOfReadRequestsTest() throws Exception {
                         !processedRequests.contains(r));
             }
         }
    +
    +    /**
    +     * In the following test, we verify that we can handle the case that we got a commit
    +     * of a request we never seen since the session that we just established. This can happen
    +     * when a session is just established and there is request waiting to be committed in the
    +     * in the session queue but it sees a commit for a request that belongs to the previous connection.
    --- End diff --
    
    Fixed
, Github user kfirlevari commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148014638
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -255,24 +255,23 @@ public void run() {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // we can get commit requests that are not at the queue head after
    +                            // a session moved (see ZOOKEEPER-2684). We will just pass the
    +                            // commit to the next processor and put the pending back with
    +                            // a warning, we should not see this often under normal load
    +                            LOG.warn("Got request " + request +
    +                                    " but we are expecting request " + topPending);
    +                            sessionQueue.addFirst(topPending);
    +                        } else {
    +                            /*
    +                             * We want to send our version of the request. the
    +                             * pointer to the connection in the request
    +                             */
    +                            topPending.setHdr(request.getHdr());
    --- End diff --
    
    I added an explanation, let me know if you meant something more specific. 
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    -1 contrib tests.  The patch failed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1133//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1133//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1133//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1134//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1134//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1134//console

This message is automatically generated., +1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1131//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1131//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1131//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    -1 contrib tests.  The patch failed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1135//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1135//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1135//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1136//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1136//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1136//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1132//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1132//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1132//console

This message is automatically generated., Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148115810
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -246,33 +246,51 @@ public void run() {
                         }
     
                         /*
    -                     * Check if request is pending, if so, update it with the
    -                     * committed info
    +                     * Check if request is pending, if so, update it with the committed info
                          */
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // TL;DR - we should not encounter this scenario often under normal load.
    +                            // We pass the commit to the next processor and put the pending back with a warning.
    +
    +                            // Generally, we can get commit requests that are not at the queue head after
    +                            // a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    +                            // with A, and the server that the session moved to with B (keep in mind that it is
    +                            // possible that the session already moved from B to a new server C, and maybe C=A).
    +                            // 1. If request.cxid < topPending.cxid : this means that the session requested this update
    +                            // from A, then moved to B (i.e., which is us), and now B receives the commit
    +                            // for the update after the session already performed several operations in B
    +                            // (and therefore its cxid is higher than that old request).
    +                            // 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    +                            // from B with cxid that is bigger than the one we know therefore in this case we
    +                            // are A, and we lost the connection to the session. Given that we are waiting for a commit
    +                            // for that update, it means that we already sent the request to the leader and it will
    +                            // be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    +                            // is an increasing order). It is not safe for us to delete the session's queue at this
    +                            // point, since it is possible that the session has newer requests in it after it moved
    +                            // back to us. We just leave the queue as it is, and once the commit arrives (for the old
    +                            // request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    +                            // response.
    +                            // Also note that we don't have a local session, therefore we treat the request
    +                            // like any other commit for a remote request, i.e., we perform the update without sending
    +                            // a response.
    +
    +                            LOG.warn("Got request " + request +
    +                                    " but we are expecting request " + topPending);
    +                            sessionQueue.addFirst(topPending);
    +                        } else {
    +                            // We want to send to the next processor our version of the request,
    +                            // since it contains the session information that is needed
    +                            // for post update processing (e.g., using request.cnxn we send a response to the client).
    +                            topPending.setHdr(request.getHdr());
    --- End diff --
    
    The explanation is really great. I was also hoping you could shed some light on this part of the code. Why do we "want to send to the next processor our version of the request" and why can we proceed in the other case if this is required here?
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148113899
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -246,33 +246,51 @@ public void run() {
                         }
     
                         /*
    -                     * Check if request is pending, if so, update it with the
    -                     * committed info
    +                     * Check if request is pending, if so, update it with the committed info
                          */
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // TL;DR - we should not encounter this scenario often under normal load.
    --- End diff --
    
    I hate to be "that guy" but we generally use "/*" comments for long blocks like this.
, Github user shralex commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148117464
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -246,33 +246,51 @@ public void run() {
                         }
     
                         /*
    -                     * Check if request is pending, if so, update it with the
    -                     * committed info
    +                     * Check if request is pending, if so, update it with the committed info
                          */
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // TL;DR - we should not encounter this scenario often under normal load.
    +                            // We pass the commit to the next processor and put the pending back with a warning.
    +
    +                            // Generally, we can get commit requests that are not at the queue head after
    +                            // a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    +                            // with A, and the server that the session moved to with B (keep in mind that it is
    +                            // possible that the session already moved from B to a new server C, and maybe C=A).
    +                            // 1. If request.cxid < topPending.cxid : this means that the session requested this update
    +                            // from A, then moved to B (i.e., which is us), and now B receives the commit
    +                            // for the update after the session already performed several operations in B
    +                            // (and therefore its cxid is higher than that old request).
    +                            // 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    +                            // from B with cxid that is bigger than the one we know therefore in this case we
    +                            // are A, and we lost the connection to the session. Given that we are waiting for a commit
    +                            // for that update, it means that we already sent the request to the leader and it will
    +                            // be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    +                            // is an increasing order). It is not safe for us to delete the session's queue at this
    +                            // point, since it is possible that the session has newer requests in it after it moved
    +                            // back to us. We just leave the queue as it is, and once the commit arrives (for the old
    +                            // request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    +                            // response.
    +                            // Also note that we don't have a local session, therefore we treat the request
    +                            // like any other commit for a remote request, i.e., we perform the update without sending
    +                            // a response.
    +
    +                            LOG.warn("Got request " + request +
    +                                    " but we are expecting request " + topPending);
    +                            sessionQueue.addFirst(topPending);
    +                        } else {
    +                            // We want to send to the next processor our version of the request,
    +                            // since it contains the session information that is needed
    +                            // for post update processing (e.g., using request.cnxn we send a response to the client).
    +                            topPending.setHdr(request.getHdr());
    --- End diff --
    
    My understanding is that when a request is in the local queue, there is (or could be) a client attached to this server waiting for a response, and there is other bookeeping of requests that are outstanding and have originated from this server (e.g., for setting the max outstanding requests) - we need to update this info when an outstanding request completes. In the other case, the operation originated from a different server and there is no local bookeeeping or a local client session that needs to be notified. 
, +1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1137//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1137//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1137//console

This message is automatically generated., Github user kfirlevari commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148119207
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -246,33 +246,51 @@ public void run() {
                         }
     
                         /*
    -                     * Check if request is pending, if so, update it with the
    -                     * committed info
    +                     * Check if request is pending, if so, update it with the committed info
                          */
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // TL;DR - we should not encounter this scenario often under normal load.
    --- End diff --
    
    NP ;)
, +1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1138//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1138//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1138//console

This message is automatically generated., Github user kfirlevari commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/411#discussion_r148119340
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -246,33 +246,51 @@ public void run() {
                         }
     
                         /*
    -                     * Check if request is pending, if so, update it with the
    -                     * committed info
    +                     * Check if request is pending, if so, update it with the committed info
                          */
                         LinkedList<Request> sessionQueue = pendingRequests
                                 .get(request.sessionId);
                         if (sessionQueue != null) {
                             // If session queue != null, then it is also not empty.
                             Request topPending = sessionQueue.poll();
                             if (request.cxid != topPending.cxid) {
    -                            LOG.error(
    -                                    "Got cxid 0x"
    -                                            + Long.toHexString(request.cxid)
    -                                            + " expected 0x" + Long.toHexString(
    -                                                    topPending.cxid)
    -                                    + " for client session id "
    -                                    + Long.toHexString(request.sessionId));
    -                            throw new IOException("Error: unexpected cxid for"
    -                                    + "client session");
    +                            // TL;DR - we should not encounter this scenario often under normal load.
    +                            // We pass the commit to the next processor and put the pending back with a warning.
    +
    +                            // Generally, we can get commit requests that are not at the queue head after
    +                            // a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    +                            // with A, and the server that the session moved to with B (keep in mind that it is
    +                            // possible that the session already moved from B to a new server C, and maybe C=A).
    +                            // 1. If request.cxid < topPending.cxid : this means that the session requested this update
    +                            // from A, then moved to B (i.e., which is us), and now B receives the commit
    +                            // for the update after the session already performed several operations in B
    +                            // (and therefore its cxid is higher than that old request).
    +                            // 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    +                            // from B with cxid that is bigger than the one we know therefore in this case we
    +                            // are A, and we lost the connection to the session. Given that we are waiting for a commit
    +                            // for that update, it means that we already sent the request to the leader and it will
    +                            // be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    +                            // is an increasing order). It is not safe for us to delete the session's queue at this
    +                            // point, since it is possible that the session has newer requests in it after it moved
    +                            // back to us. We just leave the queue as it is, and once the commit arrives (for the old
    +                            // request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    +                            // response.
    +                            // Also note that we don't have a local session, therefore we treat the request
    +                            // like any other commit for a remote request, i.e., we perform the update without sending
    +                            // a response.
    +
    +                            LOG.warn("Got request " + request +
    +                                    " but we are expecting request " + topPending);
    +                            sessionQueue.addFirst(topPending);
    +                        } else {
    +                            // We want to send to the next processor our version of the request,
    +                            // since it contains the session information that is needed
    +                            // for post update processing (e.g., using request.cnxn we send a response to the client).
    +                            topPending.setHdr(request.getHdr());
    --- End diff --
    
    Updated accordingly
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1141//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1141//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1141//console

This message is automatically generated., +1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1143//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1143//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1143//console

This message is automatically generated., +1 

Thanks a lot, Kfir, LGTM
, Github user asfgit closed the pull request at:

    https://github.com/apache/zookeeper/pull/411
]