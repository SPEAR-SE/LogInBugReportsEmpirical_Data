[Let me put together a patch for what I'm thinking (which is, admittedly, based on my assumptions for why the synchronization works as it does -- not based on truth :)), A few more clarifications:

* I observed this from concurrent {{stat}} commands, but I believe the same could happen with an intermingling of {{stat}} and {{cons}} commands.
* This appears to only affect the Netty server. I didn't see a similar execution path on the NIO side which would have the same bug., Was able to repro this locally with multiple instances of the following one-liner:

{noformat}
while true; do echo stat | nc localhost 2181 >/dev/null 2>&1; echo -n .; sleep 3; done
{noformat}, GitHub user joshelser opened a pull request:

    https://github.com/apache/zookeeper/pull/186

    ZOOKEEPER-2711 Avoid synchronization on NettyServerCnxn in Factory

    NettyServerCnxnFactory previously synchronized on the (Netty)ServerCnxn
    object to provide mutual exclusion at the RPC layer. However, this was
    at odds with the synchronized methods in ServerCnxn (which shared the
    same monitor). As such, it was possible to deadlock between concurrent
    4LW commands that were invoking one of these synchronized methods
    on ServerCnxn.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/joshelser/zookeeper 2711-4lw

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/zookeeper/pull/186.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #186
    
----
commit 9953e32963e6167f88b97519233b0872cce69a71
Author: Josh Elser <elserj@apache.org>
Date:   2017-03-07T21:03:57Z

    ZOOKEEPER-2711 Avoid synchronization on NettyServerCnxn in Factory
    
    NettyServerCnxnFactory previously synchronized on the (Netty)ServerCnxn
    object to provide mutual exclusion at the RPC layer. However, this was
    at odds with the synchronized methods in ServerCnxn (which shared the
    same monitor). As such, it was possible to deadlock between concurrent
    4LW commands that were invoking one of these synchronized methods
    on ServerCnxn.

----
, Github user joshelser commented on the issue:

    https://github.com/apache/zookeeper/pull/186
  
    I need to see if I can come up with a unit test to catch this case, but I'm not sure how useful one would be (I think anything I come up with would be a bit contrived..)
    
    I was able to test this locally by running 7 iterations of:
    
    ```bash
    while true; do echo stat | nc localhost 2181 >/dev/null 2>&1; echo -n .; sleep 1; done
    ```
    
    while generating some extra load (heavy java tests from another ASF project, *winks*) on my local machine. This ran for ~10minutes without error.
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +0 tests included.  The patch appears to be a documentation patch that doesn't require tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/388//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/388//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/388//console

This message is automatically generated., Github user keith-turner commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/186#discussion_r104790720
  
    --- Diff: src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java ---
    @@ -162,7 +162,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                                 + " from " + ctx.getChannel());
                     }
                     NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
    -                synchronized(cnxn) {
    +                synchronized(cnxn.getRpcLock()) {
                         processMessage(e, cnxn);
    --- End diff --
    
    Now one thread can be in processMessage while another thread is getting stats about the connection.  Is that ok?  
    
    Do you know if anything else besides ServerCnxn is synchronizing on its monitor?  Basically I am wondering if there is any other code out there that should now sync on what getRpcLock() returns.
, Github user joshelser commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/186#discussion_r104792592
  
    --- Diff: src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java ---
    @@ -162,7 +162,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                                 + " from " + ctx.getChannel());
                     }
                     NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
    -                synchronized(cnxn) {
    +                synchronized(cnxn.getRpcLock()) {
                         processMessage(e, cnxn);
    --- End diff --
    
    > Now one thread can be in processMessage while another thread is getting stats about the connection. Is that ok?
    
    I believe this is OK. We can receive two concurrent `stat` commands, but we only process one of them at a time. I'm also not a Netty wizard, so I could be wildly wrong :)
    
    > Basically I am wondering if there is any other code out there that should now sync on what getRpcLock() returns.
    
    That's a good point. I had looked to see that there were multiple other methods in `ServerCnxn` which were also synchronized (thus, changing `dumpConnectionInfo(..)` wouldn't have been sufficient). I didn't look to see if there's another code-path which is also synchronizing on the `NettyServerCnxn` (or `ServerCnxn`).
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/186#discussion_r105297517
  
    --- Diff: src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java ---
    @@ -162,7 +162,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                                 + " from " + ctx.getChannel());
                     }
                     NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
    -                synchronized(cnxn) {
    +                synchronized(cnxn.getRpcLock()) {
                         processMessage(e, cnxn);
    --- End diff --
    
    > Now one thread can be in processMessage while another thread is getting stats about the connection. Is that ok?
    >> I believe this is OK. We can receive two concurrent stat commands, but we only process one of them at a time. I'm also not a Netty wizard, so I could be wildly wrong :)
    I'm not sure I agree with this. Since the results output by the stat command are no longer guaranteed to represent one single instance in time. 
    
    Would it be possible to put a shared lock on the command's execution (shared with any other 4LW that acquires a lock on a connection other than its own, I THINK `cons` is the only other one)?
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/186#discussion_r105300714
  
    --- Diff: src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java ---
    @@ -162,7 +162,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                                 + " from " + ctx.getChannel());
                     }
                     NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
    -                synchronized(cnxn) {
    +                synchronized(cnxn.getRpcLock()) {
                         processMessage(e, cnxn);
    --- End diff --
    
    >> Now one thread can be in processMessage while another thread is getting stats about the connection. Is that ok?
    
    > I believe this is OK. We can receive two concurrent stat commands, but we only process one of them at a time. I'm also not a Netty wizard, so I could be wildly wrong :)
    
    This should be OK since all fields printed by `synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief)` are only updated in `synchronized` methods.
    
    Another option would be to put a shared lock on the command's execution (shared with any other 4LW that acquires a lock on a connection other than its own, I THINK `cons` is the only other one)? I think this may impact 4LW performance slightly but it would prevent the need to add another lock to `NettyServerCnxn`. 
    
    I think I like your way better.
, Github user joshelser commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/186#discussion_r105444315
  
    --- Diff: src/java/main/org/apache/zookeeper/server/NettyServerCnxnFactory.java ---
    @@ -162,7 +162,7 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
                                 + " from " + ctx.getChannel());
                     }
                     NettyServerCnxn cnxn = (NettyServerCnxn)ctx.getAttachment();
    -                synchronized(cnxn) {
    +                synchronized(cnxn.getRpcLock()) {
                         processMessage(e, cnxn);
    --- End diff --
    
    > I think I like your way better. Although it may be a good idea to have a comment next to RPC_LOCK pointing to the JIRA
    
    Totally agree there :) 
, Github user joshelser commented on the issue:

    https://github.com/apache/zookeeper/pull/186
  
    Also, I'll try to take a look at the test failures over the weekend and try to come up with a unit test as well.
, Github user joshelser commented on the issue:

    https://github.com/apache/zookeeper/pull/186
  
    Rebased the changes on top of master. f127aab is the same, 854e48e adds a comment and a (hopefully not contrived) unit test.
, +1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 2 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/405//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/405//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/405//console

This message is automatically generated.]