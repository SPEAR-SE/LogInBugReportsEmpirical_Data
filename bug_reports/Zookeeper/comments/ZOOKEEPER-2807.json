[GitHub user afine opened a pull request:

    https://github.com/apache/zookeeper/pull/300

    ZOOKEEPER-2807: Flaky test: org.apache.zookeeper.test.WatchEventWhenAutoResetTest.testNodeDataChanged

    This failure appears to be related to ZOOKEEPER-2024. When a follower is syncing with the leader and logging "the stuff that came in between the snapshot and the uptodate" we do not wait for those commits to hit the db before starting the follower.
    
    In 3.6, we now have two separate queues in the CommitProcessor, it is possible that the follower can serve requests before all of the commits from the leader have been applied. In the case of this test failure we can set a watch in between a create and delete call. This patch makes sure that the "delete" call will be committed before attempting to handle a client's watcher request.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/afine/zookeeper ZOOKEEPER-2807

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/zookeeper/pull/300.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #300
    
----
commit ca1774dca59d7a1c9e1d9e3c8391d21cf8c2c733
Author: Abraham Fine <afine@apache.org>
Date:   2017-06-30T22:44:26Z

    ZOOKEEPER-2807: Flaky test: org.apache.zookeeper.test.WatchEventWhenAutoResetTest.testNodeDataChanged

----
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +0 tests included.  The patch appears to be a documentation patch that doesn't require tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 2 new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/846//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/846//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/846//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

     1 @author.  The patch does not contain any @author tags.

     0 tests included.  The patch appears to be a documentation patch that doesn't require tests.

     1 javadoc.  The javadoc tool did not generate any warning messages.

     1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    -1 findbugs.  The patch appears to introduce 3 new Findbugs (version 3.0.1) warnings.

     1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

     1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/865//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/865//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/865//console

This message is automatically generated., Hi Abraham,

From your explanation on Github, I understand the problem (changes synced from the leader are not applied to DB before follower starts processing ops), but I don't understand the relationship with CommitProcessor or what the idea of the fix is. Could you please explain ? 

Moreover, I would REALLY prefer not to refactor the CommitProcessor. It took a while to tune it to achieve good performance and I'm worried that refactoring will have a performance effect. Also, there is a pending patch that needs to be committed in that code, ZOOKEEPER-2684.

[~breed], I think you mentioned a similar issue. Is this related ? Do you have a fix or an idea for a fix ?

Thanks
Alex, -1 overall.  GitHub Pull Request  Build
      

     1 @author.  The patch does not contain any @author tags.

     1 tests included.  The patch appears to include 3 new or modified tests.

     1 javadoc.  The javadoc tool did not generate any warning messages.

     1 javac.  The applied patch does not increase the total number of javac compiler warnings.

     1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

     1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

     1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/867//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/867//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/867//console

This message is automatically generated., [~shralex] So my understanding is that one of the major changes to the commit processor introduced in ZOOKEEPER-2024 is to change the main "run loop" of the CommitProcessor from processing all of the `committedRequests` queue on each iteration to processing only "a single committed request" (in order to prevent starvation I imagine).

So I believe this change substantially increases the probability that there will be new incoming requests in `queuedRequests` processed before older requests in`committedRequests`. This is generally fine, except when catching up to a leader. This patch adds a mechanism to make wait until `committedRequests` has been "drained" before we start "following". This way we know that all commits from the leader are applied to the DB before we begin handling incoming requests. 

I'm pretty confident that my patch will not have a real performance impact since the code path is unchanged unless there is 1 entry in committedRequests.

I need some time to take a look at ZOOKEEPER-2684, grok whats going on, and see if it has anything to do with the fix here., ZOOKEEPER-2684 is unrelated, but but also makes changes to the same file.

Intuitively this may not be the right place for such a fix - this probably should be higher level - making sure that follower does not even accept local ops before properly completing the sync. Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive. 

I think @breed may have a solution for this problem, lets wait for him to comment., [~breed] can you take a look?, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1110//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1110//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1110//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    -1 contrib tests.  The patch failed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1287//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1287//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1287//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1288//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1288//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1288//console

This message is automatically generated., -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1289//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1289//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1289//console

This message is automatically generated., Github user anmolnar commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/300#discussion_r154363054
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -327,6 +257,95 @@ public void run() {
             LOG.info("CommitProcessor exited loop!");
         }
     
    +    private void processCommittedRequest() throws IOException, InterruptedException {
    +        // In case of a spurious wakeup in waitForCommittedRequests we should not
    +        // remove the request from the queue until it has been processed
    +        Request request = committedRequests.peek();
    +
    +        if (request == null) {
    +            committedRequests.poll();
    --- End diff --
    
    If request==null then the committedRequests queue is already empty. Why do need to poll() here?
    Could it be a small mistake and originally you wanted to poll() after the peek() was successful...?
, Github user anmolnar commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/300#discussion_r154367742
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -240,84 +240,14 @@ public void run() {
                         }
     
                         // Process committed head
    -                    if ((request = committedRequests.poll()) == null) {
    -                        throw new IOException("Error: committed head is null");
    -                    }
    -
    -                    /*
    -                     * Check if request is pending, if so, update it with the committed info
    -                     */
    -                    LinkedList<Request> sessionQueue = pendingRequests
    -                            .get(request.sessionId);
    -                    if (sessionQueue != null) {
    -                        // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            /*
    -                             * TL;DR - we should not encounter this scenario often under normal load.
    -                             * We pass the commit to the next processor and put the pending back with a warning.
    -                             *
    -                             * Generally, we can get commit requests that are not at the queue head after
    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    -                             * with A, and the server that the session moved to with B (keep in mind that it is
    -                             * possible that the session already moved from B to a new server C, and maybe C=A).
    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update
    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit
    -                             * for the update after the session already performed several operations in B
    -                             * (and therefore its cxid is higher than that old request).
    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    -                             * from B with cxid that is bigger than the one we know therefore in this case we
    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit
    -                             * for that update, it means that we already sent the request to the leader and it will
    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    -                             * is an increasing order). It is not safe for us to delete the session's queue at this
    -                             * point, since it is possible that the session has newer requests in it after it moved
    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old
    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    -                             * response.
    -                             * Also note that we don't have a local session, therefore we treat the request
    -                             * like any other commit for a remote request, i.e., we perform the update without sending
    -                             * a response.
    -                             */
    -                            LOG.warn("Got request " + request +
    -                                    " but we are expecting request " + topPending);
    -                            sessionQueue.addFirst(topPending);
    -                        } else {
    -                            /*
    -                             * Generally, we want to send to the next processor our version of the request,
    -                             * since it contains the session information that is needed for post update processing.
    -                             * In more details, when a request is in the local queue, there is (or could be) a client
    -                             * attached to this server waiting for a response, and there is other bookkeeping of
    -                             * requests that are outstanding and have originated from this server
    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an
    -                             * outstanding request completes. Note that in the other case (above), the operation
    -                             * originated from a different server and there is no local bookkeeping or a local client
    -                             * session that needs to be notified.
    -                             */
    -                            topPending.setHdr(request.getHdr());
    -                            topPending.setTxn(request.getTxn());
    -                            topPending.zxid = request.zxid;
    -                            request = topPending;
    -                        }
    -                    }
    -
    -                    sendToNextProcessor(request);
    -
    -                    waitForEmptyPool();
    -
    -                    /*
    -                     * Process following reads if any, remove session queue if
    -                     * empty.
    -                     */
    -                    if (sessionQueue != null) {
    -                        while (!stopped && !sessionQueue.isEmpty()
    -                                && !needCommit(sessionQueue.peek())) {
    -                            sendToNextProcessor(sessionQueue.poll());
    -                        }
    -                        // Remove empty queues
    -                        if (sessionQueue.isEmpty()) {
    -                            pendingRequests.remove(request.sessionId);
    +                    // We only need to perform synchronization if we are on the last request in the queue
    +                    if (committedRequests.size() == 1) {
    +                        synchronized (committedRequests) {
    --- End diff --
    
    Unfortunately I don't get why do you need to synchronise here. Would you please elaborate a little bit?
, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @afine Generally speaking, I like the idea of using LinkedBlockingQueue's intrinsic lock to wait for becoming empty, but in this particular case I think it's possible that committedRequests will never be empty if the leader is constantly sending commit requests.
    
    Correct me if I'm wrong please (there's a very good chance that I completely misunderstand something), but my feeling is that the following situation is possible:
    1. Learner starts syncing with leader in syncWithLeader() method,
    2. Learner blocks and wait for all commits to be processed before finishing the sync,
    3. FollowerZookeeperServer is already running and keep receiving commits from the Leader including non-syncing ones,
    4. Learner will never be notified or only at some point in the future much more later then sync complete or way before that.
    
    To address this, if we could get the number of commits that we must wait before proceeding, we would be able to implement a CountDownLatch in CommitProcessor and wait for the number of commits which are expected in the sync process. However that does not guarantee that we received all sync-related commits either.
    
    Otherwise I could also agree with @shralex in the Jira saying: "Intuitively this may not be the right place for such a fix - this probably should be higher level - **making sure that follower does not even accept local ops before properly completing the sync.** Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive."
    
    That would be the best solution here in my opinion.
, Github user afine commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    Thanks for taking a look @anmolnar!
    
    I'm confused by what you mean in item 3. Unless I am missing something, I don't understand how `FollowerZooKeeperServer` is "already running and keep receiving commits from the Leader including non-syncing ones" before `syncWithLeader` is completed.

, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @afine If I'm not mistaken there's a thread running which receives messages from the Leader in QuorumPeer.java:997:
    Call stack is:
    QuorumPeer.run() -> Follower.followLeader() -> Follower.processPacket() -> FollowerZookeeperServer.commit()
    This code path could potentially add more commit messages to the queue which are not related to the sync.
    
    Even if I'm wrong with the above, @shralex 's concern is still valid: "Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive."
    It's possible to drain the commit queue faster than leader sends messages.
    
    In other words: draining the commit queue doesn't seem to guarantee that the sync is complete.
, Github user afine commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @anmolnar With respect to the code path above, shouldn't that be blocked on `syncWithLeader`?
    
    > Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive.
    
    I'm not sure I understand how we don't have this guarantee. My understanding is that `syncWithLeader` loops until an `UPTODATE` message is received by the follower. Incoming packets from the leader are read by:
    ```java
                    syncWithLeader(newEpochZxid);                
                    QuorumPacket qp = new QuorumPacket();
                    while (this.isRunning()) {
                        readPacket(qp);
                        processPacket(qp);
                    }
    ```
    
    In addition, my understanding is that requests are only added to `CommitProcessor`'s `committedRequests` in `processPacket`. What am I missing?
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/300#discussion_r154786233
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -327,6 +257,95 @@ public void run() {
             LOG.info("CommitProcessor exited loop!");
         }
     
    +    private void processCommittedRequest() throws IOException, InterruptedException {
    +        // In case of a spurious wakeup in waitForCommittedRequests we should not
    +        // remove the request from the queue until it has been processed
    +        Request request = committedRequests.peek();
    +
    +        if (request == null) {
    +            committedRequests.poll();
    --- End diff --
    
    we don't
, -1 overall.  GitHub Pull Request  Build
      

    +1 @author.  The patch does not contain any @author tags.

    +1 tests included.  The patch appears to include 3 new or modified tests.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    -1 core tests.  The patch failed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1333//testReport/
Findbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1333//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1333//console

This message is automatically generated., Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @afine You're right. I missed that syncWithLeader() call is on the same path and in the same thread as adding commits to the queue.
    
    In which case this must be right:
    - syncWithLeader() blocks the follower, 
    - Leader sends commits for the sync process, 
    - Leader sends UPTODATE at the very end, 
    - Follower drains the commit queue
    - Follower starts following.
    

, Github user anmolnar commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/300#discussion_r154851878
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -240,84 +240,14 @@ public void run() {
                         }
     
                         // Process committed head
    -                    if ((request = committedRequests.poll()) == null) {
    -                        throw new IOException("Error: committed head is null");
    -                    }
    -
    -                    /*
    -                     * Check if request is pending, if so, update it with the committed info
    -                     */
    -                    LinkedList<Request> sessionQueue = pendingRequests
    -                            .get(request.sessionId);
    -                    if (sessionQueue != null) {
    -                        // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            /*
    -                             * TL;DR - we should not encounter this scenario often under normal load.
    -                             * We pass the commit to the next processor and put the pending back with a warning.
    -                             *
    -                             * Generally, we can get commit requests that are not at the queue head after
    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    -                             * with A, and the server that the session moved to with B (keep in mind that it is
    -                             * possible that the session already moved from B to a new server C, and maybe C=A).
    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update
    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit
    -                             * for the update after the session already performed several operations in B
    -                             * (and therefore its cxid is higher than that old request).
    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    -                             * from B with cxid that is bigger than the one we know therefore in this case we
    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit
    -                             * for that update, it means that we already sent the request to the leader and it will
    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    -                             * is an increasing order). It is not safe for us to delete the session's queue at this
    -                             * point, since it is possible that the session has newer requests in it after it moved
    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old
    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    -                             * response.
    -                             * Also note that we don't have a local session, therefore we treat the request
    -                             * like any other commit for a remote request, i.e., we perform the update without sending
    -                             * a response.
    -                             */
    -                            LOG.warn("Got request " + request +
    -                                    " but we are expecting request " + topPending);
    -                            sessionQueue.addFirst(topPending);
    -                        } else {
    -                            /*
    -                             * Generally, we want to send to the next processor our version of the request,
    -                             * since it contains the session information that is needed for post update processing.
    -                             * In more details, when a request is in the local queue, there is (or could be) a client
    -                             * attached to this server waiting for a response, and there is other bookkeeping of
    -                             * requests that are outstanding and have originated from this server
    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an
    -                             * outstanding request completes. Note that in the other case (above), the operation
    -                             * originated from a different server and there is no local bookkeeping or a local client
    -                             * session that needs to be notified.
    -                             */
    -                            topPending.setHdr(request.getHdr());
    -                            topPending.setTxn(request.getTxn());
    -                            topPending.zxid = request.zxid;
    -                            request = topPending;
    -                        }
    -                    }
    -
    -                    sendToNextProcessor(request);
    -
    -                    waitForEmptyPool();
    -
    -                    /*
    -                     * Process following reads if any, remove session queue if
    -                     * empty.
    -                     */
    -                    if (sessionQueue != null) {
    -                        while (!stopped && !sessionQueue.isEmpty()
    -                                && !needCommit(sessionQueue.peek())) {
    -                            sendToNextProcessor(sessionQueue.poll());
    -                        }
    -                        // Remove empty queues
    -                        if (sessionQueue.isEmpty()) {
    -                            pendingRequests.remove(request.sessionId);
    +                    // We only need to perform synchronization if we are on the last request in the queue
    +                    if (committedRequests.size() == 1) {
    +                        synchronized (committedRequests) {
    --- End diff --
    
    Does synchronized - notifyAll() have any performance hit in normal operation of the follower?
, Github user afine commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/300#discussion_r155102382
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -240,84 +240,14 @@ public void run() {
                         }
     
                         // Process committed head
    -                    if ((request = committedRequests.poll()) == null) {
    -                        throw new IOException("Error: committed head is null");
    -                    }
    -
    -                    /*
    -                     * Check if request is pending, if so, update it with the committed info
    -                     */
    -                    LinkedList<Request> sessionQueue = pendingRequests
    -                            .get(request.sessionId);
    -                    if (sessionQueue != null) {
    -                        // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            /*
    -                             * TL;DR - we should not encounter this scenario often under normal load.
    -                             * We pass the commit to the next processor and put the pending back with a warning.
    -                             *
    -                             * Generally, we can get commit requests that are not at the queue head after
    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    -                             * with A, and the server that the session moved to with B (keep in mind that it is
    -                             * possible that the session already moved from B to a new server C, and maybe C=A).
    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update
    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit
    -                             * for the update after the session already performed several operations in B
    -                             * (and therefore its cxid is higher than that old request).
    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    -                             * from B with cxid that is bigger than the one we know therefore in this case we
    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit
    -                             * for that update, it means that we already sent the request to the leader and it will
    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    -                             * is an increasing order). It is not safe for us to delete the session's queue at this
    -                             * point, since it is possible that the session has newer requests in it after it moved
    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old
    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    -                             * response.
    -                             * Also note that we don't have a local session, therefore we treat the request
    -                             * like any other commit for a remote request, i.e., we perform the update without sending
    -                             * a response.
    -                             */
    -                            LOG.warn("Got request " + request +
    -                                    " but we are expecting request " + topPending);
    -                            sessionQueue.addFirst(topPending);
    -                        } else {
    -                            /*
    -                             * Generally, we want to send to the next processor our version of the request,
    -                             * since it contains the session information that is needed for post update processing.
    -                             * In more details, when a request is in the local queue, there is (or could be) a client
    -                             * attached to this server waiting for a response, and there is other bookkeeping of
    -                             * requests that are outstanding and have originated from this server
    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an
    -                             * outstanding request completes. Note that in the other case (above), the operation
    -                             * originated from a different server and there is no local bookkeeping or a local client
    -                             * session that needs to be notified.
    -                             */
    -                            topPending.setHdr(request.getHdr());
    -                            topPending.setTxn(request.getTxn());
    -                            topPending.zxid = request.zxid;
    -                            request = topPending;
    -                        }
    -                    }
    -
    -                    sendToNextProcessor(request);
    -
    -                    waitForEmptyPool();
    -
    -                    /*
    -                     * Process following reads if any, remove session queue if
    -                     * empty.
    -                     */
    -                    if (sessionQueue != null) {
    -                        while (!stopped && !sessionQueue.isEmpty()
    -                                && !needCommit(sessionQueue.peek())) {
    -                            sendToNextProcessor(sessionQueue.poll());
    -                        }
    -                        // Remove empty queues
    -                        if (sessionQueue.isEmpty()) {
    -                            pendingRequests.remove(request.sessionId);
    +                    // We only need to perform synchronization if we are on the last request in the queue
    +                    if (committedRequests.size() == 1) {
    +                        synchronized (committedRequests) {
    --- End diff --
    
    I believe I was able to mitigate any potential performance impact by only entering a synchronized block when there is only a single committed request in the queue.
, Github user anmolnar commented on a diff in the pull request:

    https://github.com/apache/zookeeper/pull/300#discussion_r155103949
  
    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---
    @@ -240,84 +240,14 @@ public void run() {
                         }
     
                         // Process committed head
    -                    if ((request = committedRequests.poll()) == null) {
    -                        throw new IOException("Error: committed head is null");
    -                    }
    -
    -                    /*
    -                     * Check if request is pending, if so, update it with the committed info
    -                     */
    -                    LinkedList<Request> sessionQueue = pendingRequests
    -                            .get(request.sessionId);
    -                    if (sessionQueue != null) {
    -                        // If session queue != null, then it is also not empty.
    -                        Request topPending = sessionQueue.poll();
    -                        if (request.cxid != topPending.cxid) {
    -                            /*
    -                             * TL;DR - we should not encounter this scenario often under normal load.
    -                             * We pass the commit to the next processor and put the pending back with a warning.
    -                             *
    -                             * Generally, we can get commit requests that are not at the queue head after
    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session
    -                             * with A, and the server that the session moved to with B (keep in mind that it is
    -                             * possible that the session already moved from B to a new server C, and maybe C=A).
    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update
    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit
    -                             * for the update after the session already performed several operations in B
    -                             * (and therefore its cxid is higher than that old request).
    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated
    -                             * from B with cxid that is bigger than the one we know therefore in this case we
    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit
    -                             * for that update, it means that we already sent the request to the leader and it will
    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid
    -                             * is an increasing order). It is not safe for us to delete the session's queue at this
    -                             * point, since it is possible that the session has newer requests in it after it moved
    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old
    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a
    -                             * response.
    -                             * Also note that we don't have a local session, therefore we treat the request
    -                             * like any other commit for a remote request, i.e., we perform the update without sending
    -                             * a response.
    -                             */
    -                            LOG.warn("Got request " + request +
    -                                    " but we are expecting request " + topPending);
    -                            sessionQueue.addFirst(topPending);
    -                        } else {
    -                            /*
    -                             * Generally, we want to send to the next processor our version of the request,
    -                             * since it contains the session information that is needed for post update processing.
    -                             * In more details, when a request is in the local queue, there is (or could be) a client
    -                             * attached to this server waiting for a response, and there is other bookkeeping of
    -                             * requests that are outstanding and have originated from this server
    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an
    -                             * outstanding request completes. Note that in the other case (above), the operation
    -                             * originated from a different server and there is no local bookkeeping or a local client
    -                             * session that needs to be notified.
    -                             */
    -                            topPending.setHdr(request.getHdr());
    -                            topPending.setTxn(request.getTxn());
    -                            topPending.zxid = request.zxid;
    -                            request = topPending;
    -                        }
    -                    }
    -
    -                    sendToNextProcessor(request);
    -
    -                    waitForEmptyPool();
    -
    -                    /*
    -                     * Process following reads if any, remove session queue if
    -                     * empty.
    -                     */
    -                    if (sessionQueue != null) {
    -                        while (!stopped && !sessionQueue.isEmpty()
    -                                && !needCommit(sessionQueue.peek())) {
    -                            sendToNextProcessor(sessionQueue.poll());
    -                        }
    -                        // Remove empty queues
    -                        if (sessionQueue.isEmpty()) {
    -                            pendingRequests.remove(request.sessionId);
    +                    // We only need to perform synchronization if we are on the last request in the queue
    +                    if (committedRequests.size() == 1) {
    +                        synchronized (committedRequests) {
    --- End diff --
    
    Ok

, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    +1 looks good to me.
    @afine Would you please trigger another build to get a green one?
, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @afine @phunt shall we commit this?
, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @afine do you think this is a good one to commit?
, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    @phunt @rakeshadr @hanm This test is quite frequently flaking, I think it'd be useful to commit the patch if we're done with the review.
, Github user anmolnar commented on the issue:

    https://github.com/apache/zookeeper/pull/300
  
    Rebased on master.
]