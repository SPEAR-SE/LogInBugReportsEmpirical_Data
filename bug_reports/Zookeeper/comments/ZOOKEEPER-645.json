[Attached patch addresses issue 2 above.
, Mahadev can you review this one?, sure am doing it right now., -1 overall.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12430357/645-fix-findPrefixInChildren.patch
  against trunk revision 899383.

    +1 @author.  The patch does not contain any @author tags.

    -1 tests included.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no tests are needed for this patch.

    +1 javadoc.  The javadoc tool did not generate any warning messages.

    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.

    +1 findbugs.  The patch does not introduce any new Findbugs warnings.

    +1 release audit.  The applied patch does not increase the total number of release audit warnings.

    +1 core tests.  The patch passed core unit tests.

    +1 contrib tests.  The patch passed contrib unit tests.

Test results: http://hudson.zones.apache.org/hudson/job/Zookeeper-Patch-h8.grid.sp2.yahoo.net/103/testReport/
Findbugs warnings: http://hudson.zones.apache.org/hudson/job/Zookeeper-Patch-h8.grid.sp2.yahoo.net/103/artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html
Console output: http://hudson.zones.apache.org/hudson/job/Zookeeper-Patch-h8.grid.sp2.yahoo.net/103/console

This message is automatically generated., We should add tests to this to verify the change.
, I can address point (1) in the original comment: having the session ID breaks the lock recipe.  It looks like the session ID was added per:

https://issues.apache.org/jira/browse/ZOOKEEPER-78?focusedCommentId=12615305&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12615305

but the sorting via ZNodeName is worse than starvation: it causes clients with low session IDs not to see that clients with higher session IDs have acquired the lock which causes the function to return true: so you could theoretically have as many lock owners as clients as long as they acquire the lock in descending session ID order.

I fixed this in a local branch by replacing ZNodeName with a different class that ignores the session ID when sorting.  My test for WriteLockTest became:
{noformat}
/*
        * Test that the bug which makes it possible to acquire a lock in two
        * different sessions simultaneously is fixed. Bug occurs because including
        * session ID in node name results in sorting in
        * LockZooKeeperOperation.execute() such that low session ID clients do not
        * see that higher session ID clients already have the lock.
        */
       @Test
       public void testSessionOrderingBugFix() throws Exception {
               // session IDs are presumably assigned in order, but perform some checks
               final ZooKeeper zooA = createClient();
               final ZooKeeper zooB = createClient();

               final ZooKeeper lowZoo = zooA.getSessionId() < zooB.getSessionId() ? zooA
                               : zooB;
               final ZooKeeper highZoo = zooA.getSessionId() < zooB.getSessionId() ? zooB
                               : zooA;

               final WriteLock highLock = new WriteLock(highZoo, dir, null);
               final WriteLock lowLock = new WriteLock(lowZoo, dir, null);

               boolean highLocked = highLock.lock();
               assertTrue(highLocked);

               // If the bug is present, this attempt to lock will succeed.
               boolean lowLocked = lowLock.lock();
               assertFalse(lowLocked);

               assertTrue(highLock.isOwner());
               assertFalse(lowLock.isOwner());
       }
{noformat}, not a blocker. moving it to 3.4., I have applied the patch but still see that locks generated by subsequent clients are not respected by the first client and it is always able to get the lock  , around line 245, seems need to set id = null to continue the loop as the watcher not be setup corrently.

Stat stat = zookeeper.exists(lastChildId, new LockWatcher());
                            if (stat != null) {
                                return Boolean.FALSE;
                            } else {
                                LOG.warn("Could not find the" +
                                		" stats for less than me: " + lastChildName.getName());
                                id = null; //2011.3.31 set id to null to continue the loop                            }, compareTo.patch aims to correct ordering of ZNodeName objects used to validate lock ownership.

The code at WriteLock gets a list of znodes and for each znode creates a ZNodeName object which is added to a sorted list. 
The sorting was based on the full znode name, i.e. x-sessionID-ephemeral_number. As earlier connected clients appear to have lower sessionID values than those which connected latter, who connects first gets the lock disregarding anyone who has already the lock.

This patch simply changes compareTo overload at ZNodeName to just consider the sequence number instead of the full znode name, as this class' objects are used only for this purpose, this seems to have done the trick =)

However, getSessionID not being thread-safe is still an issue.

Could someone try it out and post the results?

[A discussion about this bug and some other issues on lock recipe, as well as this patch contributors, can be found here (in Portuguese) http://www.lsd.ic.unicamp.br/mc715-1s2011/index.php/Grupo01], Hi, has anyone tried this?, I've tried it.  I did see the starvation behavior with the original compareTo method from ZNodeName.  When I applied the compareTo patch the starvation issue went away., It seems as though both of the patches uploaded to date address real issues.  I've combined both patches and added a couple small changes:

- session ID is always padded out to the maximum number of digits in a long (this is purely an esthetic change, but I added a test case to make sure that the previous format and the current format could be intermingled).

- using a regex to extract the sequence ID from the znode.  I'm doing this based on the assumption that sequence numbers will always be padded to 10 digits (as stated on the wiki).  This seemed a little more robust than simply looking for the last index of '-' if, for example, somebody exactly creates a znode in the directory where you only expect lock-related paths.  On a related note: is there no way to tell if a znode was created as a sequential node from the Stat object.  I see "ephemeralOwner", but no equivalent for checking if the node was created as a sequential node.

After writing that last bullet point, I'm realizing that it would probably be best to use "ephemeralOwner" instead of explicitly adding the session ID to the path... I'll try to change that in a future patch., follow this and it seems work.

1、ZNodeName
public int compareTo(ZNodeName that) {
    int s1 = this.sequence;
    int s2 = that.sequence;
    if (s1 == -1 && s2 == -1) {
        return this.name.compareTo(that.name);
    }
    return s1 == -1 ? 1 : s2 == -1 ? -1 : s1 - s2;
}

2、WriteLock
change “id = name;” to “id = dir + "/" + name;”

3、WriteLock
if (stat != null) {
    return Boolean.FALSE;
} else {
    LOG.warn("Could not find the" + " stats for less than me: " + lastChildName.getName());
    return execute(); // add this
}

, Github user phunt commented on the issue:

    https://github.com/apache/zookeeper/pull/413
  
    Did you guys see https://issues.apache.org/jira/browse/ZOOKEEPER-645 - it's from long back. Not sure if it's interesting to you @javicacheiro but FYI. If someone is interested to get that one over the line as well please speak up. thx.
, I'm getting WriteLocks never being granted on 3.4.11 and initially brought it up on the user email list.  I'm working with ZookeeperNetEx on C# but have verified the code behaves the same on Java.

I've encountered two issues:
 # When setting the watch on the predecessor, its possible that the predecessor has been deleted between the time we acquired the children and set the watch.  If this happens, there is no watch and we exit out of the loop.  We should set id to null in this case to ensure the loop doesn't terminate.
 # Still need the change to ensure the dir name is prepended to the name returned from getChildren call in findPrefixInChildren.

#1 change
{code:java}
Stat stat = zookeeper.exists(lastChildId, new LockWatcher());
if (stat != null) {
   return Boolean.FALSE;
} else {
    LOG.warn("Could not find the" +
" stats for less than me: " + lastChildName.getName());
}
{code}
to
{code:java}
Stat stat = zookeeper.exists(lastChildId, new LockWatcher());
if (stat != null) {
    return Boolean.FALSE;
} else {
    LOG.warn("Could not find the" +
" stats for less than me: " + lastChildName.getName());
    id = null;
}
{code}
 

I've been running with these changes on 3.4.11 with two processes contending for 3 different locks and so far no hangs like I was seeing consistently without them., I am going to suggest removing the code. It seems clear that
 # The implementation has bugs
 # Willingness to fix them is near 0
 # The implementation is not even a good academic example
 # If anyone attempts to fix it gets stalled by adding integration testing that is not in place
 # There are other mature lock over zk libraries in the wild]