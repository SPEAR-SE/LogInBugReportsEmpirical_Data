{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13018325","self":"https://issues.apache.org/jira/rest/api/2/issue/13018325","key":"ZOOKEEPER-2628","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310801","id":"12310801","key":"ZOOKEEPER","name":"ZooKeeper","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310801&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310801&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310801&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310801&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10484","id":"10484","description":"Apache ZooKeeper related","name":"ZooKeeper"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12335444","id":"12335444","description":"Beta release against 3.5 branch","name":"3.5.3","archived":false,"released":true,"releaseDate":"2017-04-17"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12326518","id":"12326518","name":"3.6.0","archived":false,"released":false}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12312322":null,"customfield_12310220":"2016-11-07T22:11:59.259+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Thu Nov 24 21:54:41 UTC 2016","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":"1_*:*_1_*:*_1697497623_*|*_5_*:*_1_*:*_0","customfield_12312321":null,"resolutiondate":"2016-11-24T16:21:27.032+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2628/watchers","watchCount":5,"isWatching":false},"created":"2016-11-05T00:49:49.715+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12331981","id":"12331981","description":"Alpha release against 3.5 branch","name":"3.5.2","archived":false,"released":true,"releaseDate":"2016-07-21"}],"issuelinks":[{"id":"12487410","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12487410","type":{"id":"12310050","name":"Regression","inward":"is broken by","outward":"breaks","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310050"},"outwardIssue":{"id":"13023262","key":"ZOOKEEPER-2636","self":"https://issues.apache.org/jira/rest/api/2/issue/13023262","fields":{"summary":"Fix C build break.","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/1","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/blocker.svg","name":"Blocker","id":"1"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2017-05-18T03:44:02.778+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"components":[],"timeoriginalestimate":null,"description":"Findbug tool used by Jenkins bot is upgraded to 3.0.1 from 2.0.3 according to Infra team, and this leads to 20 new warnings produced by findbug. The warning reports can be found on [pre commit builds|https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/] with build number >= 3513. These warnings need to be triaged and fixed if they are legitimate.\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"Investigate and fix findbug warnings","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15645632","id":"15645632","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"GitHub user hanm opened a pull request:\n\n    https://github.com/apache/zookeeper/pull/102\n\n    ZOOKEEPER-2628: Fix findbug warnings.\n\n    This PR fixed 19 find bug warnings except this one, which might require interface change that potentially could break client side apps.\n    \n    Malicious code vulnerability Warnings\n    org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE is a mutable collection\n    Bug type MS_MUTABLE_COLLECTION (click for details) \n    In class org.apache.zookeeper.ZooDefs$Ids\n    Field org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE\n    At ZooDefs.java:[line 116]\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/hanm/zookeeper ZOOKEEPER-2628\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/zookeeper/pull/102.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #102\n    \n----\ncommit d6e059ef11dea0de725b7bebd14e7bba626bdf53\nAuthor: Michael Han <hanm@cloudera.com>\nDate:   2016-11-07T22:09:10Z\n\n    ZOOKEEPER-2628: Fix findbug warnings.\n\n----\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-07T22:11:59.259+0000","updated":"2016-11-07T22:11:59.259+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15645695","id":"15645695","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r86885871\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/CGenerator.java ---\n    @@ -61,70 +61,88 @@ void genCode() throws IOException {\n                             + outputDirectory);\n                 }\n             }\n    -        FileWriter c = new FileWriter(new File(outputDirectory, mName+\".c\"));\n    -        FileWriter h = new FileWriter(new File(outputDirectory, mName+\".h\"));\n     \n    -        h.write(\"/**\\n\");\n    -        h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        h.write(\"* distributed with this work for additional information\\n\");\n    -        h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        h.write(\"*\\n\");\n    -        h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        h.write(\"*\\n\");\n    -        h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        h.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        h.write(\"* limitations under the License.\\n\");\n    -        h.write(\"*/\\n\");\n    -        h.write(\"\\n\");\n    +        FileWriter c = null, h = null;\n    +        try {\n    +            c = new FileWriter(new File(outputDirectory, mName + \".c\"));\n    +            h = new FileWriter(new File(outputDirectory, mName + \".h\"));\n     \n    -        c.write(\"/**\\n\");\n    -        c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        c.write(\"* distributed with this work for additional information\\n\");\n    -        c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        c.write(\"*\\n\");\n    -        c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        c.write(\"*\\n\");\n    -        c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        c.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        c.write(\"* limitations under the License.\\n\");\n    -        c.write(\"*/\\n\");\n    -        c.write(\"\\n\");\n    +            h.write(\"/**\\n\");\n    +            h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            h.write(\"* distributed with this work for additional information\\n\");\n    +            h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            h.write(\"*\\n\");\n    +            h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            h.write(\"*\\n\");\n    +            h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            h.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            h.write(\"* limitations under the License.\\n\");\n    +            h.write(\"*/\\n\");\n    +            h.write(\"\\n\");\n     \n    -        h.write(\"#ifndef __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    -        h.write(\"#define __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    +            c.write(\"/**\\n\");\n    +            c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            c.write(\"* distributed with this work for additional information\\n\");\n    +            c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            c.write(\"*\\n\");\n    +            c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            c.write(\"*\\n\");\n    +            c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            c.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            c.write(\"* limitations under the License.\\n\");\n    +            c.write(\"*/\\n\");\n    +            c.write(\"\\n\");\n     \n    -        h.write(\"#include \\\"recordio.h\\\"\\n\");\n    -        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {\n    -            JFile f = i.next();\n    -            h.write(\"#include \\\"\"+f.getName()+\".h\\\"\\n\");\n    -        }\n    -        // required for compilation from C++\n    -        h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n    +            h.write(\"#ifndef __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n    +            h.write(\"#define __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n     \n    -        c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n    -        c.write(\"#include \\\"\"+mName+\".h\\\"\\n\\n\");\n    +            h.write(\"#include \\\"recordio.h\\\"\\n\");\n    +            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {\n    +                JFile f = i.next();\n    +                h.write(\"#include \\\"\" + f.getName() + \".h\\\"\\n\");\n    +            }\n    +            // required for compilation from C++\n    +            h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n     \n    -        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {\n    -            JRecord jr = i.next();\n    -            jr.genCCode(h, c);\n    -        }\n    +            c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n    +            c.write(\"#include \\\"\" + mName + \".h\\\"\\n\\n\");\n     \n    -        h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n    -        h.write(\"#endif //\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    +            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {\n    +                JRecord jr = i.next();\n    +                jr.genCCode(h, c);\n    +            }\n     \n    -        h.close();\n    -        c.close();\n    +            h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n    +            h.write(\"#endif //\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n    +        } catch (IOException e) {\n    +            throw e;\n    +        } finally {\n    +            if (h != null) {\n    +                try {\n    +                    h.close();\n    +                } catch (IOException ex) {\n    +                    throw ex;\n    +                } finally {\n    +                    if (c != null) {\n    +                        c.close();\n    +                    }\n    +                }\n    +            }\n    +            if (c != null) {\n    --- End diff --\n    \n    It's sad that we have to close c twice (one here, one in the finally block earlier.). Findbugs is not happy if either of them is missing. It could be that the flow sensitive engine of findbug need an improvement.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-07T22:37:02.614+0000","updated":"2016-11-07T22:37:02.614+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15646021","id":"15646021","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user breed commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r86903124\n  \n    --- Diff: src/java/main/org/apache/zookeeper/version/util/VerGen.java ---\n    @@ -93,6 +93,14 @@ public static void generateFile(File outputDir, Version version, int rev, String\n             } catch (IOException e) {\n                 System.out.println(\"Unable to generate version.Info file: \"\n                         + e.getMessage());\n    +            if (w != null) {\n    --- End diff --\n    \n    wow this is a weird one... we have it in the finally... try with resources would make this a bit nicer too...\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T00:57:36.997+0000","updated":"2016-11-08T00:57:36.997+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15646022","id":"15646022","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user breed commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r86902626\n  \n    --- Diff: src/java/main/org/apache/zookeeper/cli/DeleteCommand.java ---\n    @@ -59,11 +59,6 @@ private void retainCompatibility(String[] cmdArgs) throws CliParseException {\n             // delete path [version]\n             if (args.length > 2) {\n                 // rewrite to option\n    --- End diff --\n    \n    you can remove the comment too :)\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T00:57:36.997+0000","updated":"2016-11-08T00:57:36.997+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15646023","id":"15646023","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user breed commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r86902396\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/CGenerator.java ---\n    @@ -61,70 +61,88 @@ void genCode() throws IOException {\n                             + outputDirectory);\n                 }\n             }\n    -        FileWriter c = new FileWriter(new File(outputDirectory, mName+\".c\"));\n    -        FileWriter h = new FileWriter(new File(outputDirectory, mName+\".h\"));\n     \n    -        h.write(\"/**\\n\");\n    -        h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        h.write(\"* distributed with this work for additional information\\n\");\n    -        h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        h.write(\"*\\n\");\n    -        h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        h.write(\"*\\n\");\n    -        h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        h.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        h.write(\"* limitations under the License.\\n\");\n    -        h.write(\"*/\\n\");\n    -        h.write(\"\\n\");\n    +        FileWriter c = null, h = null;\n    +        try {\n    +            c = new FileWriter(new File(outputDirectory, mName + \".c\"));\n    +            h = new FileWriter(new File(outputDirectory, mName + \".h\"));\n     \n    -        c.write(\"/**\\n\");\n    -        c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        c.write(\"* distributed with this work for additional information\\n\");\n    -        c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        c.write(\"*\\n\");\n    -        c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        c.write(\"*\\n\");\n    -        c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        c.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        c.write(\"* limitations under the License.\\n\");\n    -        c.write(\"*/\\n\");\n    -        c.write(\"\\n\");\n    +            h.write(\"/**\\n\");\n    +            h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            h.write(\"* distributed with this work for additional information\\n\");\n    +            h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            h.write(\"*\\n\");\n    +            h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            h.write(\"*\\n\");\n    +            h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            h.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            h.write(\"* limitations under the License.\\n\");\n    +            h.write(\"*/\\n\");\n    +            h.write(\"\\n\");\n     \n    -        h.write(\"#ifndef __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    -        h.write(\"#define __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    +            c.write(\"/**\\n\");\n    +            c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            c.write(\"* distributed with this work for additional information\\n\");\n    +            c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            c.write(\"*\\n\");\n    +            c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            c.write(\"*\\n\");\n    +            c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            c.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            c.write(\"* limitations under the License.\\n\");\n    +            c.write(\"*/\\n\");\n    +            c.write(\"\\n\");\n     \n    -        h.write(\"#include \\\"recordio.h\\\"\\n\");\n    -        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {\n    -            JFile f = i.next();\n    -            h.write(\"#include \\\"\"+f.getName()+\".h\\\"\\n\");\n    -        }\n    -        // required for compilation from C++\n    -        h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n    +            h.write(\"#ifndef __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n    +            h.write(\"#define __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n     \n    -        c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n    -        c.write(\"#include \\\"\"+mName+\".h\\\"\\n\\n\");\n    +            h.write(\"#include \\\"recordio.h\\\"\\n\");\n    +            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {\n    +                JFile f = i.next();\n    +                h.write(\"#include \\\"\" + f.getName() + \".h\\\"\\n\");\n    +            }\n    +            // required for compilation from C++\n    +            h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n     \n    -        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {\n    -            JRecord jr = i.next();\n    -            jr.genCCode(h, c);\n    -        }\n    +            c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n    +            c.write(\"#include \\\"\" + mName + \".h\\\"\\n\\n\");\n     \n    -        h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n    -        h.write(\"#endif //\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    +            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {\n    +                JRecord jr = i.next();\n    +                jr.genCCode(h, c);\n    +            }\n     \n    -        h.close();\n    -        c.close();\n    +            h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n    +            h.write(\"#endif //\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n    +        } catch (IOException e) {\n    +            throw e;\n    +        } finally {\n    +            if (h != null) {\n    +                try {\n    +                    h.close();\n    +                } catch (IOException ex) {\n    +                    throw ex;\n    +                } finally {\n    +                    if (c != null) {\n    +                        c.close();\n    +                    }\n    +                }\n    +            }\n    +            if (c != null) {\n    --- End diff --\n    \n    i think try with resources would clean this up. we are on java7 now right?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T00:57:36.997+0000","updated":"2016-11-08T00:57:36.997+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15646036","id":"15646036","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r86905102\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/CGenerator.java ---\n    @@ -61,70 +61,88 @@ void genCode() throws IOException {\n                             + outputDirectory);\n                 }\n             }\n    -        FileWriter c = new FileWriter(new File(outputDirectory, mName+\".c\"));\n    -        FileWriter h = new FileWriter(new File(outputDirectory, mName+\".h\"));\n     \n    -        h.write(\"/**\\n\");\n    -        h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        h.write(\"* distributed with this work for additional information\\n\");\n    -        h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        h.write(\"*\\n\");\n    -        h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        h.write(\"*\\n\");\n    -        h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        h.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        h.write(\"* limitations under the License.\\n\");\n    -        h.write(\"*/\\n\");\n    -        h.write(\"\\n\");\n    +        FileWriter c = null, h = null;\n    +        try {\n    +            c = new FileWriter(new File(outputDirectory, mName + \".c\"));\n    +            h = new FileWriter(new File(outputDirectory, mName + \".h\"));\n     \n    -        c.write(\"/**\\n\");\n    -        c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        c.write(\"* distributed with this work for additional information\\n\");\n    -        c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        c.write(\"*\\n\");\n    -        c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        c.write(\"*\\n\");\n    -        c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        c.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        c.write(\"* limitations under the License.\\n\");\n    -        c.write(\"*/\\n\");\n    -        c.write(\"\\n\");\n    +            h.write(\"/**\\n\");\n    +            h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            h.write(\"* distributed with this work for additional information\\n\");\n    +            h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            h.write(\"*\\n\");\n    +            h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            h.write(\"*\\n\");\n    +            h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            h.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            h.write(\"* limitations under the License.\\n\");\n    +            h.write(\"*/\\n\");\n    +            h.write(\"\\n\");\n     \n    -        h.write(\"#ifndef __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    -        h.write(\"#define __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    +            c.write(\"/**\\n\");\n    +            c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            c.write(\"* distributed with this work for additional information\\n\");\n    +            c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            c.write(\"*\\n\");\n    +            c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            c.write(\"*\\n\");\n    +            c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            c.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            c.write(\"* limitations under the License.\\n\");\n    +            c.write(\"*/\\n\");\n    +            c.write(\"\\n\");\n     \n    -        h.write(\"#include \\\"recordio.h\\\"\\n\");\n    -        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {\n    -            JFile f = i.next();\n    -            h.write(\"#include \\\"\"+f.getName()+\".h\\\"\\n\");\n    -        }\n    -        // required for compilation from C++\n    -        h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n    +            h.write(\"#ifndef __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n    +            h.write(\"#define __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n     \n    -        c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n    -        c.write(\"#include \\\"\"+mName+\".h\\\"\\n\\n\");\n    +            h.write(\"#include \\\"recordio.h\\\"\\n\");\n    +            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {\n    +                JFile f = i.next();\n    +                h.write(\"#include \\\"\" + f.getName() + \".h\\\"\\n\");\n    +            }\n    +            // required for compilation from C++\n    +            h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n     \n    -        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {\n    -            JRecord jr = i.next();\n    -            jr.genCCode(h, c);\n    -        }\n    +            c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n    +            c.write(\"#include \\\"\" + mName + \".h\\\"\\n\\n\");\n     \n    -        h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n    -        h.write(\"#endif //\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n    +            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {\n    +                JRecord jr = i.next();\n    +                jr.genCCode(h, c);\n    +            }\n     \n    -        h.close();\n    -        c.close();\n    +            h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n    +            h.write(\"#endif //\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n    +        } catch (IOException e) {\n    +            throw e;\n    +        } finally {\n    +            if (h != null) {\n    +                try {\n    +                    h.close();\n    +                } catch (IOException ex) {\n    +                    throw ex;\n    +                } finally {\n    +                    if (c != null) {\n    +                        c.close();\n    +                    }\n    +                }\n    +            }\n    +            if (c != null) {\n    --- End diff --\n    \n    Yeah I thought about using try / with  - for some reasons I had the impression that we also need to support JDK 1.6 (that's probably only for 3.4.x). I'll update with try / with.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T01:06:25.479+0000","updated":"2016-11-08T01:06:25.479+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15646038","id":"15646038","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r86905174\n  \n    --- Diff: src/java/main/org/apache/zookeeper/version/util/VerGen.java ---\n    @@ -93,6 +93,14 @@ public static void generateFile(File outputDir, Version version, int rev, String\n             } catch (IOException e) {\n                 System.out.println(\"Unable to generate version.Info file: \"\n                         + e.getMessage());\n    +            if (w != null) {\n    --- End diff --\n    \n    Findbug complains here because we use System.exit in catch block - in that case it is not guaranteed that the finally block will be executed.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T01:07:12.125+0000","updated":"2016-11-08T01:07:12.125+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15646614","id":"15646614","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/102\n  \n    Updated PR to address review comments from @breed.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T05:56:05.177+0000","updated":"2016-11-08T05:56:05.177+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15648175","id":"15648175","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87028116\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/DataTree.java ---\n    @@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {\n          * @param pwriter the output to write to\n          */\n         public void dumpEphemerals(PrintWriter pwriter) {\n    -        Set<Long> keys = ephemerals.keySet();\n             pwriter.println(\"Sessions with Ephemerals (\"\n    -                + keys.size() + \"):\");\n    -        for (long k : keys) {\n    -            pwriter.print(\"0x\" + Long.toHexString(k));\n    +                + ephemerals.keySet().size() + \"):\");\n    +        for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {\n    +            pwriter.print(\"0x\" + Long.toHexString(entry.getKey()));\n                 pwriter.println(\":\");\n    -            HashSet<String> tmp = ephemerals.get(k);\n    +            HashSet<String> tmp = entry.getValue();\n    --- End diff --\n    \n    Could we define `tmp` as `Set` instead of `HashSet`?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T17:25:26.758+0000","updated":"2016-11-08T17:25:26.758+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15648176","id":"15648176","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87027160\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java ---\n    @@ -344,9 +345,10 @@ public boolean containsQuorum(Set<Long> set){\n              * Check if all groups have majority\n              */\n             int majGroupCounter = 0;\n    -        for(long gid : expansion.keySet()) {\n    -            LOG.debug(\"Group info: \" + expansion.get(gid) + \", \" + gid + \", \" + groupWeight.get(gid));\n    -            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )\n    +        for (Entry<Long, Long> entry : expansion.entrySet()) {\n    +            Long gid = entry.getKey();\n    +            LOG.debug(\"Group info: \" + entry.getValue() + \", \" + gid + \", \" + groupWeight.get(gid));\n    --- End diff --\n    \n    We could use modern LOG printing here: \n    \n    ``\n    LOG.debug(\"Group info: {}, {}, {}\", entry.getValue(), gid, groupWeight.get(gid));\n    ``\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T17:25:26.780+0000","updated":"2016-11-08T17:25:26.780+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15648177","id":"15648177","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87027302\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java ---\n    @@ -344,9 +345,10 @@ public boolean containsQuorum(Set<Long> set){\n              * Check if all groups have majority\n              */\n             int majGroupCounter = 0;\n    -        for(long gid : expansion.keySet()) {\n    -            LOG.debug(\"Group info: \" + expansion.get(gid) + \", \" + gid + \", \" + groupWeight.get(gid));\n    -            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )\n    +        for (Entry<Long, Long> entry : expansion.entrySet()) {\n    +            Long gid = entry.getKey();\n    +            LOG.debug(\"Group info: \" + entry.getValue() + \", \" + gid + \", \" + groupWeight.get(gid));\n    +            if(entry.getValue() > (groupWeight.get(gid) / 2) )\n    --- End diff --\n    \n    nit: add space after the `if` and remove space before the last parenthesis.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T17:25:26.781+0000","updated":"2016-11-08T17:25:26.781+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15648178","id":"15648178","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87038798\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/JRecord.java ---\n    @@ -141,109 +141,128 @@ public String genCsharpWriteWrapper(String fname, String tag) {\n     \n         static HashMap<String, String> vectorStructs = new HashMap<String, String>();\n         public void genCCode(FileWriter h, FileWriter c) throws IOException {\n    -        for (JField f : mFields) {\n    -            if (f.getType() instanceof JVector) {\n    -                JVector jv = (JVector)f.getType();\n    -                JType jvType = jv.getElementType();\n    -                String struct_name = JVector.extractVectorName(jvType);\n    -                if (vectorStructs.get(struct_name) == null) {\n    -                    vectorStructs.put(struct_name, struct_name);\n    -                    h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\" + jv.getElementType().genCDecl(\"*data\") + \"\\n};\\n\");\n    -                    h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v);\\n\");\n    -                    h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v);\\n\");\n    -                    h.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len);\\n\");\n    -                    h.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v);\\n\");\n    -                    c.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len) {\\n\");\n    -                    c.write(\"    if (!len) {\\n\");\n    -                    c.write(\"        v->count = 0;\\n\");\n    -                    c.write(\"        v->data = 0;\\n\");\n    -                    c.write(\"    } else {\\n\");\n    -                    c.write(\"        v->count = len;\\n\");\n    -                    c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n    -                    c.write(\"    }\\n\");\n    -                    c.write(\"    return 0;\\n\");\n    -                    c.write(\"}\\n\");\n    -                    c.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v) {\\n\");\n    -                    c.write(\"    if (v->data) {\\n\");\n    -                    c.write(\"        int32_t i;\\n\");\n    -                    c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n    -                    c.write(\"            deallocate_\"+JRecord.extractMethodSuffix(jvType)+\"(&v->data[i]);\\n\");\n    -                    c.write(\"        }\\n\");\n    -                    c.write(\"        free(v->data);\\n\");\n    -                    c.write(\"        v->data = 0;\\n\");\n    -                    c.write(\"    }\\n\");\n    -                    c.write(\"    return 0;\\n\");\n    -                    c.write(\"}\\n\");\n    -                    c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v)\\n\");\n    -                    c.write(\"{\\n\");\n    -                    c.write(\"    int32_t count = v->count;\\n\");\n    -                    c.write(\"    int rc = 0;\\n\");\n    -                    c.write(\"    int32_t i;\\n\");\n    -                    c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n    -                    c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n    -                    genSerialize(c, jvType, \"data\", \"data[i]\");\n    -                    c.write(\"    }\\n\");\n    -                    c.write(\"    rc = rc ? rc : out->end_vector(out, tag);\\n\");\n    -                    c.write(\"    return rc;\\n\");\n    -                    c.write(\"}\\n\");\n    -                    c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v)\\n\");\n    -                    c.write(\"{\\n\");\n    -                    c.write(\"    int rc = 0;\\n\");\n    -                    c.write(\"    int32_t i;\\n\");\n    -                    c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n    -                    c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n    -                    c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n    -                    genDeserialize(c, jvType, \"value\", \"data[i]\");\n    -                    c.write(\"    }\\n\");\n    -                    c.write(\"    rc = in->end_vector(in, tag);\\n\");\n    -                    c.write(\"    return rc;\\n\");\n    -                    c.write(\"}\\n\");\n    -\n    +        try {\n    +            for (JField f : mFields) {\n    +                if (f.getType() instanceof JVector) {\n    +                    JVector jv = (JVector) f.getType();\n    +                    JType jvType = jv.getElementType();\n    +                    String struct_name = JVector.extractVectorName(jvType);\n    +                    if (vectorStructs.get(struct_name) == null) {\n    +                        vectorStructs.put(struct_name, struct_name);\n    +                        h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\" + jv.getElementType().genCDecl(\"*data\") + \"\\n};\\n\");\n    +                        h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v);\\n\");\n    +                        h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v);\\n\");\n    +                        h.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len);\\n\");\n    +                        h.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v);\\n\");\n    +                        c.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len) {\\n\");\n    +                        c.write(\"    if (!len) {\\n\");\n    +                        c.write(\"        v->count = 0;\\n\");\n    +                        c.write(\"        v->data = 0;\\n\");\n    +                        c.write(\"    } else {\\n\");\n    +                        c.write(\"        v->count = len;\\n\");\n    +                        c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n    +                        c.write(\"    }\\n\");\n    +                        c.write(\"    return 0;\\n\");\n    +                        c.write(\"}\\n\");\n    +                        c.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v) {\\n\");\n    +                        c.write(\"    if (v->data) {\\n\");\n    +                        c.write(\"        int32_t i;\\n\");\n    +                        c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n    +                        c.write(\"            deallocate_\" + JRecord.extractMethodSuffix(jvType) + \"(&v->data[i]);\\n\");\n    +                        c.write(\"        }\\n\");\n    +                        c.write(\"        free(v->data);\\n\");\n    +                        c.write(\"        v->data = 0;\\n\");\n    +                        c.write(\"    }\\n\");\n    +                        c.write(\"    return 0;\\n\");\n    +                        c.write(\"}\\n\");\n    +                        c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v)\\n\");\n    +                        c.write(\"{\\n\");\n    +                        c.write(\"    int32_t count = v->count;\\n\");\n    +                        c.write(\"    int rc = 0;\\n\");\n    +                        c.write(\"    int32_t i;\\n\");\n    +                        c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n    +                        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n    +                        genSerialize(c, jvType, \"data\", \"data[i]\");\n    +                        c.write(\"    }\\n\");\n    +                        c.write(\"    rc = rc ? rc : out->end_vector(out, tag);\\n\");\n    +                        c.write(\"    return rc;\\n\");\n    +                        c.write(\"}\\n\");\n    +                        c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v)\\n\");\n    +                        c.write(\"{\\n\");\n    +                        c.write(\"    int rc = 0;\\n\");\n    +                        c.write(\"    int32_t i;\\n\");\n    +                        c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n    +                        c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n    +                        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n    +                        genDeserialize(c, jvType, \"value\", \"data[i]\");\n    +                        c.write(\"    }\\n\");\n    +                        c.write(\"    rc = in->end_vector(in, tag);\\n\");\n    +                        c.write(\"    return rc;\\n\");\n    +                        c.write(\"}\\n\");\n    +\n    +                    }\n                     }\n                 }\n    -        }\n    -        String rec_name = getName();\n    -        h.write(\"struct \" + rec_name + \" {\\n\");\n    -        for (JField f : mFields) {\n    -            h.write(f.genCDecl());\n    -        }\n    -        h.write(\"};\\n\");\n    -        h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v);\\n\");\n    -        h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v);\\n\");\n    -        h.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*);\\n\");\n    -        c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v)\");\n    -        c.write(\"{\\n\");\n    -        c.write(\"    int rc;\\n\");\n    -        c.write(\"    rc = out->start_record(out, tag);\\n\");\n    -        for(JField f : mFields) {\n    -            genSerialize(c, f.getType(), f.getTag(), f.getName());\n    -        }\n    -        c.write(\"    rc = rc ? rc : out->end_record(out, tag);\\n\");\n    -        c.write(\"    return rc;\\n\");\n    -        c.write(\"}\\n\");\n    -        c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v)\");\n    -        c.write(\"{\\n\");\n    -        c.write(\"    int rc;\\n\");\n    -        c.write(\"    rc = in->start_record(in, tag);\\n\");\n    -        for(JField f : mFields) {\n    -            genDeserialize(c, f.getType(), f.getTag(), f.getName());\n    -        }\n    -        c.write(\"    rc = rc ? rc : in->end_record(in, tag);\\n\");\n    -        c.write(\"    return rc;\\n\");\n    -        c.write(\"}\\n\");\n    -        c.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*v)\");\n    -        c.write(\"{\\n\");\n    -        for(JField f : mFields) {\n    -            if (f.getType() instanceof JRecord) {\n    -                c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n    -            } else if (f.getType() instanceof JVector) {\n    -                JVector vt = (JVector)f.getType();\n    -                c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType())+ \"(&v->\"+f.getName()+\");\\n\");\n    -            } else if (f.getType() instanceof JCompType) {\n    -                c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\"+f.getName()+\");\\n\");\n    +            String rec_name = getName();\n    +            h.write(\"struct \" + rec_name + \" {\\n\");\n    +            for (JField f : mFields) {\n    +                h.write(f.genCDecl());\n    +            }\n    +            h.write(\"};\\n\");\n    +            h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v);\\n\");\n    +            h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v);\\n\");\n    +            h.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*);\\n\");\n    +            c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v)\");\n    +            c.write(\"{\\n\");\n    +            c.write(\"    int rc;\\n\");\n    +            c.write(\"    rc = out->start_record(out, tag);\\n\");\n    +            for (JField f : mFields) {\n    +                genSerialize(c, f.getType(), f.getTag(), f.getName());\n    +            }\n    +            c.write(\"    rc = rc ? rc : out->end_record(out, tag);\\n\");\n    +            c.write(\"    return rc;\\n\");\n    +            c.write(\"}\\n\");\n    +            c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v)\");\n    +            c.write(\"{\\n\");\n    +            c.write(\"    int rc;\\n\");\n    +            c.write(\"    rc = in->start_record(in, tag);\\n\");\n    +            for (JField f : mFields) {\n    +                genDeserialize(c, f.getType(), f.getTag(), f.getName());\n    +            }\n    +            c.write(\"    rc = rc ? rc : in->end_record(in, tag);\\n\");\n    +            c.write(\"    return rc;\\n\");\n    +            c.write(\"}\\n\");\n    +            c.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*v)\");\n    +            c.write(\"{\\n\");\n    +            for (JField f : mFields) {\n    +                if (f.getType() instanceof JRecord) {\n    +                    c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n    +                } else if (f.getType() instanceof JVector) {\n    +                    JVector vt = (JVector) f.getType();\n    +                    c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType()) + \"(&v->\" + f.getName() + \");\\n\");\n    +                } else if (f.getType() instanceof JCompType) {\n    +                    c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n    +                }\n    +            }\n    +            c.write(\"}\\n\");\n    +        } catch (IOException e) {\n    +            throw e;\n    +        } finally {\n    +            if (h != null) {\n    --- End diff --\n    \n    Just speculating here: couldn't we write this snippet as:\n    \n    ```\n    private IOException maybeClose(FileWriter file) {\n           IOException t = null;\n           if (file != null) {\n                 try {\n                         file.close();\n                 } catch (IOException ex) {\n                       t = ex;\n                 }          \n         }\n        return t;\n    }\n    \n    (...)\n    \n    } finally {\n    \n        IOException e1 = maybeClose(h);\n        IOException e2 = maybeClose(c);\n    \n        if (e1 != null) {\n            throw e1;\n        }\n    \n       if (e2 != null) {\n           throw e2;\n       }\n    }\n    \n    \n    ```\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T17:25:26.805+0000","updated":"2016-11-08T17:25:26.805+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15648179","id":"15648179","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87026194\n  \n    --- Diff: src/java/main/org/apache/zookeeper/version/util/VerGen.java ---\n    @@ -50,10 +50,8 @@ public static void generateFile(File outputDir, Version version, int rev, String\n                 System.out.println(path + \" is not a directory.\");\n                 System.exit(1);\n             }\n    -        File file = new File(pkgdir, TYPE_NAME + \".java\");\n    -        FileWriter w = null;\n    -        try {\n    -            w = new FileWriter(file);\n    +\n    +        try (FileWriter w = new FileWriter(new File(pkgdir, TYPE_NAME + \".java\"));) {\n    --- End diff --\n    \n    nit: spurious \";\"\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T17:25:27.375+0000","updated":"2016-11-08T17:25:27.375+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15648697","id":"15648697","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/102\n  \n    Updated PR to address review comments from @eribeiro.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-08T20:22:49.563+0000","updated":"2016-11-08T20:22:49.563+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15651880","id":"15651880","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user lvfangmin commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87265113\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java ---\n    @@ -151,9 +153,13 @@\n          */\n         public final static int telnetCloseCmd = 0xfff4fffd;\n     \n    -    public final static HashMap<Integer, String> cmd2String =\n    +    final static HashMap<Integer, String> cmd2String =\n    --- End diff --\n    \n    Same here, we can also define this as Map to keep consistent with the others.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-09T19:54:29.372+0000","updated":"2016-11-09T19:54:29.372+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15651881","id":"15651881","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user lvfangmin commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87264725\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/DataTree.java ---\n    @@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {\n          * @param pwriter the output to write to\n          */\n         public void dumpEphemerals(PrintWriter pwriter) {\n    -        Set<Long> keys = ephemerals.keySet();\n             pwriter.println(\"Sessions with Ephemerals (\"\n    -                + keys.size() + \"):\");\n    -        for (long k : keys) {\n    -            pwriter.print(\"0x\" + Long.toHexString(k));\n    +                + ephemerals.keySet().size() + \"):\");\n    +        for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {\n    +            pwriter.print(\"0x\" + Long.toHexString(entry.getKey()));\n                 pwriter.println(\":\");\n    -            HashSet<String> tmp = ephemerals.get(k);\n    +            HashSet<String> tmp = entry.getValue();\n    --- End diff --\n    \n    Usually, prefer to use the interface if we only use the methods defined in the interface, which makes it flexible (or less change needed) in case we want to use another Set implementation. \n    \n    There is a best practice defined in Effective Java 2nd Edition, Item 52: Refer to objects by their interfaces:\n    If appropriate interface types exist, then parameters, return values, and fields should all be declared using interface types. If you get into the habit of using interface types, your program will be much more flexible. It is entirely appropriate to refer to an object by a class if no appropriate interface exists.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-09T19:54:29.373+0000","updated":"2016-11-09T19:54:29.373+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15654879","id":"15654879","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r87466839\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/DataTree.java ---\n    @@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {\n          * @param pwriter the output to write to\n          */\n         public void dumpEphemerals(PrintWriter pwriter) {\n    -        Set<Long> keys = ephemerals.keySet();\n             pwriter.println(\"Sessions with Ephemerals (\"\n    -                + keys.size() + \"):\");\n    -        for (long k : keys) {\n    -            pwriter.print(\"0x\" + Long.toHexString(k));\n    +                + ephemerals.keySet().size() + \"):\");\n    +        for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {\n    +            pwriter.print(\"0x\" + Long.toHexString(entry.getKey()));\n                 pwriter.println(\":\");\n    -            HashSet<String> tmp = ephemerals.get(k);\n    +            HashSet<String> tmp = entry.getValue();\n    --- End diff --\n    \n    Ya @lvfangmin, one of my favourite books on Java, and was the reference to my comment above. Thanks pointing out. :smiley:\n    \n    Agree with @hanm, better to create a separate issue for dealing with this legacy technical debt. :+1: \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-10T19:23:04.858+0000","updated":"2016-11-10T19:23:04.858+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15668655","id":"15668655","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm closed the pull request at:\n\n    https://github.com/apache/zookeeper/pull/102\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-15T22:58:20.496+0000","updated":"2016-11-15T22:58:20.496+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15668685","id":"15668685","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"GitHub user hanm reopened a pull request:\n\n    https://github.com/apache/zookeeper/pull/102\n\n    ZOOKEEPER-2628: Fix findbug warnings.\n\n    This PR fixed 19 find bug warnings except this one, which might require interface change that potentially could break client side apps.\n    \n    Malicious code vulnerability Warnings\n    org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE is a mutable collection\n    Bug type MS_MUTABLE_COLLECTION (click for details) \n    In class org.apache.zookeeper.ZooDefs$Ids\n    Field org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE\n    At ZooDefs.java:[line 116]\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/hanm/zookeeper ZOOKEEPER-2628\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/zookeeper/pull/102.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #102\n    \n----\ncommit fbb0957167f42ba64ab3eab15fae4b8dce9b0f4b\nAuthor: Michael Han <hanm@cloudera.com>\nDate:   2016-11-15T23:09:02Z\n\n    ZOOKEEPER-2628: Fix findbug warnings.\n\n----\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-15T23:09:53.498+0000","updated":"2016-11-15T23:09:53.498+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15668696","id":"15668696","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/102\n  \n    Update: disable \"Malicious code vulnerability Warnings\" appertains to org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE, and we will use ZOOKEEPER-1362 for this work.\n    \n    Can we get this merged? Would be good to have findbug clean again for pre-commit builds.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-15T23:14:54.424+0000","updated":"2016-11-15T23:14:54.424+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15668708","id":"15668708","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +0 tests included.  The patch appears to be a documentation patch that doesn't require tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    -1 findbugs.  The patch appears to introduce 20 new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    +1 core tests.  The patch passed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-15T23:20:04.685+0000","updated":"2016-11-15T23:20:04.685+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15668763","id":"15668763","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +1 tests included.  The patch appears to include 3 new or modified tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-15T23:39:53.955+0000","updated":"2016-11-15T23:39:53.955+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689655","id":"15689655","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89283699\n  \n    --- Diff: src/java/main/org/apache/zookeeper/cli/DeleteCommand.java ---\n    @@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {\n         }\n     \n         private void retainCompatibility(String[] cmdArgs) throws CliParseException {\n    -        // delete path [version]\n             if (args.length > 2) {\n    -            // rewrite to option\n    -            String [] newCmd = new String[4];\n    --- End diff --\n    \n    Why are we removing this rewrite?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:13:56.341+0000","updated":"2016-11-23T10:13:56.341+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689656","id":"15689656","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89284431\n  \n    --- Diff: src/java/test/config/findbugsExcludeFile.xml ---\n    @@ -144,4 +144,10 @@\n         <Bug pattern=\"DM_DEFAULT_ENCODING\" />\n       </Match>\n     \n    +  <!-- Disable 'Malicious code vulnerability warnings' due to mutable collection types in interface.\n    --- End diff --\n    \n    We probably want to leave a note in ZOOKEEPER-1362 to remind ourselves to do it.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:13:56.397+0000","updated":"2016-11-23T10:13:56.397+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689657","id":"15689657","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89285632\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/JRecord.java ---\n    @@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {\n             } else if (!outputDirectory.isDirectory()) {\n                 throw new IOException(outputDirectory + \" is not a directory.\");\n             }\n    -        File csharpFile = new File(outputDirectory, getName()+\".cs\");\n    -        FileWriter cs = new FileWriter(csharpFile);\n    -        cs.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    -        cs.write(\"/**\\n\");\n    -        cs.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        cs.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        cs.write(\"* distributed with this work for additional information\\n\");\n    -        cs.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        cs.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        cs.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        cs.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        cs.write(\"*\\n\");\n    -        cs.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        cs.write(\"*\\n\");\n    -        cs.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        cs.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        cs.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        cs.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        cs.write(\"* limitations under the License.\\n\");\n    -        cs.write(\"*/\\n\");\n    -        cs.write(\"\\n\");\n    -        cs.write(\"using System;\\n\");\n    -        cs.write(\"using Org.Apache.Jute;\\n\");\n    -        cs.write(\"\\n\");        \n    -        cs.write(\"namespace \"+getCsharpNameSpace()+\"\\n\");\n    -        cs.write(\"{\\n\");\n    -\n    -        String className = getCsharpName();\n    -        cs.write(\"public class \"+className+\" : IRecord, IComparable \\n\");\n    -        cs.write(\"{\\n\");\n    -        cs.write(\"  public \"+ className +\"() {\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public \"+className+\"(\\n\");\n    -        int fIdx = 0;\n    -        int fLen = mFields.size();\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));\n    -            cs.write((fLen-1 == fIdx)?\"\":\",\\n\");\n    -        }\n    -        cs.write(\") {\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));\n    -        }\n    -        cs.write(\"  }\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpGetSet(fIdx));\n    +\n    +        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + \".cs\"));) {\n    +            cs.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    +            cs.write(\"/**\\n\");\n    +            cs.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            cs.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            cs.write(\"* distributed with this work for additional information\\n\");\n    +            cs.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            cs.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            cs.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            cs.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            cs.write(\"*\\n\");\n    +            cs.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            cs.write(\"*\\n\");\n    +            cs.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            cs.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            cs.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            cs.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            cs.write(\"* limitations under the License.\\n\");\n    +            cs.write(\"*/\\n\");\n                 cs.write(\"\\n\");\n    -        }\n    -        cs.write(\"  public void Serialize(IOutputArchive a_, String tag) {\\n\");\n    -        cs.write(\"    a_.StartRecord(this,tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpWriteMethodName());\n    -        }\n    -        cs.write(\"    a_.EndRecord(this,tag);\\n\");\n    -        cs.write(\"  }\\n\");\n    +            cs.write(\"using System;\\n\");\n    +            cs.write(\"using Org.Apache.Jute;\\n\");\n    +            cs.write(\"\\n\");\n    +            cs.write(\"namespace \" + getCsharpNameSpace() + \"\\n\");\n    +            cs.write(\"{\\n\");\n    +\n    +            String className = getCsharpName();\n    +            cs.write(\"public class \" + className + \" : IRecord, IComparable \\n\");\n    +            cs.write(\"{\\n\");\n    +            cs.write(\"  public \" + className + \"() {\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public \" + className + \"(\\n\");\n    +            int fIdx = 0;\n    +            int fLen = mFields.size();\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));\n    +                cs.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n    +            }\n    +            cs.write(\") {\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));\n    +            }\n    +            cs.write(\"  }\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpGetSet(fIdx));\n    +                cs.write(\"\\n\");\n    +            }\n    +            cs.write(\"  public void Serialize(IOutputArchive a_, String tag) {\\n\");\n    +            cs.write(\"    a_.StartRecord(this,tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpWriteMethodName());\n    +            }\n    +            cs.write(\"    a_.EndRecord(this,tag);\\n\");\n    +            cs.write(\"  }\\n\");\n     \n    -        cs.write(\"  public void Deserialize(IInputArchive a_, String tag) {\\n\");\n    -        cs.write(\"    a_.StartRecord(tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpReadMethodName());\n    -        }\n    -        cs.write(\"    a_.EndRecord(tag);\\n\");\n    -        cs.write(\"}\\n\");\n    -\n    -        cs.write(\"  public override String ToString() {\\n\");\n    -        cs.write(\"    try {\\n\");\n    -        cs.write(\"      System.IO.MemoryStream ms = new System.IO.MemoryStream();\\n\");\n    -        cs.write(\"      MiscUtil.IO.EndianBinaryWriter writer =\\n\");\n    -        cs.write(\"        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\\n\");\n    -        cs.write(\"      BinaryOutputArchive a_ = \\n\");\n    -        cs.write(\"        new BinaryOutputArchive(writer);\\n\");\n    -        cs.write(\"      a_.StartRecord(this,\\\"\\\");\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpWriteMethodName());\n    -        }\n    -        cs.write(\"      a_.EndRecord(this,\\\"\\\");\\n\");\n    -        cs.write(\"      ms.Position = 0;\\n\");\n    -        cs.write(\"      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\\n\");\n    -        cs.write(\"    } catch (Exception ex) {\\n\");\n    -        cs.write(\"      Console.WriteLine(ex.StackTrace);\\n\");\n    -        cs.write(\"    }\\n\");\n    -        cs.write(\"    return \\\"ERROR\\\";\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\\n\");\n    -        cs.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\\n\");\n    -        cs.write(\"    Serialize(archive, \\\"\\\");\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\\n\");\n    -        cs.write(\"    BinaryInputArchive archive = new BinaryInputArchive(reader);\\n\");\n    -        cs.write(\"    Deserialize(archive, \\\"\\\");\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public int CompareTo (object peer_) {\\n\");\n    -        boolean unimplemented = false;\n    -        for (JField f : mFields) {\n    -            if ((f.getType() instanceof JMap)\n    -                    || (f.getType() instanceof JVector))\n    -            {\n    -                unimplemented = true;\n    +            cs.write(\"  public void Deserialize(IInputArchive a_, String tag) {\\n\");\n    +            cs.write(\"    a_.StartRecord(tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpReadMethodName());\n                 }\n    -        }\n    -        if (unimplemented) {\n    -            cs.write(\"    throw new InvalidOperationException(\\\"comparing \"\n    -                    + getCsharpName() + \" is unimplemented\\\");\\n\");\n    -        } else {\n    -            cs.write(\"    if (!(peer_ is \"+getCsharpName()+\")) {\\n\");\n    -            cs.write(\"      throw new InvalidOperationException(\\\"Comparing different types of records.\\\");\\n\");\n    +            cs.write(\"    a_.EndRecord(tag);\\n\");\n    +            cs.write(\"}\\n\");\n    +\n    +            cs.write(\"  public override String ToString() {\\n\");\n    +            cs.write(\"    try {\\n\");\n    +            cs.write(\"      System.IO.MemoryStream ms = new System.IO.MemoryStream();\\n\");\n    +            cs.write(\"      MiscUtil.IO.EndianBinaryWriter writer =\\n\");\n    +            cs.write(\"        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\\n\");\n    +            cs.write(\"      BinaryOutputArchive a_ = \\n\");\n    +            cs.write(\"        new BinaryOutputArchive(writer);\\n\");\n    +            cs.write(\"      a_.StartRecord(this,\\\"\\\");\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpWriteMethodName());\n    +            }\n    +            cs.write(\"      a_.EndRecord(this,\\\"\\\");\\n\");\n    +            cs.write(\"      ms.Position = 0;\\n\");\n    +            cs.write(\"      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\\n\");\n    +            cs.write(\"    } catch (Exception ex) {\\n\");\n    +            cs.write(\"      Console.WriteLine(ex.StackTrace);\\n\");\n                 cs.write(\"    }\\n\");\n    -            cs.write(\"    \"+getCsharpName()+\" peer = (\"+getCsharpName()+\") peer_;\\n\");\n    -            cs.write(\"    int ret = 0;\\n\");\n    +            cs.write(\"    return \\\"ERROR\\\";\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\\n\");\n    +            cs.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\\n\");\n    +            cs.write(\"    Serialize(archive, \\\"\\\");\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\\n\");\n    +            cs.write(\"    BinaryInputArchive archive = new BinaryInputArchive(reader);\\n\");\n    +            cs.write(\"    Deserialize(archive, \\\"\\\");\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public int CompareTo (object peer_) {\\n\");\n    +            boolean unimplemented = false;\n    +            for (JField f : mFields) {\n    +                if ((f.getType() instanceof JMap)\n    +                        || (f.getType() instanceof JVector)) {\n    +                    unimplemented = true;\n    +                }\n    +            }\n    +            if (unimplemented) {\n    +                cs.write(\"    throw new InvalidOperationException(\\\"comparing \"\n    +                        + getCsharpName() + \" is unimplemented\\\");\\n\");\n    +            } else {\n    +                cs.write(\"    if (!(peer_ is \" + getCsharpName() + \")) {\\n\");\n    +                cs.write(\"      throw new InvalidOperationException(\\\"Comparing different types of records.\\\");\\n\");\n    +                cs.write(\"    }\\n\");\n    +                cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \") peer_;\\n\");\n    +                cs.write(\"    int ret = 0;\\n\");\n    +                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                    JField jf = i.next();\n    +                    cs.write(jf.genCsharpCompareTo());\n    +                    cs.write(\"    if (ret != 0) return ret;\\n\");\n    +                }\n    +                cs.write(\"     return ret;\\n\");\n    +            }\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public override bool Equals(object peer_) {\\n\");\n    +            cs.write(\"    if (!(peer_ is \" + getCsharpName() + \")) {\\n\");\n    +            cs.write(\"      return false;\\n\");\n    +            cs.write(\"    }\\n\");\n    +            cs.write(\"    if (peer_ == this) {\\n\");\n    +            cs.write(\"      return true;\\n\");\n    +            cs.write(\"    }\\n\");\n    +            cs.write(\"    bool ret = false;\\n\");\n    +            cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \")peer_;\\n\");\n                 for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n                     JField jf = i.next();\n    -                cs.write(jf.genCsharpCompareTo());\n    -                cs.write(\"    if (ret != 0) return ret;\\n\");\n    +                cs.write(jf.genCsharpEquals());\n    --- End diff --\n    \n    What's the reason for changing to `genCsharpEquals`? I suppose is is the same reason for changing to `genJavaEquals`...\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:13:56.398+0000","updated":"2016-11-23T10:13:56.398+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689658","id":"15689658","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89264869\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/JRecord.java ---\n    @@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {\n             } else if (!pkgdir.isDirectory()) {\n                 throw new IOException(pkgpath + \" is not a directory.\");\n             }\n    -        File jfile = new File(pkgdir, getName()+\".java\");\n    -        FileWriter jj = new FileWriter(jfile);\n    -        jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    -        jj.write(\"/**\\n\");\n    -        jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        jj.write(\"* distributed with this work for additional information\\n\");\n    -        jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        jj.write(\"*\\n\");\n    -        jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        jj.write(\"*\\n\");\n    -        jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        jj.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        jj.write(\"* limitations under the License.\\n\");\n    -        jj.write(\"*/\\n\");\n    -        jj.write(\"\\n\");\n    -        jj.write(\"package \"+getJavaPackage()+\";\\n\\n\");\n    -        jj.write(\"import org.apache.jute.*;\\n\");\n    -        jj.write(\"public class \"+getName()+\" implements Record {\\n\");\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaDecl());\n    -        }\n    -        jj.write(\"  public \"+getName()+\"() {\\n\");\n    -        jj.write(\"  }\\n\");\n    +        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+\".java\"))) {\n    +            jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    +            jj.write(\"/**\\n\");\n    +            jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            jj.write(\"* distributed with this work for additional information\\n\");\n    +            jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            jj.write(\"*\\n\");\n    +            jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            jj.write(\"*\\n\");\n    +            jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            jj.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            jj.write(\"* limitations under the License.\\n\");\n    +            jj.write(\"*/\\n\");\n    +            jj.write(\"\\n\");\n    +            jj.write(\"package \" + getJavaPackage() + \";\\n\\n\");\n    +            jj.write(\"import org.apache.jute.*;\\n\");\n    +            jj.write(\"public class \" + getName() + \" implements Record {\\n\");\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaDecl());\n    +            }\n    +            jj.write(\"  public \" + getName() + \"() {\\n\");\n    +            jj.write(\"  }\\n\");\n     \n    -        jj.write(\"  public \"+getName()+\"(\\n\");\n    -        int fIdx = 0;\n    -        int fLen = mFields.size();\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaConstructorParam(jf.getName()));\n    -            jj.write((fLen-1 == fIdx)?\"\":\",\\n\");\n    -        }\n    -        jj.write(\") {\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaConstructorSet(jf.getName()));\n    -        }\n    -        jj.write(\"  }\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaGetSet(fIdx));\n    -        }\n    -        jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n    -        jj.write(\"    a_.startRecord(this,tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaWriteMethodName());\n    -        }\n    -        jj.write(\"    a_.endRecord(this,tag);\\n\");\n    -        jj.write(\"  }\\n\");\n    +            jj.write(\"  public \" + getName() + \"(\\n\");\n    +            int fIdx = 0;\n    +            int fLen = mFields.size();\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaConstructorParam(jf.getName()));\n    +                jj.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n    +            }\n    +            jj.write(\") {\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaConstructorSet(jf.getName()));\n    +            }\n    +            jj.write(\"  }\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaGetSet(fIdx));\n    +            }\n    +            jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n    +            jj.write(\"    a_.startRecord(this,tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaWriteMethodName());\n    +            }\n    +            jj.write(\"    a_.endRecord(this,tag);\\n\");\n    +            jj.write(\"  }\\n\");\n     \n    -        jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n    -        jj.write(\"    a_.startRecord(tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaReadMethodName());\n    -        }\n    -        jj.write(\"    a_.endRecord(tag);\\n\");\n    -        jj.write(\"}\\n\");\n    -\n    -        jj.write(\"  public String toString() {\\n\");\n    -        jj.write(\"    try {\\n\");\n    -        jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n    -        jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n    -        jj.write(\"      CsvOutputArchive a_ = \\n\");\n    -        jj.write(\"        new CsvOutputArchive(s);\\n\");\n    -        jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaWriteMethodName());\n    -        }\n    -        jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n    -        jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n    -        jj.write(\"    } catch (Throwable ex) {\\n\");\n    -        jj.write(\"      ex.printStackTrace();\\n\");\n    -        jj.write(\"    }\\n\");\n    -        jj.write(\"    return \\\"ERROR\\\";\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n    -        jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n    -        jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n    -        jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n    -        jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n    -        boolean unimplemented = false;\n    -        for (JField f : mFields) {\n    -            if ((f.getType() instanceof JMap)\n    -                    || (f.getType() instanceof JVector))\n    -            {\n    -                unimplemented = true;\n    +            jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n    +            jj.write(\"    a_.startRecord(tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaReadMethodName());\n                 }\n    -        }\n    -        if (unimplemented) {\n    -            jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n    -                    + getName() + \" is unimplemented\\\");\\n\");\n    -        } else {\n    -            jj.write(\"    if (!(peer_ instanceof \"+getName()+\")) {\\n\");\n    -            jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n    +            jj.write(\"    a_.endRecord(tag);\\n\");\n    +            jj.write(\"}\\n\");\n    +\n    +            jj.write(\"  public String toString() {\\n\");\n    +            jj.write(\"    try {\\n\");\n    +            jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n    +            jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n    +            jj.write(\"      CsvOutputArchive a_ = \\n\");\n    +            jj.write(\"        new CsvOutputArchive(s);\\n\");\n    +            jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaWriteMethodName());\n    +            }\n    +            jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n    +            jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n    +            jj.write(\"    } catch (Throwable ex) {\\n\");\n    +            jj.write(\"      ex.printStackTrace();\\n\");\n                 jj.write(\"    }\\n\");\n    -            jj.write(\"    \"+getName()+\" peer = (\"+getName()+\") peer_;\\n\");\n    -            jj.write(\"    int ret = 0;\\n\");\n    +            jj.write(\"    return \\\"ERROR\\\";\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n    +            jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n    +            jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n    +            jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n    +            jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n    +            boolean unimplemented = false;\n    +            for (JField f : mFields) {\n    +                if ((f.getType() instanceof JMap)\n    +                        || (f.getType() instanceof JVector)) {\n    +                    unimplemented = true;\n    +                }\n    +            }\n    +            if (unimplemented) {\n    +                jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n    +                        + getName() + \" is unimplemented\\\");\\n\");\n    +            } else {\n    +                jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n    +                jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n    +                jj.write(\"    }\\n\");\n    +                jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n    +                jj.write(\"    int ret = 0;\\n\");\n    +                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                    JField jf = i.next();\n    +                    jj.write(jf.genJavaCompareTo());\n    --- End diff --\n    \n    Why are we changing to `genJavaEquals` below and not here?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:13:56.417+0000","updated":"2016-11-23T10:13:56.417+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689659","id":"15689659","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89264584\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/JRecord.java ---\n    @@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {\n             } else if (!pkgdir.isDirectory()) {\n                 throw new IOException(pkgpath + \" is not a directory.\");\n             }\n    -        File jfile = new File(pkgdir, getName()+\".java\");\n    -        FileWriter jj = new FileWriter(jfile);\n    -        jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    -        jj.write(\"/**\\n\");\n    -        jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        jj.write(\"* distributed with this work for additional information\\n\");\n    -        jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        jj.write(\"*\\n\");\n    -        jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        jj.write(\"*\\n\");\n    -        jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        jj.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        jj.write(\"* limitations under the License.\\n\");\n    -        jj.write(\"*/\\n\");\n    -        jj.write(\"\\n\");\n    -        jj.write(\"package \"+getJavaPackage()+\";\\n\\n\");\n    -        jj.write(\"import org.apache.jute.*;\\n\");\n    -        jj.write(\"public class \"+getName()+\" implements Record {\\n\");\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaDecl());\n    -        }\n    -        jj.write(\"  public \"+getName()+\"() {\\n\");\n    -        jj.write(\"  }\\n\");\n    +        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+\".java\"))) {\n    +            jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    +            jj.write(\"/**\\n\");\n    +            jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            jj.write(\"* distributed with this work for additional information\\n\");\n    +            jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            jj.write(\"*\\n\");\n    +            jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            jj.write(\"*\\n\");\n    +            jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            jj.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            jj.write(\"* limitations under the License.\\n\");\n    +            jj.write(\"*/\\n\");\n    +            jj.write(\"\\n\");\n    +            jj.write(\"package \" + getJavaPackage() + \";\\n\\n\");\n    +            jj.write(\"import org.apache.jute.*;\\n\");\n    +            jj.write(\"public class \" + getName() + \" implements Record {\\n\");\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaDecl());\n    +            }\n    +            jj.write(\"  public \" + getName() + \"() {\\n\");\n    +            jj.write(\"  }\\n\");\n     \n    -        jj.write(\"  public \"+getName()+\"(\\n\");\n    -        int fIdx = 0;\n    -        int fLen = mFields.size();\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaConstructorParam(jf.getName()));\n    -            jj.write((fLen-1 == fIdx)?\"\":\",\\n\");\n    -        }\n    -        jj.write(\") {\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaConstructorSet(jf.getName()));\n    -        }\n    -        jj.write(\"  }\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaGetSet(fIdx));\n    -        }\n    -        jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n    -        jj.write(\"    a_.startRecord(this,tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaWriteMethodName());\n    -        }\n    -        jj.write(\"    a_.endRecord(this,tag);\\n\");\n    -        jj.write(\"  }\\n\");\n    +            jj.write(\"  public \" + getName() + \"(\\n\");\n    +            int fIdx = 0;\n    +            int fLen = mFields.size();\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaConstructorParam(jf.getName()));\n    +                jj.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n    +            }\n    +            jj.write(\") {\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaConstructorSet(jf.getName()));\n    +            }\n    +            jj.write(\"  }\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaGetSet(fIdx));\n    +            }\n    +            jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n    +            jj.write(\"    a_.startRecord(this,tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaWriteMethodName());\n    +            }\n    +            jj.write(\"    a_.endRecord(this,tag);\\n\");\n    +            jj.write(\"  }\\n\");\n     \n    -        jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n    -        jj.write(\"    a_.startRecord(tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaReadMethodName());\n    -        }\n    -        jj.write(\"    a_.endRecord(tag);\\n\");\n    -        jj.write(\"}\\n\");\n    -\n    -        jj.write(\"  public String toString() {\\n\");\n    -        jj.write(\"    try {\\n\");\n    -        jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n    -        jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n    -        jj.write(\"      CsvOutputArchive a_ = \\n\");\n    -        jj.write(\"        new CsvOutputArchive(s);\\n\");\n    -        jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaWriteMethodName());\n    -        }\n    -        jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n    -        jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n    -        jj.write(\"    } catch (Throwable ex) {\\n\");\n    -        jj.write(\"      ex.printStackTrace();\\n\");\n    -        jj.write(\"    }\\n\");\n    -        jj.write(\"    return \\\"ERROR\\\";\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n    -        jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n    -        jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n    -        jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n    -        jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n    -        boolean unimplemented = false;\n    -        for (JField f : mFields) {\n    -            if ((f.getType() instanceof JMap)\n    -                    || (f.getType() instanceof JVector))\n    -            {\n    -                unimplemented = true;\n    +            jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n    +            jj.write(\"    a_.startRecord(tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaReadMethodName());\n                 }\n    -        }\n    -        if (unimplemented) {\n    -            jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n    -                    + getName() + \" is unimplemented\\\");\\n\");\n    -        } else {\n    -            jj.write(\"    if (!(peer_ instanceof \"+getName()+\")) {\\n\");\n    -            jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n    +            jj.write(\"    a_.endRecord(tag);\\n\");\n    +            jj.write(\"}\\n\");\n    +\n    +            jj.write(\"  public String toString() {\\n\");\n    +            jj.write(\"    try {\\n\");\n    +            jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n    +            jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n    +            jj.write(\"      CsvOutputArchive a_ = \\n\");\n    +            jj.write(\"        new CsvOutputArchive(s);\\n\");\n    +            jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaWriteMethodName());\n    +            }\n    +            jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n    +            jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n    +            jj.write(\"    } catch (Throwable ex) {\\n\");\n    +            jj.write(\"      ex.printStackTrace();\\n\");\n                 jj.write(\"    }\\n\");\n    -            jj.write(\"    \"+getName()+\" peer = (\"+getName()+\") peer_;\\n\");\n    -            jj.write(\"    int ret = 0;\\n\");\n    +            jj.write(\"    return \\\"ERROR\\\";\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n    +            jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n    +            jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n    +            jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n    +            jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n    +            boolean unimplemented = false;\n    +            for (JField f : mFields) {\n    +                if ((f.getType() instanceof JMap)\n    +                        || (f.getType() instanceof JVector)) {\n    +                    unimplemented = true;\n    +                }\n    +            }\n    +            if (unimplemented) {\n    +                jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n    +                        + getName() + \" is unimplemented\\\");\\n\");\n    +            } else {\n    +                jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n    +                jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n    +                jj.write(\"    }\\n\");\n    +                jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n    +                jj.write(\"    int ret = 0;\\n\");\n    +                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                    JField jf = i.next();\n    +                    jj.write(jf.genJavaCompareTo());\n    +                    jj.write(\"    if (ret != 0) return ret;\\n\");\n    +                }\n    +                jj.write(\"     return ret;\\n\");\n    +            }\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public boolean equals(Object peer_) {\\n\");\n    +            jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n    +            jj.write(\"      return false;\\n\");\n    +            jj.write(\"    }\\n\");\n    +            jj.write(\"    if (peer_ == this) {\\n\");\n    +            jj.write(\"      return true;\\n\");\n    +            jj.write(\"    }\\n\");\n    +            jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n    +            jj.write(\"    boolean ret = false;\\n\");\n                 for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n                     JField jf = i.next();\n    -                jj.write(jf.genJavaCompareTo());\n    -                jj.write(\"    if (ret != 0) return ret;\\n\");\n    +                jj.write(jf.genJavaEquals());\n    --- End diff --\n    \n    What's the reason for changing to `genJavaEquals`?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:13:56.418+0000","updated":"2016-11-23T10:13:56.418+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689660","id":"15689660","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89283922\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java ---\n    @@ -151,9 +153,13 @@\n          */\n         public final static int telnetCloseCmd = 0xfff4fffd;\n     \n    -    public final static HashMap<Integer, String> cmd2String =\n    +    final static HashMap<Integer, String> cmd2String =\n    --- End diff --\n    \n    If we can remove this `public`, then I think we should. Also agree with the consistent `Map` declaration comment.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:13:56.418+0000","updated":"2016-11-23T10:13:56.418+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689664","id":"15689664","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/102\n  \n    @hanm I've left a few comments, but in general looks pretty good. I noticed that there are also unaddressed comments from @lvfangmin and @eribeiro . Could you take care of those so that we can check this in, please?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:15:16.668+0000","updated":"2016-11-23T10:15:16.668+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15689676","id":"15689676","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user eribeiro commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89287398\n  \n    --- Diff: src/java/test/config/findbugsExcludeFile.xml ---\n    @@ -144,4 +144,10 @@\n         <Bug pattern=\"DM_DEFAULT_ENCODING\" />\n       </Match>\n     \n    +  <!-- Disable 'Malicious code vulnerability warnings' due to mutable collection types in interface.\n    --- End diff --\n    \n    Gonna say that! At least a TODO mark I guess...\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T10:21:55.592+0000","updated":"2016-11-23T10:21:55.592+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15690675","id":"15690675","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89355986\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/JRecord.java ---\n    @@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {\n             } else if (!pkgdir.isDirectory()) {\n                 throw new IOException(pkgpath + \" is not a directory.\");\n             }\n    -        File jfile = new File(pkgdir, getName()+\".java\");\n    -        FileWriter jj = new FileWriter(jfile);\n    -        jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    -        jj.write(\"/**\\n\");\n    -        jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        jj.write(\"* distributed with this work for additional information\\n\");\n    -        jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        jj.write(\"*\\n\");\n    -        jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        jj.write(\"*\\n\");\n    -        jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        jj.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        jj.write(\"* limitations under the License.\\n\");\n    -        jj.write(\"*/\\n\");\n    -        jj.write(\"\\n\");\n    -        jj.write(\"package \"+getJavaPackage()+\";\\n\\n\");\n    -        jj.write(\"import org.apache.jute.*;\\n\");\n    -        jj.write(\"public class \"+getName()+\" implements Record {\\n\");\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaDecl());\n    -        }\n    -        jj.write(\"  public \"+getName()+\"() {\\n\");\n    -        jj.write(\"  }\\n\");\n    +        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+\".java\"))) {\n    +            jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    +            jj.write(\"/**\\n\");\n    +            jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            jj.write(\"* distributed with this work for additional information\\n\");\n    +            jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            jj.write(\"*\\n\");\n    +            jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            jj.write(\"*\\n\");\n    +            jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            jj.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            jj.write(\"* limitations under the License.\\n\");\n    +            jj.write(\"*/\\n\");\n    +            jj.write(\"\\n\");\n    +            jj.write(\"package \" + getJavaPackage() + \";\\n\\n\");\n    +            jj.write(\"import org.apache.jute.*;\\n\");\n    +            jj.write(\"public class \" + getName() + \" implements Record {\\n\");\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaDecl());\n    +            }\n    +            jj.write(\"  public \" + getName() + \"() {\\n\");\n    +            jj.write(\"  }\\n\");\n     \n    -        jj.write(\"  public \"+getName()+\"(\\n\");\n    -        int fIdx = 0;\n    -        int fLen = mFields.size();\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaConstructorParam(jf.getName()));\n    -            jj.write((fLen-1 == fIdx)?\"\":\",\\n\");\n    -        }\n    -        jj.write(\") {\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaConstructorSet(jf.getName()));\n    -        }\n    -        jj.write(\"  }\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaGetSet(fIdx));\n    -        }\n    -        jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n    -        jj.write(\"    a_.startRecord(this,tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaWriteMethodName());\n    -        }\n    -        jj.write(\"    a_.endRecord(this,tag);\\n\");\n    -        jj.write(\"  }\\n\");\n    +            jj.write(\"  public \" + getName() + \"(\\n\");\n    +            int fIdx = 0;\n    +            int fLen = mFields.size();\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaConstructorParam(jf.getName()));\n    +                jj.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n    +            }\n    +            jj.write(\") {\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaConstructorSet(jf.getName()));\n    +            }\n    +            jj.write(\"  }\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaGetSet(fIdx));\n    +            }\n    +            jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n    +            jj.write(\"    a_.startRecord(this,tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaWriteMethodName());\n    +            }\n    +            jj.write(\"    a_.endRecord(this,tag);\\n\");\n    +            jj.write(\"  }\\n\");\n     \n    -        jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n    -        jj.write(\"    a_.startRecord(tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaReadMethodName());\n    -        }\n    -        jj.write(\"    a_.endRecord(tag);\\n\");\n    -        jj.write(\"}\\n\");\n    -\n    -        jj.write(\"  public String toString() {\\n\");\n    -        jj.write(\"    try {\\n\");\n    -        jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n    -        jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n    -        jj.write(\"      CsvOutputArchive a_ = \\n\");\n    -        jj.write(\"        new CsvOutputArchive(s);\\n\");\n    -        jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            jj.write(jf.genJavaWriteMethodName());\n    -        }\n    -        jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n    -        jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n    -        jj.write(\"    } catch (Throwable ex) {\\n\");\n    -        jj.write(\"      ex.printStackTrace();\\n\");\n    -        jj.write(\"    }\\n\");\n    -        jj.write(\"    return \\\"ERROR\\\";\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n    -        jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n    -        jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n    -        jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n    -        jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n    -        jj.write(\"  }\\n\");\n    -\n    -        jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n    -        boolean unimplemented = false;\n    -        for (JField f : mFields) {\n    -            if ((f.getType() instanceof JMap)\n    -                    || (f.getType() instanceof JVector))\n    -            {\n    -                unimplemented = true;\n    +            jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n    +            jj.write(\"    a_.startRecord(tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaReadMethodName());\n                 }\n    -        }\n    -        if (unimplemented) {\n    -            jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n    -                    + getName() + \" is unimplemented\\\");\\n\");\n    -        } else {\n    -            jj.write(\"    if (!(peer_ instanceof \"+getName()+\")) {\\n\");\n    -            jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n    +            jj.write(\"    a_.endRecord(tag);\\n\");\n    +            jj.write(\"}\\n\");\n    +\n    +            jj.write(\"  public String toString() {\\n\");\n    +            jj.write(\"    try {\\n\");\n    +            jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n    +            jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n    +            jj.write(\"      CsvOutputArchive a_ = \\n\");\n    +            jj.write(\"        new CsvOutputArchive(s);\\n\");\n    +            jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                jj.write(jf.genJavaWriteMethodName());\n    +            }\n    +            jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n    +            jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n    +            jj.write(\"    } catch (Throwable ex) {\\n\");\n    +            jj.write(\"      ex.printStackTrace();\\n\");\n                 jj.write(\"    }\\n\");\n    -            jj.write(\"    \"+getName()+\" peer = (\"+getName()+\") peer_;\\n\");\n    -            jj.write(\"    int ret = 0;\\n\");\n    +            jj.write(\"    return \\\"ERROR\\\";\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n    +            jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n    +            jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n    +            jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n    +            jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n    +            boolean unimplemented = false;\n    +            for (JField f : mFields) {\n    +                if ((f.getType() instanceof JMap)\n    +                        || (f.getType() instanceof JVector)) {\n    +                    unimplemented = true;\n    +                }\n    +            }\n    +            if (unimplemented) {\n    +                jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n    +                        + getName() + \" is unimplemented\\\");\\n\");\n    +            } else {\n    +                jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n    +                jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n    +                jj.write(\"    }\\n\");\n    +                jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n    +                jj.write(\"    int ret = 0;\\n\");\n    +                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                    JField jf = i.next();\n    +                    jj.write(jf.genJavaCompareTo());\n    +                    jj.write(\"    if (ret != 0) return ret;\\n\");\n    +                }\n    +                jj.write(\"     return ret;\\n\");\n    +            }\n    +            jj.write(\"  }\\n\");\n    +\n    +            jj.write(\"  public boolean equals(Object peer_) {\\n\");\n    +            jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n    +            jj.write(\"      return false;\\n\");\n    +            jj.write(\"    }\\n\");\n    +            jj.write(\"    if (peer_ == this) {\\n\");\n    +            jj.write(\"      return true;\\n\");\n    +            jj.write(\"    }\\n\");\n    +            jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n    +            jj.write(\"    boolean ret = false;\\n\");\n                 for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n                     JField jf = i.next();\n    -                jj.write(jf.genJavaCompareTo());\n    -                jj.write(\"    if (ret != 0) return ret;\\n\");\n    +                jj.write(jf.genJavaEquals());\n    --- End diff --\n    \n    Similarly, there is no actual change here.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T16:46:48.364+0000","updated":"2016-11-23T16:46:48.364+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15690676","id":"15690676","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89356018\n  \n    --- Diff: src/java/main/org/apache/jute/compiler/JRecord.java ---\n    @@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {\n             } else if (!outputDirectory.isDirectory()) {\n                 throw new IOException(outputDirectory + \" is not a directory.\");\n             }\n    -        File csharpFile = new File(outputDirectory, getName()+\".cs\");\n    -        FileWriter cs = new FileWriter(csharpFile);\n    -        cs.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    -        cs.write(\"/**\\n\");\n    -        cs.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    -        cs.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    -        cs.write(\"* distributed with this work for additional information\\n\");\n    -        cs.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    -        cs.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    -        cs.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    -        cs.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    -        cs.write(\"*\\n\");\n    -        cs.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    -        cs.write(\"*\\n\");\n    -        cs.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    -        cs.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    -        cs.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    -        cs.write(\"* See the License for the specific language governing permissions and\\n\");\n    -        cs.write(\"* limitations under the License.\\n\");\n    -        cs.write(\"*/\\n\");\n    -        cs.write(\"\\n\");\n    -        cs.write(\"using System;\\n\");\n    -        cs.write(\"using Org.Apache.Jute;\\n\");\n    -        cs.write(\"\\n\");        \n    -        cs.write(\"namespace \"+getCsharpNameSpace()+\"\\n\");\n    -        cs.write(\"{\\n\");\n    -\n    -        String className = getCsharpName();\n    -        cs.write(\"public class \"+className+\" : IRecord, IComparable \\n\");\n    -        cs.write(\"{\\n\");\n    -        cs.write(\"  public \"+ className +\"() {\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public \"+className+\"(\\n\");\n    -        int fIdx = 0;\n    -        int fLen = mFields.size();\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));\n    -            cs.write((fLen-1 == fIdx)?\"\":\",\\n\");\n    -        }\n    -        cs.write(\") {\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));\n    -        }\n    -        cs.write(\"  }\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpGetSet(fIdx));\n    +\n    +        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + \".cs\"));) {\n    +            cs.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n    +            cs.write(\"/**\\n\");\n    +            cs.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n    +            cs.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n    +            cs.write(\"* distributed with this work for additional information\\n\");\n    +            cs.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n    +            cs.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n    +            cs.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n    +            cs.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n    +            cs.write(\"*\\n\");\n    +            cs.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n    +            cs.write(\"*\\n\");\n    +            cs.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n    +            cs.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n    +            cs.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n    +            cs.write(\"* See the License for the specific language governing permissions and\\n\");\n    +            cs.write(\"* limitations under the License.\\n\");\n    +            cs.write(\"*/\\n\");\n                 cs.write(\"\\n\");\n    -        }\n    -        cs.write(\"  public void Serialize(IOutputArchive a_, String tag) {\\n\");\n    -        cs.write(\"    a_.StartRecord(this,tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpWriteMethodName());\n    -        }\n    -        cs.write(\"    a_.EndRecord(this,tag);\\n\");\n    -        cs.write(\"  }\\n\");\n    +            cs.write(\"using System;\\n\");\n    +            cs.write(\"using Org.Apache.Jute;\\n\");\n    +            cs.write(\"\\n\");\n    +            cs.write(\"namespace \" + getCsharpNameSpace() + \"\\n\");\n    +            cs.write(\"{\\n\");\n    +\n    +            String className = getCsharpName();\n    +            cs.write(\"public class \" + className + \" : IRecord, IComparable \\n\");\n    +            cs.write(\"{\\n\");\n    +            cs.write(\"  public \" + className + \"() {\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public \" + className + \"(\\n\");\n    +            int fIdx = 0;\n    +            int fLen = mFields.size();\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));\n    +                cs.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n    +            }\n    +            cs.write(\") {\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));\n    +            }\n    +            cs.write(\"  }\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpGetSet(fIdx));\n    +                cs.write(\"\\n\");\n    +            }\n    +            cs.write(\"  public void Serialize(IOutputArchive a_, String tag) {\\n\");\n    +            cs.write(\"    a_.StartRecord(this,tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpWriteMethodName());\n    +            }\n    +            cs.write(\"    a_.EndRecord(this,tag);\\n\");\n    +            cs.write(\"  }\\n\");\n     \n    -        cs.write(\"  public void Deserialize(IInputArchive a_, String tag) {\\n\");\n    -        cs.write(\"    a_.StartRecord(tag);\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpReadMethodName());\n    -        }\n    -        cs.write(\"    a_.EndRecord(tag);\\n\");\n    -        cs.write(\"}\\n\");\n    -\n    -        cs.write(\"  public override String ToString() {\\n\");\n    -        cs.write(\"    try {\\n\");\n    -        cs.write(\"      System.IO.MemoryStream ms = new System.IO.MemoryStream();\\n\");\n    -        cs.write(\"      MiscUtil.IO.EndianBinaryWriter writer =\\n\");\n    -        cs.write(\"        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\\n\");\n    -        cs.write(\"      BinaryOutputArchive a_ = \\n\");\n    -        cs.write(\"        new BinaryOutputArchive(writer);\\n\");\n    -        cs.write(\"      a_.StartRecord(this,\\\"\\\");\\n\");\n    -        fIdx = 0;\n    -        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    -            JField jf = i.next();\n    -            cs.write(jf.genCsharpWriteMethodName());\n    -        }\n    -        cs.write(\"      a_.EndRecord(this,\\\"\\\");\\n\");\n    -        cs.write(\"      ms.Position = 0;\\n\");\n    -        cs.write(\"      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\\n\");\n    -        cs.write(\"    } catch (Exception ex) {\\n\");\n    -        cs.write(\"      Console.WriteLine(ex.StackTrace);\\n\");\n    -        cs.write(\"    }\\n\");\n    -        cs.write(\"    return \\\"ERROR\\\";\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\\n\");\n    -        cs.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\\n\");\n    -        cs.write(\"    Serialize(archive, \\\"\\\");\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\\n\");\n    -        cs.write(\"    BinaryInputArchive archive = new BinaryInputArchive(reader);\\n\");\n    -        cs.write(\"    Deserialize(archive, \\\"\\\");\\n\");\n    -        cs.write(\"  }\\n\");\n    -\n    -        cs.write(\"  public int CompareTo (object peer_) {\\n\");\n    -        boolean unimplemented = false;\n    -        for (JField f : mFields) {\n    -            if ((f.getType() instanceof JMap)\n    -                    || (f.getType() instanceof JVector))\n    -            {\n    -                unimplemented = true;\n    +            cs.write(\"  public void Deserialize(IInputArchive a_, String tag) {\\n\");\n    +            cs.write(\"    a_.StartRecord(tag);\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpReadMethodName());\n                 }\n    -        }\n    -        if (unimplemented) {\n    -            cs.write(\"    throw new InvalidOperationException(\\\"comparing \"\n    -                    + getCsharpName() + \" is unimplemented\\\");\\n\");\n    -        } else {\n    -            cs.write(\"    if (!(peer_ is \"+getCsharpName()+\")) {\\n\");\n    -            cs.write(\"      throw new InvalidOperationException(\\\"Comparing different types of records.\\\");\\n\");\n    +            cs.write(\"    a_.EndRecord(tag);\\n\");\n    +            cs.write(\"}\\n\");\n    +\n    +            cs.write(\"  public override String ToString() {\\n\");\n    +            cs.write(\"    try {\\n\");\n    +            cs.write(\"      System.IO.MemoryStream ms = new System.IO.MemoryStream();\\n\");\n    +            cs.write(\"      MiscUtil.IO.EndianBinaryWriter writer =\\n\");\n    +            cs.write(\"        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\\n\");\n    +            cs.write(\"      BinaryOutputArchive a_ = \\n\");\n    +            cs.write(\"        new BinaryOutputArchive(writer);\\n\");\n    +            cs.write(\"      a_.StartRecord(this,\\\"\\\");\\n\");\n    +            fIdx = 0;\n    +            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                JField jf = i.next();\n    +                cs.write(jf.genCsharpWriteMethodName());\n    +            }\n    +            cs.write(\"      a_.EndRecord(this,\\\"\\\");\\n\");\n    +            cs.write(\"      ms.Position = 0;\\n\");\n    +            cs.write(\"      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\\n\");\n    +            cs.write(\"    } catch (Exception ex) {\\n\");\n    +            cs.write(\"      Console.WriteLine(ex.StackTrace);\\n\");\n                 cs.write(\"    }\\n\");\n    -            cs.write(\"    \"+getCsharpName()+\" peer = (\"+getCsharpName()+\") peer_;\\n\");\n    -            cs.write(\"    int ret = 0;\\n\");\n    +            cs.write(\"    return \\\"ERROR\\\";\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\\n\");\n    +            cs.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\\n\");\n    +            cs.write(\"    Serialize(archive, \\\"\\\");\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\\n\");\n    +            cs.write(\"    BinaryInputArchive archive = new BinaryInputArchive(reader);\\n\");\n    +            cs.write(\"    Deserialize(archive, \\\"\\\");\\n\");\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public int CompareTo (object peer_) {\\n\");\n    +            boolean unimplemented = false;\n    +            for (JField f : mFields) {\n    +                if ((f.getType() instanceof JMap)\n    +                        || (f.getType() instanceof JVector)) {\n    +                    unimplemented = true;\n    +                }\n    +            }\n    +            if (unimplemented) {\n    +                cs.write(\"    throw new InvalidOperationException(\\\"comparing \"\n    +                        + getCsharpName() + \" is unimplemented\\\");\\n\");\n    +            } else {\n    +                cs.write(\"    if (!(peer_ is \" + getCsharpName() + \")) {\\n\");\n    +                cs.write(\"      throw new InvalidOperationException(\\\"Comparing different types of records.\\\");\\n\");\n    +                cs.write(\"    }\\n\");\n    +                cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \") peer_;\\n\");\n    +                cs.write(\"    int ret = 0;\\n\");\n    +                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n    +                    JField jf = i.next();\n    +                    cs.write(jf.genCsharpCompareTo());\n    +                    cs.write(\"    if (ret != 0) return ret;\\n\");\n    +                }\n    +                cs.write(\"     return ret;\\n\");\n    +            }\n    +            cs.write(\"  }\\n\");\n    +\n    +            cs.write(\"  public override bool Equals(object peer_) {\\n\");\n    +            cs.write(\"    if (!(peer_ is \" + getCsharpName() + \")) {\\n\");\n    +            cs.write(\"      return false;\\n\");\n    +            cs.write(\"    }\\n\");\n    +            cs.write(\"    if (peer_ == this) {\\n\");\n    +            cs.write(\"      return true;\\n\");\n    +            cs.write(\"    }\\n\");\n    +            cs.write(\"    bool ret = false;\\n\");\n    +            cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \")peer_;\\n\");\n                 for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n                     JField jf = i.next();\n    -                cs.write(jf.genCsharpCompareTo());\n    -                cs.write(\"    if (ret != 0) return ret;\\n\");\n    +                cs.write(jf.genCsharpEquals());\n    --- End diff --\n    \n    Similarly, there is no actual change here. \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T16:46:56.298+0000","updated":"2016-11-23T16:46:56.298+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15690680","id":"15690680","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/102#discussion_r89356303\n  \n    --- Diff: src/java/main/org/apache/zookeeper/cli/DeleteCommand.java ---\n    @@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {\n         }\n     \n         private void retainCompatibility(String[] cmdArgs) throws CliParseException {\n    -        // delete path [version]\n             if (args.length > 2) {\n    -            // rewrite to option\n    -            String [] newCmd = new String[4];\n    --- End diff --\n    \n    These are dead code. newCmd was declared but not used so it's better to remove them. \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T16:48:21.846+0000","updated":"2016-11-23T16:48:21.846+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15690710","id":"15690710","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/102\n  \n    @fpj Thank you for taking time to double check the patch.\n    \n    >> I noticed that there are also unaddressed comments from @lvfangmin and @eribeiro .\n    The comments were about using Interface type instead of implementation type, and I addressed the comments by creating ZOOKEEPER-2630 because this issue is not a regression and is not specifically about findbug warnings, and I think it might be better to address them separately.\n    \n    I've left replies on your other comments in PR, please take a look.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-23T16:58:38.971+0000","updated":"2016-11-23T16:58:38.971+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15693655","id":"15693655","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user asfgit closed the pull request at:\n\n    https://github.com/apache/zookeeper/pull/102\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-24T16:18:55.903+0000","updated":"2016-11-24T16:18:55.903+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15693663","id":"15693663","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"body":"+1, thanks for the patch [~hanm].","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"created":"2016-11-24T16:21:27.227+0000","updated":"2016-11-24T16:21:27.227+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15693858","id":"15693858","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hudson","name":"hudson","key":"hudson","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hudson","active":true,"timeZone":"Etc/UTC"},"body":"FAILURE: Integrated in Jenkins build ZooKeeper-trunk #3169 (See [https://builds.apache.org/job/ZooKeeper-trunk/3169/])\nZOOKEEPER-2628: Fix findbug warnings. (fpj: rev b9beabf5cfbb8e447f67a8050486ca2821132f61)\n* (edit) src/java/main/org/apache/zookeeper/server/DataTree.java\n* (edit) src/java/main/org/apache/jute/compiler/CGenerator.java\n* (edit) src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java\n* (edit) src/java/main/org/apache/zookeeper/version/util/VerGen.java\n* (edit) src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java\n* (edit) src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java\n* (edit) src/java/main/org/apache/zookeeper/cli/DeleteCommand.java\n* (edit) src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java\n* (edit) src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java\n* (edit) src/java/main/org/apache/jute/compiler/CppGenerator.java\n* (edit) src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java\n* (edit) src/java/test/config/findbugsExcludeFile.xml\n* (edit) src/java/main/org/apache/zookeeper/ZooKeeperMain.java\n* (edit) src/java/main/org/apache/jute/compiler/JRecord.java\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hudson","name":"hudson","key":"hudson","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hudson","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-24T17:31:05.130+0000","updated":"2016-11-24T17:31:05.130+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15694253","id":"15694253","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"GitHub user hanm opened a pull request:\n\n    https://github.com/apache/zookeeper/pull/114\n\n    Fix C client build break caused by ZOOKEEPER-2628.\n\n    JIRA: https://issues.apache.org/jira/browse/ZOOKEEPER-2636\n    \n    Fix build break by reverting the changes made to JRecord.genCCode in ZOOKEEPER-2686, which prematurely closed the file writers that prevents zookeeper.jute.h and zookeeper.jute.c files from complete generation.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/hanm/zookeeper ZOOKEEPER-2636\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/zookeeper/pull/114.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #114\n    \n----\ncommit 8b2df1dca353946cd265c217e4010d3f080943ba\nAuthor: Michael Han <hanm@cloudera.com>\nDate:   2016-11-24T21:32:16Z\n\n    Fix C client build break caused by ZOOKEEPER-2628.\n\n----\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-24T21:35:23.046+0000","updated":"2016-11-24T21:35:23.046+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15694255","id":"15694255","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user hanm closed the pull request at:\n\n    https://github.com/apache/zookeeper/pull/114\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-24T21:35:47.362+0000","updated":"2016-11-24T21:35:47.362+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15694265","id":"15694265","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"body":"[~fpj] Thanks for reviewing and merging this patch. Unfortunately I just noticed C client build was broken because of one change in the patch. Created ZOOKEEPER-2636 where I did post mortem analysis and the fix to the broken build.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"created":"2016-11-24T21:41:04.702+0000","updated":"2016-11-24T21:41:04.702+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13018325/comment/15694286","id":"15694286","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"+1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +0 tests included.  The patch appears to be a documentation patch that doesn't require tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    +1 core tests.  The patch passed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2016-11-24T21:54:41.461+0000","updated":"2016-11-24T21:54:41.461+0000"}],"maxResults":41,"total":41,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2628/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i35x0n:"}}