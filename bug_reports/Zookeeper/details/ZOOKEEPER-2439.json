{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12975028","self":"https://issues.apache.org/jira/rest/api/2/issue/12975028","key":"ZOOKEEPER-2439","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310801","id":"12310801","key":"ZOOKEEPER","name":"ZooKeeper","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310801&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310801&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310801&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310801&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10484","id":"10484","description":"Apache ZooKeeper related","name":"ZooKeeper"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2016-09-16T15:34:41.070+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Sep 19 08:05:52 UTC 2016","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2439/watchers","watchCount":4,"isWatching":false},"created":"2016-06-02T03:17:20.920+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":["acl"],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"2.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12326517","id":"12326517","description":"Fix release against 3.4 branch","name":"3.4.8","archived":false,"released":true,"releaseDate":"2016-02-22"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12326786","id":"12326786","description":"Alpha release against 3.5 branch","name":"3.5.1","archived":false,"released":true,"releaseDate":"2015-09-02"}],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2016-09-19T08:05:52.215+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":"Within a given client connection, the execution of commands on the ZooKeeper server is always ordered, as both synchronous and asynchronous commands are dispatched through queuePacket (directly or indirectly).\n\nIn other words, Zookeeper guarantees sequential consistency: updates from a client will be applied in the order that they were sent.\n\nHowever, the order of asynchronous setACL is not correct on Ubuntu.\nWhen asynchronous setACL is called BEFORE another API is called, asynchronous setACL is applied AFTER another API.\n\nFor example, if a client calls\n\n(1) asynchronous setACL to remove all permissions of node \"/\" and\n\n(2) synchronous create to create node \"/a\",\nsynchronous create should fail, but it succeeds on Ubuntu.\n\n(We can see all permissions of node \"/\" are removed when the client calls getACL to node \"/\" after (2), so (1) is applied AFTER (2). If we call getACL between (1) and (2), the synchronous case works correctly but the asynchronous case still produces the bug.)\n\nThe attached unit test reproduces this scenario. It fails on Linux Ubuntu but succeeds on Mac OS X. If used on a heavily loaded server on Mac OS, the test sometimes fails as well but only rarely.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12807608","id":"12807608","filename":"ZOOKEEPER-2439.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kazuakibanzai","name":"kazuakibanzai","key":"kazuakibanzai","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kazuaki Banzai","active":true,"timeZone":"Etc/UTC"},"created":"2016-06-02T03:28:05.962+0000","size":4807,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12807608/ZOOKEEPER-2439.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12828873","id":"12828873","filename":"ZOOKEEPER-2439-WIP.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"created":"2016-09-16T18:06:47.668+0000","size":9083,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12828873/ZOOKEEPER-2439-WIP.patch"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"The order of asynchronous setACL is not correct.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kazuakibanzai","name":"kazuakibanzai","key":"kazuakibanzai","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kazuaki Banzai","active":true,"timeZone":"Etc/UTC"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kazuakibanzai","name":"kazuakibanzai","key":"kazuakibanzai","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kazuaki Banzai","active":true,"timeZone":"Etc/UTC"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"Linux Ubuntu\nMac OS X","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12975028/comment/15311674","id":"15311674","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kazuakibanzai","name":"kazuakibanzai","key":"kazuakibanzai","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kazuaki Banzai","active":true,"timeZone":"Etc/UTC"},"body":"This patch doesn't fix the bug.\nIt includes a unit test only.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kazuakibanzai","name":"kazuakibanzai","key":"kazuakibanzai","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kazuaki Banzai","active":true,"timeZone":"Etc/UTC"},"created":"2016-06-02T03:28:05.967+0000","updated":"2016-06-02T03:28:05.967+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12975028/comment/15496588","id":"15496588","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"body":"Hi [~kazuakibanzai],\n\nI took some time to dig this problem and I *guess* I've found the root cause. *Disclaimer: I can be totally wrong on my assumptions, so would love to hear from some ZK committers as to deny or confirm my idea (and took the liberty of marking them on this message, sorry guys).* /cc [~fpj], [~breed], [~phunt]\n\nFirst and foremost, *huge thanks* for the patch to simulate the bug, it helped a lot. Well, let's start: in a nutshell, the server side ZK is an ordered processing pipeline of RequestProcessors, where each processor is handled by a different Thread. The one that is interesting to this particular case looks like this (I am a newbie, so I may get something wrong):\n\n{code}\nrequest ---------->  PrepRequestProcessor --------> SyncRequestsProcessor  ----------> FinalRequestProcessor ------> [request applied and committed]\n{code}\n\n*KEEP THIS IN MIND:* A request is committed to ZK database as well as having the logs and snapshots updated if it arrives at the {{FinalRequestProcessor}} without any exception.\n\na. One request can be currently being processed at {{PrepRequestProcessor}} while another one is either {{SyncRequestsProcessor}} or {{FinalRequestsProcessor}}. In fact, I guess that we can have three requests, one in each step of the pipeline under high load, for example.\n\nb. At {{PrepRequestProcessor}} ZK checks if the znode path of the request is well formed as well as authorization and ACL permissions (it makes sense as SyncRequestProcessor, among other things, saves the log file and we wouldn't want to record an invalid request on command log, right?). *KEEP THIS IN MIND TOO:* ACL checks are done at the first stage of the pipeline.\n\n\n*_So, the problem you described can be summarised as such:_*\n\n1. a setACL request that removes access to '/' (let's call it REQ1) is sent asynchronously, followed by a create a znode under '/a' request (let's call it REQ2). Both are enqueued in order and arrive in this order on the server side.\n\n2. REQ1 passes {{PrepRequestProcessor}}.\n\n3. While REQ1 is at {{SyncRequestsProcessor}}, REQ 2 arrives at {{PrepRequestProcessor}}. {{PrepRequestProcessor}} checks ZK DB and see that REQ2 has the ACL rights to create the node, because REQ1 was not committed to ZK DB yet (it's in the middle of the pipeline).\n\n4. When REQ1 is finally committed on ZK DB, REQ1 is just behind it in the pipeline, so it also gets committed to the ZK DB even tough REQ1 would prevent REQ2 from being applied! Remember the permission was check on {{PrepRequestProcessor}}, the first stage of the pipeline, when REQ1 was still ongoing.\n\n*_Now let's see why some scenarios that explain your unit test:_*\n\nCase 1: The sync ACL call is, well, synchronous so, it wait for a response before sending the next command (createNode). Therefore, REQ1 completes the pipeline before REQ2 even reaches the it and the createNode is rejected as expected.\n\nCase 2. If you put a sleep between async setACL and createNode then you gave some time to REQ1 finish the pipeline because REQ2 will be inserted into the client outgoing queue after the sleep time. Again, this succeeds by rejecting the createNode command.\n\nCase 3. If you insert async or sync setACL commands before the createNode you are \"stuffing\" additional commands between setACL and createNode. Again giving a chance of setACL finishes before the createdNode reaches the first stage of the pipeline. Then again, it works as expected (the createNode is rejected).\n\nFinally, another conjecture I have is that this setACL/createNode behavior could happen if with synchronous setACL. If we had two clients, the first one could issue a sync setACL and the second one a createNode, and with the right timing they would be enqueued as explained above.\n\nDoes it make sense?\n\n\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"created":"2016-09-16T15:34:41.070+0000","updated":"2016-09-16T15:37:08.495+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12975028/comment/15496963","id":"15496963","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"body":"I am attaching a crude and possible buggy stab at a solution.\n\nMy idea with this patch is just to *bootstrap* the discussion about possible fixes, so *don't rely on it for being complete (what about multiop?), correct or comprehensive*, but it passed the {{AsyncSetACLTest}} that Kazuaki kindly provided, for what's worth. :)\n\nPS: TBH, I *don't* like the idea of 'throttling' the pipeline until setACL completes, so I am more than open to hear what you have to say.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"created":"2016-09-16T18:06:47.672+0000","updated":"2016-09-16T18:07:44.235+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12975028/comment/15499464","id":"15499464","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"body":"Should we check ACL in FinalRequestProcessor? Because of total ordering guarantee, proposal on changing ACL should be committed when FinalRequestProcessor is processing the create node proposal - note we already check ACL in FinalRequestProcessor ([example|https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/FinalRequestProcessor.java#L320]) for some ops, but not all, not sure why. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"created":"2016-09-17T18:24:52.875+0000","updated":"2016-09-17T18:24:52.875+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12975028/comment/15500156","id":"15500156","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"body":"Hi [~hanm]!\n\n{quote}\nShould we check ACL in FinalRequestProcessor?\n{quote}\n\nI hope so! :) I considered this solution too, but sidetracked because I am unsure about transactional guarantees, particularly the _*sync request to disk*_ performed by {{SyncRequestProcessor}}.\n\nNote: by the way, my stab at a solution (just a sketch, really) most probably breaks on parallel unit test running due to the use of static mutable fields.\n\n{quote}\nnote we already check ACL in FinalRequestProcessor (example) for some ops, but not all, not sure why.\n{quote}\n\nThe *non state changing* operations (exists, getData, getChildren, etc) follow a slightly different, more straightforward, path down the processing pipeline while transactional, *state changing*, operations (setData, delete, setACL, etc) perform a series of extra operations, as expected. Therefore, it looks like {{FinalRequestProcessor}} is currently checking the ACL permissions for non transactional check/read operations (even tough _exists()_ operation is lacking ACL check, a bug, imho) while the transactional operations are handled by {{PrepRequestProcessor.pRequest2Txn}} nowadays.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=eribeiro","name":"eribeiro","key":"eribeiro","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=eribeiro&avatarId=16169","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eribeiro&avatarId=16169","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eribeiro&avatarId=16169","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eribeiro&avatarId=16169"},"displayName":"Edward Ribeiro","active":true,"timeZone":"America/Sao_Paulo"},"created":"2016-09-18T03:28:59.068+0000","updated":"2016-09-18T03:28:59.068+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12975028/comment/15502658","id":"15502658","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=Telcontar","name":"Telcontar","key":"telcontar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Cyrille Artho","active":true,"timeZone":"Etc/UTC"},"body":"I think the idea of \"throttling\" as such is good, but if it has a timeout, then the same bug may reappear, just much more rarely.\n\nIf {{SyncRequestsProcessor}} propagates changes to other servers, I think it may be better to check access permission at the earliest stage. Otherwise it may become necessary to undo changes.\n\nFrom that point of view, throttling pending requests of the /same/ session until all other pending ACL operations are done, seems inevitable. Requests of /other/ sessions do not have to be throttled as it does not really matter if other requests \"win\" because of a faster network or because of thread scheduling.\n\nIf throttled requests originate from the same client session as pending ACL requests, a timeout seems unnecessary. Furthermore, the use of static variables looks very dangerous to me, as this may mix up multiple unrelated ACL requests (from different sessions).\n\nIf we throttle only requests of the same session, aren't those using the same instance of {{PrepRequestProcessor}}? That would make static fields (and timeouts) unnecessary.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=Telcontar","name":"Telcontar","key":"telcontar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Cyrille Artho","active":true,"timeZone":"Etc/UTC"},"created":"2016-09-19T08:05:52.215+0000","updated":"2016-09-19T08:05:52.215+0000"}],"maxResults":6,"total":6,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2439/votes","votes":1,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i2yv7j:"}}