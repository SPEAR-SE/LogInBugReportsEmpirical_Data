{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13079588","self":"https://issues.apache.org/jira/rest/api/2/issue/13079588","key":"ZOOKEEPER-2807","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310801","id":"12310801","key":"ZOOKEEPER","name":"ZooKeeper","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310801&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310801&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310801&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310801&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10484","id":"10484","description":"Apache ZooKeeper related","name":"ZooKeeper"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2017-06-30T22:55:11.789+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Thu Apr 19 14:37:36 UTC 2018","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2807/watchers","watchCount":5,"isWatching":false},"created":"2017-06-13T21:56:49.823+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[],"issuelinks":[{"id":"12512839","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12512839","type":{"id":"12310000","name":"Duplicate","inward":"is duplicated by","outward":"duplicates","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"},"inwardIssue":{"id":"13055830","key":"ZOOKEEPER-2720","self":"https://issues.apache.org/jira/rest/api/2/issue/13055830","fields":{"summary":"org.apache.zookeeper.test.WatchEventWhenAutoResetTest fails intermittently","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Done"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/6","id":"6","description":"A new unit, integration or system test.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/requirement.png","name":"Test","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2018-04-19T14:37:36.999+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":null,"customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"Flaky test: org.apache.zookeeper.test.WatchEventWhenAutoResetTest.testNodeDataChanged","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16070824","id":"16070824","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"GitHub user afine opened a pull request:\n\n    https://github.com/apache/zookeeper/pull/300\n\n    ZOOKEEPER-2807: Flaky test: org.apache.zookeeper.test.WatchEventWhenAutoResetTest.testNodeDataChanged\n\n    This failure appears to be related to ZOOKEEPER-2024. When a follower is syncing with the leader and logging \"the stuff that came in between the snapshot and the uptodate\" we do not wait for those commits to hit the db before starting the follower.\n    \n    In 3.6, we now have two separate queues in the CommitProcessor, it is possible that the follower can serve requests before all of the commits from the leader have been applied. In the case of this test failure we can set a watch in between a create and delete call. This patch makes sure that the \"delete\" call will be committed before attempting to handle a client's watcher request.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/afine/zookeeper ZOOKEEPER-2807\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/zookeeper/pull/300.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #300\n    \n----\ncommit ca1774dca59d7a1c9e1d9e3c8391d21cf8c2c733\nAuthor: Abraham Fine <afine@apache.org>\nDate:   2017-06-30T22:44:26Z\n\n    ZOOKEEPER-2807: Flaky test: org.apache.zookeeper.test.WatchEventWhenAutoResetTest.testNodeDataChanged\n\n----\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-06-30T22:55:11.789+0000","updated":"2017-06-30T22:55:11.789+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16071003","id":"16071003","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +0 tests included.  The patch appears to be a documentation patch that doesn't require tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    -1 findbugs.  The patch appears to introduce 2 new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/846//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/846//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/846//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-07-01T05:07:14.475+0000","updated":"2017-07-01T05:07:14.475+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16077235","id":"16077235","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n     1 @author.  The patch does not contain any @author tags.\n\n     0 tests included.  The patch appears to be a documentation patch that doesn't require tests.\n\n     1 javadoc.  The javadoc tool did not generate any warning messages.\n\n     1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    -1 findbugs.  The patch appears to introduce 3 new Findbugs (version 3.0.1) warnings.\n\n     1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n     1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/865//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/865//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/865//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-07-06T21:43:42.445+0000","updated":"2017-07-06T21:43:42.445+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16077274","id":"16077274","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shralex","name":"shralex","key":"shralex","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Alexander Shraer","active":true,"timeZone":"America/Los_Angeles"},"body":"Hi Abraham,\n\nFrom your explanation on Github, I understand the problem (changes synced from the leader are not applied to DB before follower starts processing ops), but I don't understand the relationship with CommitProcessor or what the idea of the fix is. Could you please explain ? \n\nMoreover, I would REALLY prefer not to refactor the CommitProcessor. It took a while to tune it to achieve good performance and I'm worried that refactoring will have a performance effect. Also, there is a pending patch that needs to be committed in that code, ZOOKEEPER-2684.\n\n[~breed], I think you mentioned a similar issue. Is this related ? Do you have a fix or an idea for a fix ?\n\nThanks\nAlex","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shralex","name":"shralex","key":"shralex","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Alexander Shraer","active":true,"timeZone":"America/Los_Angeles"},"created":"2017-07-06T22:24:09.186+0000","updated":"2017-07-06T22:24:09.186+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16077290","id":"16077290","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n     1 @author.  The patch does not contain any @author tags.\n\n     1 tests included.  The patch appears to include 3 new or modified tests.\n\n     1 javadoc.  The javadoc tool did not generate any warning messages.\n\n     1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n     1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n     1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n     1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/867//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/867//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/867//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-07-06T22:35:55.712+0000","updated":"2017-07-06T22:35:55.712+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16077315","id":"16077315","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"body":"[~shralex] So my understanding is that one of the major changes to the commit processor introduced in ZOOKEEPER-2024 is to change the main \"run loop\" of the CommitProcessor from processing all of the `committedRequests` queue on each iteration to processing only \"a single committed request\" (in order to prevent starvation I imagine).\n\nSo I believe this change substantially increases the probability that there will be new incoming requests in `queuedRequests` processed before older requests in`committedRequests`. This is generally fine, except when catching up to a leader. This patch adds a mechanism to make wait until `committedRequests` has been \"drained\" before we start \"following\". This way we know that all commits from the leader are applied to the DB before we begin handling incoming requests. \n\nI'm pretty confident that my patch will not have a real performance impact since the code path is unchanged unless there is 1 entry in committedRequests.\n\nI need some time to take a look at ZOOKEEPER-2684, grok whats going on, and see if it has anything to do with the fix here.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"created":"2017-07-06T22:59:08.892+0000","updated":"2017-07-06T23:10:05.487+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16077413","id":"16077413","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shralex","name":"shralex","key":"shralex","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Alexander Shraer","active":true,"timeZone":"America/Los_Angeles"},"body":"ZOOKEEPER-2684 is unrelated, but but also makes changes to the same file.\n\nIntuitively this may not be the right place for such a fix - this probably should be higher level - making sure that follower does not even accept local ops before properly completing the sync. Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive. \n\nI think @breed may have a solution for this problem, lets wait for him to comment.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=shralex","name":"shralex","key":"shralex","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Alexander Shraer","active":true,"timeZone":"America/Los_Angeles"},"created":"2017-07-07T00:37:43.983+0000","updated":"2017-07-07T00:37:43.983+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16091949","id":"16091949","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"body":"[~breed] can you take a look?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=abrahamfine","name":"abrahamfine","key":"abrahamfine","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Abraham Fine","active":true,"timeZone":"America/Los_Angeles"},"created":"2017-07-18T18:24:11.200+0000","updated":"2017-07-18T18:24:11.200+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16213246","id":"16213246","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +1 tests included.  The patch appears to include 3 new or modified tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1110//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1110//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1110//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-10-20T21:09:29.062+0000","updated":"2017-10-20T21:09:29.062+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16260377","id":"16260377","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +1 tests included.  The patch appears to include 3 new or modified tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    -1 contrib tests.  The patch failed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1287//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1287//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1287//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-11-21T07:49:26.862+0000","updated":"2017-11-21T07:49:26.862+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16260378","id":"16260378","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +1 tests included.  The patch appears to include 3 new or modified tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1288//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1288//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1288//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-11-21T07:49:27.391+0000","updated":"2017-11-21T07:49:27.391+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16260395","id":"16260395","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +1 tests included.  The patch appears to include 3 new or modified tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1289//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1289//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1289//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-11-21T08:07:36.110+0000","updated":"2017-11-21T08:07:36.110+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16274484","id":"16274484","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/300#discussion_r154363054\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---\n    @@ -327,6 +257,95 @@ public void run() {\n             LOG.info(\"CommitProcessor exited loop!\");\n         }\n     \n    +    private void processCommittedRequest() throws IOException, InterruptedException {\n    +        // In case of a spurious wakeup in waitForCommittedRequests we should not\n    +        // remove the request from the queue until it has been processed\n    +        Request request = committedRequests.peek();\n    +\n    +        if (request == null) {\n    +            committedRequests.poll();\n    --- End diff --\n    \n    If request==null then the committedRequests queue is already empty. Why do need to poll() here?\r\n    Could it be a small mistake and originally you wanted to poll() after the peek() was successful...?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-01T14:55:55.198+0000","updated":"2017-12-01T14:55:55.198+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16274498","id":"16274498","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/300#discussion_r154367742\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---\n    @@ -240,84 +240,14 @@ public void run() {\n                         }\n     \n                         // Process committed head\n    -                    if ((request = committedRequests.poll()) == null) {\n    -                        throw new IOException(\"Error: committed head is null\");\n    -                    }\n    -\n    -                    /*\n    -                     * Check if request is pending, if so, update it with the committed info\n    -                     */\n    -                    LinkedList<Request> sessionQueue = pendingRequests\n    -                            .get(request.sessionId);\n    -                    if (sessionQueue != null) {\n    -                        // If session queue != null, then it is also not empty.\n    -                        Request topPending = sessionQueue.poll();\n    -                        if (request.cxid != topPending.cxid) {\n    -                            /*\n    -                             * TL;DR - we should not encounter this scenario often under normal load.\n    -                             * We pass the commit to the next processor and put the pending back with a warning.\n    -                             *\n    -                             * Generally, we can get commit requests that are not at the queue head after\n    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session\n    -                             * with A, and the server that the session moved to with B (keep in mind that it is\n    -                             * possible that the session already moved from B to a new server C, and maybe C=A).\n    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update\n    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit\n    -                             * for the update after the session already performed several operations in B\n    -                             * (and therefore its cxid is higher than that old request).\n    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated\n    -                             * from B with cxid that is bigger than the one we know therefore in this case we\n    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit\n    -                             * for that update, it means that we already sent the request to the leader and it will\n    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid\n    -                             * is an increasing order). It is not safe for us to delete the session's queue at this\n    -                             * point, since it is possible that the session has newer requests in it after it moved\n    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old\n    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a\n    -                             * response.\n    -                             * Also note that we don't have a local session, therefore we treat the request\n    -                             * like any other commit for a remote request, i.e., we perform the update without sending\n    -                             * a response.\n    -                             */\n    -                            LOG.warn(\"Got request \" + request +\n    -                                    \" but we are expecting request \" + topPending);\n    -                            sessionQueue.addFirst(topPending);\n    -                        } else {\n    -                            /*\n    -                             * Generally, we want to send to the next processor our version of the request,\n    -                             * since it contains the session information that is needed for post update processing.\n    -                             * In more details, when a request is in the local queue, there is (or could be) a client\n    -                             * attached to this server waiting for a response, and there is other bookkeeping of\n    -                             * requests that are outstanding and have originated from this server\n    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an\n    -                             * outstanding request completes. Note that in the other case (above), the operation\n    -                             * originated from a different server and there is no local bookkeeping or a local client\n    -                             * session that needs to be notified.\n    -                             */\n    -                            topPending.setHdr(request.getHdr());\n    -                            topPending.setTxn(request.getTxn());\n    -                            topPending.zxid = request.zxid;\n    -                            request = topPending;\n    -                        }\n    -                    }\n    -\n    -                    sendToNextProcessor(request);\n    -\n    -                    waitForEmptyPool();\n    -\n    -                    /*\n    -                     * Process following reads if any, remove session queue if\n    -                     * empty.\n    -                     */\n    -                    if (sessionQueue != null) {\n    -                        while (!stopped && !sessionQueue.isEmpty()\n    -                                && !needCommit(sessionQueue.peek())) {\n    -                            sendToNextProcessor(sessionQueue.poll());\n    -                        }\n    -                        // Remove empty queues\n    -                        if (sessionQueue.isEmpty()) {\n    -                            pendingRequests.remove(request.sessionId);\n    +                    // We only need to perform synchronization if we are on the last request in the queue\n    +                    if (committedRequests.size() == 1) {\n    +                        synchronized (committedRequests) {\n    --- End diff --\n    \n    Unfortunately I don't get why do you need to synchronise here. Would you please elaborate a little bit?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-01T15:11:28.653+0000","updated":"2017-12-01T15:11:28.653+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16274540","id":"16274540","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @afine Generally speaking, I like the idea of using LinkedBlockingQueue's intrinsic lock to wait for becoming empty, but in this particular case I think it's possible that committedRequests will never be empty if the leader is constantly sending commit requests.\r\n    \r\n    Correct me if I'm wrong please (there's a very good chance that I completely misunderstand something), but my feeling is that the following situation is possible:\r\n    1. Learner starts syncing with leader in syncWithLeader() method,\r\n    2. Learner blocks and wait for all commits to be processed before finishing the sync,\r\n    3. FollowerZookeeperServer is already running and keep receiving commits from the Leader including non-syncing ones,\r\n    4. Learner will never be notified or only at some point in the future much more later then sync complete or way before that.\r\n    \r\n    To address this, if we could get the number of commits that we must wait before proceeding, we would be able to implement a CountDownLatch in CommitProcessor and wait for the number of commits which are expected in the sync process. However that does not guarantee that we received all sync-related commits either.\r\n    \r\n    Otherwise I could also agree with @shralex in the Jira saying: \"Intuitively this may not be the right place for such a fix - this probably should be higher level - **making sure that follower does not even accept local ops before properly completing the sync.** Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive.\"\r\n    \r\n    That would be the best solution here in my opinion.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-01T15:45:55.623+0000","updated":"2017-12-01T15:45:55.623+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16274817","id":"16274817","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user afine commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    Thanks for taking a look @anmolnar!\r\n    \r\n    I'm confused by what you mean in item 3. Unless I am missing something, I don't understand how `FollowerZooKeeperServer` is \"already running and keep receiving commits from the Leader including non-syncing ones\" before `syncWithLeader` is completed.\r\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-01T19:22:34.754+0000","updated":"2017-12-01T19:22:34.754+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16275478","id":"16275478","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @afine If I'm not mistaken there's a thread running which receives messages from the Leader in QuorumPeer.java:997:\r\n    Call stack is:\r\n    QuorumPeer.run() -> Follower.followLeader() -> Follower.processPacket() -> FollowerZookeeperServer.commit()\r\n    This code path could potentially add more commit messages to the queue which are not related to the sync.\r\n    \r\n    Even if I'm wrong with the above, @shralex 's concern is still valid: \"Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive.\"\r\n    It's possible to drain the commit queue faster than leader sends messages.\r\n    \r\n    In other words: draining the commit queue doesn't seem to guarantee that the sync is complete.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-02T08:34:13.298+0000","updated":"2017-12-02T08:34:13.298+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16277541","id":"16277541","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user afine commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @anmolnar With respect to the code path above, shouldn't that be blocked on `syncWithLeader`?\r\n    \r\n    > Even if you drain the committedRequests, I'm not sure that guarantees that there are no more that will arrive.\r\n    \r\n    I'm not sure I understand how we don't have this guarantee. My understanding is that `syncWithLeader` loops until an `UPTODATE` message is received by the follower. Incoming packets from the leader are read by:\r\n    ```java\r\n                    syncWithLeader(newEpochZxid);                \r\n                    QuorumPacket qp = new QuorumPacket();\r\n                    while (this.isRunning()) {\r\n                        readPacket(qp);\r\n                        processPacket(qp);\r\n                    }\r\n    ```\r\n    \r\n    In addition, my understanding is that requests are only added to `CommitProcessor`'s `committedRequests` in `processPacket`. What am I missing?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-04T21:29:06.807+0000","updated":"2017-12-04T21:29:06.807+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16277582","id":"16277582","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user afine commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/300#discussion_r154786233\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---\n    @@ -327,6 +257,95 @@ public void run() {\n             LOG.info(\"CommitProcessor exited loop!\");\n         }\n     \n    +    private void processCommittedRequest() throws IOException, InterruptedException {\n    +        // In case of a spurious wakeup in waitForCommittedRequests we should not\n    +        // remove the request from the queue until it has been processed\n    +        Request request = committedRequests.peek();\n    +\n    +        if (request == null) {\n    +            committedRequests.poll();\n    --- End diff --\n    \n    we don't\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-04T21:51:16.850+0000","updated":"2017-12-04T21:51:16.850+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16277625","id":"16277625","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"body":"-1 overall.  GitHub Pull Request  Build\n      \n\n    +1 @author.  The patch does not contain any @author tags.\n\n    +1 tests included.  The patch appears to include 3 new or modified tests.\n\n    +1 javadoc.  The javadoc tool did not generate any warning messages.\n\n    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.\n\n    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.\n\n    +1 release audit.  The applied patch does not increase the total number of release audit warnings.\n\n    -1 core tests.  The patch failed core unit tests.\n\n    +1 contrib tests.  The patch passed contrib unit tests.\n\nTest results: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1333//testReport/\nFindbugs warnings: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1333//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html\nConsole output: https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1333//console\n\nThis message is automatically generated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hadoopqa","name":"hadoopqa","key":"hadoopqa","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hadoopqa&avatarId=10393","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hadoopqa&avatarId=10393","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hadoopqa&avatarId=10393","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hadoopqa&avatarId=10393"},"displayName":"Hadoop QA","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-04T22:11:13.327+0000","updated":"2017-12-04T22:11:13.327+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16278048","id":"16278048","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @afine You're right. I missed that syncWithLeader() call is on the same path and in the same thread as adding commits to the queue.\r\n    \r\n    In which case this must be right:\r\n    - syncWithLeader() blocks the follower, \r\n    - Leader sends commits for the sync process, \r\n    - Leader sends UPTODATE at the very end, \r\n    - Follower drains the commit queue\r\n    - Follower starts following.\r\n    \r\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-05T05:42:41.191+0000","updated":"2017-12-05T05:42:41.191+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16278053","id":"16278053","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/300#discussion_r154851878\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---\n    @@ -240,84 +240,14 @@ public void run() {\n                         }\n     \n                         // Process committed head\n    -                    if ((request = committedRequests.poll()) == null) {\n    -                        throw new IOException(\"Error: committed head is null\");\n    -                    }\n    -\n    -                    /*\n    -                     * Check if request is pending, if so, update it with the committed info\n    -                     */\n    -                    LinkedList<Request> sessionQueue = pendingRequests\n    -                            .get(request.sessionId);\n    -                    if (sessionQueue != null) {\n    -                        // If session queue != null, then it is also not empty.\n    -                        Request topPending = sessionQueue.poll();\n    -                        if (request.cxid != topPending.cxid) {\n    -                            /*\n    -                             * TL;DR - we should not encounter this scenario often under normal load.\n    -                             * We pass the commit to the next processor and put the pending back with a warning.\n    -                             *\n    -                             * Generally, we can get commit requests that are not at the queue head after\n    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session\n    -                             * with A, and the server that the session moved to with B (keep in mind that it is\n    -                             * possible that the session already moved from B to a new server C, and maybe C=A).\n    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update\n    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit\n    -                             * for the update after the session already performed several operations in B\n    -                             * (and therefore its cxid is higher than that old request).\n    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated\n    -                             * from B with cxid that is bigger than the one we know therefore in this case we\n    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit\n    -                             * for that update, it means that we already sent the request to the leader and it will\n    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid\n    -                             * is an increasing order). It is not safe for us to delete the session's queue at this\n    -                             * point, since it is possible that the session has newer requests in it after it moved\n    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old\n    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a\n    -                             * response.\n    -                             * Also note that we don't have a local session, therefore we treat the request\n    -                             * like any other commit for a remote request, i.e., we perform the update without sending\n    -                             * a response.\n    -                             */\n    -                            LOG.warn(\"Got request \" + request +\n    -                                    \" but we are expecting request \" + topPending);\n    -                            sessionQueue.addFirst(topPending);\n    -                        } else {\n    -                            /*\n    -                             * Generally, we want to send to the next processor our version of the request,\n    -                             * since it contains the session information that is needed for post update processing.\n    -                             * In more details, when a request is in the local queue, there is (or could be) a client\n    -                             * attached to this server waiting for a response, and there is other bookkeeping of\n    -                             * requests that are outstanding and have originated from this server\n    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an\n    -                             * outstanding request completes. Note that in the other case (above), the operation\n    -                             * originated from a different server and there is no local bookkeeping or a local client\n    -                             * session that needs to be notified.\n    -                             */\n    -                            topPending.setHdr(request.getHdr());\n    -                            topPending.setTxn(request.getTxn());\n    -                            topPending.zxid = request.zxid;\n    -                            request = topPending;\n    -                        }\n    -                    }\n    -\n    -                    sendToNextProcessor(request);\n    -\n    -                    waitForEmptyPool();\n    -\n    -                    /*\n    -                     * Process following reads if any, remove session queue if\n    -                     * empty.\n    -                     */\n    -                    if (sessionQueue != null) {\n    -                        while (!stopped && !sessionQueue.isEmpty()\n    -                                && !needCommit(sessionQueue.peek())) {\n    -                            sendToNextProcessor(sessionQueue.poll());\n    -                        }\n    -                        // Remove empty queues\n    -                        if (sessionQueue.isEmpty()) {\n    -                            pendingRequests.remove(request.sessionId);\n    +                    // We only need to perform synchronization if we are on the last request in the queue\n    +                    if (committedRequests.size() == 1) {\n    +                        synchronized (committedRequests) {\n    --- End diff --\n    \n    Does synchronized - notifyAll() have any performance hit in normal operation of the follower?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-05T05:46:49.757+0000","updated":"2017-12-05T05:46:49.757+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16279333","id":"16279333","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user afine commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/300#discussion_r155102382\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---\n    @@ -240,84 +240,14 @@ public void run() {\n                         }\n     \n                         // Process committed head\n    -                    if ((request = committedRequests.poll()) == null) {\n    -                        throw new IOException(\"Error: committed head is null\");\n    -                    }\n    -\n    -                    /*\n    -                     * Check if request is pending, if so, update it with the committed info\n    -                     */\n    -                    LinkedList<Request> sessionQueue = pendingRequests\n    -                            .get(request.sessionId);\n    -                    if (sessionQueue != null) {\n    -                        // If session queue != null, then it is also not empty.\n    -                        Request topPending = sessionQueue.poll();\n    -                        if (request.cxid != topPending.cxid) {\n    -                            /*\n    -                             * TL;DR - we should not encounter this scenario often under normal load.\n    -                             * We pass the commit to the next processor and put the pending back with a warning.\n    -                             *\n    -                             * Generally, we can get commit requests that are not at the queue head after\n    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session\n    -                             * with A, and the server that the session moved to with B (keep in mind that it is\n    -                             * possible that the session already moved from B to a new server C, and maybe C=A).\n    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update\n    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit\n    -                             * for the update after the session already performed several operations in B\n    -                             * (and therefore its cxid is higher than that old request).\n    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated\n    -                             * from B with cxid that is bigger than the one we know therefore in this case we\n    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit\n    -                             * for that update, it means that we already sent the request to the leader and it will\n    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid\n    -                             * is an increasing order). It is not safe for us to delete the session's queue at this\n    -                             * point, since it is possible that the session has newer requests in it after it moved\n    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old\n    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a\n    -                             * response.\n    -                             * Also note that we don't have a local session, therefore we treat the request\n    -                             * like any other commit for a remote request, i.e., we perform the update without sending\n    -                             * a response.\n    -                             */\n    -                            LOG.warn(\"Got request \" + request +\n    -                                    \" but we are expecting request \" + topPending);\n    -                            sessionQueue.addFirst(topPending);\n    -                        } else {\n    -                            /*\n    -                             * Generally, we want to send to the next processor our version of the request,\n    -                             * since it contains the session information that is needed for post update processing.\n    -                             * In more details, when a request is in the local queue, there is (or could be) a client\n    -                             * attached to this server waiting for a response, and there is other bookkeeping of\n    -                             * requests that are outstanding and have originated from this server\n    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an\n    -                             * outstanding request completes. Note that in the other case (above), the operation\n    -                             * originated from a different server and there is no local bookkeeping or a local client\n    -                             * session that needs to be notified.\n    -                             */\n    -                            topPending.setHdr(request.getHdr());\n    -                            topPending.setTxn(request.getTxn());\n    -                            topPending.zxid = request.zxid;\n    -                            request = topPending;\n    -                        }\n    -                    }\n    -\n    -                    sendToNextProcessor(request);\n    -\n    -                    waitForEmptyPool();\n    -\n    -                    /*\n    -                     * Process following reads if any, remove session queue if\n    -                     * empty.\n    -                     */\n    -                    if (sessionQueue != null) {\n    -                        while (!stopped && !sessionQueue.isEmpty()\n    -                                && !needCommit(sessionQueue.peek())) {\n    -                            sendToNextProcessor(sessionQueue.poll());\n    -                        }\n    -                        // Remove empty queues\n    -                        if (sessionQueue.isEmpty()) {\n    -                            pendingRequests.remove(request.sessionId);\n    +                    // We only need to perform synchronization if we are on the last request in the queue\n    +                    if (committedRequests.size() == 1) {\n    +                        synchronized (committedRequests) {\n    --- End diff --\n    \n    I believe I was able to mitigate any potential performance impact by only entering a synchronized block when there is only a single committed request in the queue.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-05T23:02:40.319+0000","updated":"2017-12-05T23:02:40.319+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16279351","id":"16279351","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/300#discussion_r155103949\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java ---\n    @@ -240,84 +240,14 @@ public void run() {\n                         }\n     \n                         // Process committed head\n    -                    if ((request = committedRequests.poll()) == null) {\n    -                        throw new IOException(\"Error: committed head is null\");\n    -                    }\n    -\n    -                    /*\n    -                     * Check if request is pending, if so, update it with the committed info\n    -                     */\n    -                    LinkedList<Request> sessionQueue = pendingRequests\n    -                            .get(request.sessionId);\n    -                    if (sessionQueue != null) {\n    -                        // If session queue != null, then it is also not empty.\n    -                        Request topPending = sessionQueue.poll();\n    -                        if (request.cxid != topPending.cxid) {\n    -                            /*\n    -                             * TL;DR - we should not encounter this scenario often under normal load.\n    -                             * We pass the commit to the next processor and put the pending back with a warning.\n    -                             *\n    -                             * Generally, we can get commit requests that are not at the queue head after\n    -                             * a session moved (see ZOOKEEPER-2684). Let's denote the previous server of the session\n    -                             * with A, and the server that the session moved to with B (keep in mind that it is\n    -                             * possible that the session already moved from B to a new server C, and maybe C=A).\n    -                             * 1. If request.cxid < topPending.cxid : this means that the session requested this update\n    -                             * from A, then moved to B (i.e., which is us), and now B receives the commit\n    -                             * for the update after the session already performed several operations in B\n    -                             * (and therefore its cxid is higher than that old request).\n    -                             * 2. If request.cxid > topPending.cxid : this means that the session requested an updated\n    -                             * from B with cxid that is bigger than the one we know therefore in this case we\n    -                             * are A, and we lost the connection to the session. Given that we are waiting for a commit\n    -                             * for that update, it means that we already sent the request to the leader and it will\n    -                             * be committed at some point (in this case the order of cxid won't follow zxid, since zxid\n    -                             * is an increasing order). It is not safe for us to delete the session's queue at this\n    -                             * point, since it is possible that the session has newer requests in it after it moved\n    -                             * back to us. We just leave the queue as it is, and once the commit arrives (for the old\n    -                             * request), the finalRequestProcessor will see a closed cnxn handle, and just won't send a\n    -                             * response.\n    -                             * Also note that we don't have a local session, therefore we treat the request\n    -                             * like any other commit for a remote request, i.e., we perform the update without sending\n    -                             * a response.\n    -                             */\n    -                            LOG.warn(\"Got request \" + request +\n    -                                    \" but we are expecting request \" + topPending);\n    -                            sessionQueue.addFirst(topPending);\n    -                        } else {\n    -                            /*\n    -                             * Generally, we want to send to the next processor our version of the request,\n    -                             * since it contains the session information that is needed for post update processing.\n    -                             * In more details, when a request is in the local queue, there is (or could be) a client\n    -                             * attached to this server waiting for a response, and there is other bookkeeping of\n    -                             * requests that are outstanding and have originated from this server\n    -                             * (e.g., for setting the max outstanding requests) - we need to update this info when an\n    -                             * outstanding request completes. Note that in the other case (above), the operation\n    -                             * originated from a different server and there is no local bookkeeping or a local client\n    -                             * session that needs to be notified.\n    -                             */\n    -                            topPending.setHdr(request.getHdr());\n    -                            topPending.setTxn(request.getTxn());\n    -                            topPending.zxid = request.zxid;\n    -                            request = topPending;\n    -                        }\n    -                    }\n    -\n    -                    sendToNextProcessor(request);\n    -\n    -                    waitForEmptyPool();\n    -\n    -                    /*\n    -                     * Process following reads if any, remove session queue if\n    -                     * empty.\n    -                     */\n    -                    if (sessionQueue != null) {\n    -                        while (!stopped && !sessionQueue.isEmpty()\n    -                                && !needCommit(sessionQueue.peek())) {\n    -                            sendToNextProcessor(sessionQueue.poll());\n    -                        }\n    -                        // Remove empty queues\n    -                        if (sessionQueue.isEmpty()) {\n    -                            pendingRequests.remove(request.sessionId);\n    +                    // We only need to perform synchronization if we are on the last request in the queue\n    +                    if (committedRequests.size() == 1) {\n    +                        synchronized (committedRequests) {\n    --- End diff --\n    \n    Ok\r\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-05T23:11:04.044+0000","updated":"2017-12-05T23:11:04.044+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16279712","id":"16279712","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    +1 looks good to me.\r\n    @afine Would you please trigger another build to get a green one?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2017-12-06T06:23:48.658+0000","updated":"2017-12-06T06:23:48.658+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16335561","id":"16335561","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @afine @phunt shall we commit this?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-01-23T09:28:07.008+0000","updated":"2018-01-23T09:28:07.008+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16351782","id":"16351782","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @afine do you think this is a good one to commit?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-04T13:27:28.128+0000","updated":"2018-02-04T13:27:28.128+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16442571","id":"16442571","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    @phunt @rakeshadr @hanm This test is quite frequently flaking, I think it'd be useful to commit the patch if we're done with the review.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-04-18T14:14:37.158+0000","updated":"2018-04-18T14:14:37.158+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13079588/comment/16444130","id":"16444130","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user anmolnar commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/300\n  \n    Rebased on master.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-04-19T14:37:36.999+0000","updated":"2018-04-19T14:37:36.999+0000"}],"maxResults":29,"total":29,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2807/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i3g8dr:"}}