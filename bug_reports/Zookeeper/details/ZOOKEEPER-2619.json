{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13014437","self":"https://issues.apache.org/jira/rest/api/2/issue/13014437","key":"ZOOKEEPER-2619","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310801","id":"12310801","key":"ZOOKEEPER","name":"ZooKeeper","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310801&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310801&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310801&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310801&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10484","id":"10484","description":"Apache ZooKeeper related","name":"ZooKeeper"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2016-10-22T00:49:22.647+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Thu Nov 03 14:54:20 UTC 2016","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2619/watchers","watchCount":9,"isWatching":false},"created":"2016-10-22T00:01:28.693+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2016-11-03T14:54:20.959+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":"According to the USENIX ATC 2010 [paper|https://www.usenix.org/conference/usenix-atc-10/zookeeper-wait-free-coordination-internet-scale-systems], ZooKeeper provides \"FIFO client order: all requests from a given client are executed in the order that they were sent by the client.\" I believe applications written using the Java client library are unable to rely on this guarantee, and any current application that does so is broken. Other client libraries are also likely to be affected.\n\nConsider this application, which is simplified from the algorithm described on Page 4 (right column) of the paper:\n{code}\n  zk = new ZooKeeper(...)\n  zk.createAsync(\"/data-23857\", \"...\", callback)\n  zk.createSync(\"/pointer\", \"/data-23857\")\n{code}\nAssume an empty ZooKeeper database to begin with and no other writers. Applying the above definition, if the ZooKeeper database contains /pointer, it must also contain /data-23857.\n\nNow consider this series of unfortunate events:\n{code}\n  zk = new ZooKeeper(...)\n  // The library establishes a TCP connection.\n  zk.createAsync(\"/data-23857\", \"...\", callback)\n  // The library/kernel closes the TCP connection because it times out, and\n  // the create of /data-23857 is doomed to fail with ConnectionLoss. Suppose\n  // that it never reaches the server.\n  // The library establishes a new TCP connection.\n  zk.createSync(\"/pointer\", \"/data-23857\")\n  // The create of /pointer succeeds.\n{code}\nThat's the problem: subsequent operations get assigned to the new connection and succeed, while earlier operations fail.\n\nIn general, I believe it's impossible to have a system with the following three properties:\n # FIFO client order for asynchronous operations,\n # Failing operations when connections are lost, AND\n # Transparently reconnecting when connections are lost.\n\nTo argue this, consider an application that issues a series of pipelined operations, then upon noticing a connection loss, issues a series of recovery operations, repeating the recovery procedure as necessary. If a pipelined operation fails, all subsequent operations in the pipeline must also fail. Yet the client must also carry on eventually: the recovery operations cannot be trivially failed forever. Unfortunately, the client library does not know where the pipelined operations end and the recovery operations begin. At the time of a connection loss, subsequent pipelined operations may or may not be queued in the library; others might be upcoming in the application thread. If the library re-establishes a connection too early, it will send pipelined operations out of FIFO client order.\n\n\nI considered a possible workaround of having the client diligently check its callbacks and watchers for connection loss events, and do its best to stop the subsequent pipelined operations at the first sign of a connection loss. In addition to being a large burden for the application, this does not solve the problem all the time. In particular, if the callback thread is delayed significantly (as can happen due to excessive computation or scheduling hiccups), the application may not learn about the connection loss event until after the connection has been re-established and after dependent pipelined operations have already been transmitted over the new connection.\n\n\nI suggest the following API changes to fix the problem:\n - Add a method ZooKeeper.getConnection() returning a ZKConnection object. ZKConnection would wrap a TCP connection. It would include all synchronous and asynchronous operations currently defined on the ZooKeeper class. Upon a connection loss on a ZKConnection, all subsequent operations on the same ZKConnection would return a Connection Loss error. Upon noticing, the client would need to call ZooKeeper.getConnection() again to get a working ZKConnection object, and it would execute its recovery procedure on this new connection.\n - Deprecate all asynchronous methods on the ZooKeeper object. These are unsafe to use if the caller assumes they're getting FIFO client order.\n - No changes to the protocols or servers are required.\n\nI recognize this could cause a lot of code churn for both ZooKeeper and projects that use it. On the other hand, the existing asynchronous calls in applications should now be audited anyhow.\n\n\nThe code affected by this issue may be difficult to contain:\n - It likely affects all ZooKeeper client libraries that provide both asynchronous operations and transparent reconnection. That's probably all versions of the official Java client library, as well as most other client libraries.\n - It affects all applications using those libraries that depend on the FIFO client order of asynchronous operations. I don't know how common that is, but the paper implies that FIFO client order is important.\n - Fortunately, the issue can only manifest itself when connections are lost and transparently reestablished. In practice, it may also require a long pipeline or a significant delay in the application thread while the library establishes a new connection.\n - In case you're wondering, this issue occurred to me while working on a new client library for Go. I haven't seen this issue in the wild, but I was able to produce it locally by placing sleep statements in a Java program and closing its TCP connections.\n\n\nI'm new to this community, so I'm looking forward to the discussion. Let me know if I can clarify any of the above.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"Client library reconnecting breaks FIFO client order","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15596822","id":"15596822","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rgs","name":"rgs","key":"rgs","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rgs&avatarId=18469","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rgs&avatarId=18469","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rgs&avatarId=18469","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rgs&avatarId=18469"},"displayName":"Raul Gutierrez Segales","active":true,"timeZone":"America/Los_Angeles"},"body":"[~ongardie]: thanks for reporting this. In the example given though:\n\n{code}\n  zk = new ZooKeeper(...)\n  // The library establishes a TCP connection.\n  zk.createAsync(\"/data-23857\", \"...\", callback)\n  // The library/kernel closes the TCP connection because it times out, and\n  // the create of /data-23857 is doomed to fail with ConnectionLoss. Suppose\n  // that it never reaches the server.\n  // The library establishes a new TCP connection.\n  zk.createSync(\"/pointer\", \"/data-23857\")\n  // The create of /pointer succeeds.\n{code}\n\nCallback should be called with ConnectionLossException before createSync() is send to the server, because internally all requests — sync or async — are serialized through the same queue.\n\nIt sounds like the assumption here is that a createSync() should fail if a previous createAsync() call failed? That should be left to the application, no? Internally, all replies/events are delivered in order so ordering shouldn't be broken — no?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rgs","name":"rgs","key":"rgs","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=rgs&avatarId=18469","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=rgs&avatarId=18469","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=rgs&avatarId=18469","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=rgs&avatarId=18469"},"displayName":"Raul Gutierrez Segales","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-22T00:49:22.647+0000","updated":"2016-10-22T00:49:22.647+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15596910","id":"15596910","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. Callback should be called with ConnectionLossException before createSync() is send to the server, because internally all requests — sync or async — are serialized through the same queue. --[~rgs]\n\nI've observed that subsequent requests do not block on the return of the callback from prior requests. In other words, I can't count on my /data-23857 callback to see and process the ConnectionLoss before my /pointer request is sent out on the new connection. (And even if I could, that programming model would be error-prone and burdensome.)\n\nBTW, whether the second create is sync or async isn't important in the example. The problematic situation could arise even if both were createAsync.\n\nbq. It sounds like the assumption here is that a createSync() should fail if a previous createAsync() call failed? That should be left to the application, no? Internally, all replies/events are delivered in order so ordering shouldn't be broken — no? --[~rgs]\n\nCan you clarify?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-22T01:38:32.595+0000","updated":"2016-10-22T01:38:32.595+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15598040","id":"15598040","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"body":"Thanks for starting this discussion, [~ongardie].\n\nSome of the issues you're describing, we only had the opportunity to discuss in more detail in the book. It is really not self-promotion, and it is where we had a chance to talk more about some of the subtleties we have.\n\nLet me first acknowledge that it is possible that we submit asynchronously operations OP1 and OP2, such that OP2 is executed and OP1 isn't. This can happen in the case that the connection is lost while the client is processing OP1, the callback is set to deliver the connection loss event, a new connection is created, and OP2 is submitted concurrently. ZooKeeper in this scenario makes two important guarantees: 1) it notifies the application that there has been an error for OP1; 2) it doesn't reorder the execution of OP1 and OP2. If they both execute, it will follow the order of submission.\n\nIf you're building an application, then you have two choices with the current API. You can be optimistic and submit asynchronous operations in a tight loop. In the case you fall in the situation I describe above, then you might need to execute some recovery procedure. If as an application designer you don't want or can't execute such a procedure, then you'll have to execute one at a time.\n\nIn your first example, you're mixing the synchronous and the asynchronous API. We don't actually enforce that an application uses one or the other, but we do not recommend to mix synchronous and asynchronous calls precisely because of the reasons you're raising.\n\nAbout your proposal, it is fairly extreme, so I'm -1 as is. However, there is one thing we have discussed at some point, but never really got to do, is to fail all operations upon a connection loss and only re-enable upon an explicit indication from the application, like a {{reenableOps}} call. It achieves the same effect of dropping a suffix of operations and does not require all the changes you're proposing. It should be a fairly simple change to make and it is compatible with the current API. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"created":"2016-10-22T15:39:45.972+0000","updated":"2016-10-22T18:08:35.489+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15598647","id":"15598647","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"body":"bq. ZooKeeper provides \"FIFO client order: all requests from a given client are executed in the order that they were sent by the client.\"\n\nOne more constraint should be added: all requests from a given client in *the same session* are guaranteed being executed in FIFO order as they were sent. Requests across sessions are not guaranteed FIFO order. In the case of two consecutive quests with a connection loss between the two, there will be two sessions after client reconnect, thus both requests will not be guaranteed executed FIFO.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hanm","name":"hanm","key":"hanm","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=hanm&avatarId=26946","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=hanm&avatarId=26946","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=hanm&avatarId=26946","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=hanm&avatarId=26946"},"displayName":"Michael Han","active":true,"timeZone":"America/Vancouver"},"created":"2016-10-22T23:02:59.076+0000","updated":"2016-10-22T23:02:59.076+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15598842","id":"15598842","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"body":"i think it's a good idea to document this issue in this jira. it would be really nice to surface this to clients in a way that they both realize the problem and they have a way to deal with it.\n\nthe nice thing about it is that it is a client side issue. the server maintains its guarantees. since you are implementing your own client you can actually experiment with different ideas.\n\nit sounds to me that getConnection() and reenableOps() are basically the same. right? or are you proposing that when you get a ZKConnection object you can invoke the zookeeper operations on that?\n\ni think this is really only an issue for async methods, since synchronous methods execute ... synchronously, thus one at a time. i kind of like the idea of getting a object that only has async methods that you can have a strong guarantee of FIFO execution.\n\none problem i see with reenableOps is that it affects everything using the zookeeper handle, not just the ops in question.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-23T01:51:24.669+0000","updated":"2016-10-23T01:51:24.669+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15599814","id":"15599814","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"body":"bq. i think it's a good idea to document this issue in this jira.\n\nDocumenting is a good suggestion, but probably better on the official or docs or at least wiki. I think that's what you're suggesting, yes?\n\nbq. it sounds to me that getConnection() and reenableOps() are basically the same. right?\n\nI need to step back to respond to this and say how I have interpreted the original proposal. The description says:\n\nbq. Add a method ZooKeeper.getConnection() returning a ZKConnection object. ZKConnection would wrap a TCP connection.\n\nMy interpretation here is that in {{SendThread}}, instead of starting a connection automatically once the connection is declared lost, we need to change the logic to have the application enabling the reconnection. If we let the application do it and the application takes long, then the session might end up expiring. I'm not convinced that it is a good idea to let the application take control over the reconnection.\n\nThe different approach with {{reenableOps}} consists of leaving the automatic reconnection as we have today, but in the {{queuePacket}} method where we have this:\n\n{code}\n            if (!state.isAlive() || closing) {\n                conLossPacket(packet);\n            } else {\n                // If the client is asking to close the session then\n                // mark as closing\n                if (h.getType() == OpCode.closeSession) {\n                    closing = true;\n                }\n                outgoingQueue.add(packet);\n            }\n{code}\n\nwe change the predicate of the {{if}} block to evaluate to true also in the case operations haven't been re-enabled after a connection loss. We might want to have a new state that represents the client being connected but disabled and possibly a parameter that disables this behavior to provide what we have currently for compatibility. I'd say that the default behavior is what we have today, but I don't feel strongly about it.\n\nbq. one problem i see with reenableOps is that it affects everything using the zookeeper handle, not just the ops in question.\n\nI'm not sure what you have in mind when you refer to *everything*, [~breed]. If you're alluding to the fact that it also affects the sync api, then the configuration switch enables turning it on and off. The discussion below provides a different option, though.\n\nbq. i kind of like the idea of getting a object that only has async methods that you can have a strong guarantee of FIFO execution.\n\nI agree, it shouldn't be difficult to separate out so that we have a synchronous handle and an asynchronous handle. We would need to keep a {{ZooKeeper}} class that instantiates the two for backward compatibility.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"created":"2016-10-23T15:03:08.675+0000","updated":"2016-10-23T15:03:08.675+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15602873","id":"15602873","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"body":"Thanks for the quick replies.\n\nbq. In your first example, you're mixing the synchronous and the asynchronous API. We don't actually enforce that an application uses one or the other, but we do not recommend to mix synchronous and asynchronous calls precisely because of the reasons you're raising.\n\nIn my three-line example, it doesn't matter whether the second create is synchronous (mixing) or asynchronous (not mixing). Isn't it fine to issue a series of asynchronous calls ending with a synchronous call?\n\nSummarizing the *{{reenableOps()}}* proposal so far, we have:\n - A new configuration option (say, \"requireReenableOps\") for an application to opt into calling {{reenableOps()}}. This would preserve backwards compatibility for existing clients, so the default would be to keep today's behavior.\n - Upon a connection loss, the client library would still reconnect automatically and issue pings as needed. However, with the configuration option set, it would continue to fail all requests (both synchronous and asynchronous).\n - After the application calls {{reenableOps()}}, the client library would permit new requests to use the new connection.\n\nThis would work, but in terms of API design, I can think of a couple of drawbacks:\n\n- If we consider an application that's spread across various modules and/or thread boundaries, it has to be carefully designed with respect to {{reenableOps()}}, as this is a global property. I think this is what [~breed] was getting at with \"it affects everything using the zookeeper handle\". Specifically, every module/thread must be ready for a call to {{reenableOps()}} before it is safe to invoke, and until such time, the application won't make much progress.\n\n- Most asynchronous code will need to know whether it's running under requireReenableOps=false or requireReenableOps=true. This might complicate a reusable library's internals and API, which may need to have different behavior depending on this setting.\n\nThe *{{getConnection()}}* proposal doesn't have these problems. Some modules of an application can continue issuing synchronous calls on the ZooKeeper object, others can issue (deprecated) asynchronous calls on the ZooKeeper object, and yet others can use ZKConnection objects, moving to new connections at their own pace with no application-level synchronization.\n\nbq. it sounds to me that getConnection() and reenableOps() are basically the same. right? or are you proposing that when you get a ZKConnection object you can invoke the zookeeper operations on that?\n\nYou would invoke the operations directly on the ZKConnection object.\n\nI do like the idea of the library automatically reconnecting for pings, and we could apply that to the {{getConnection()}} proposal too:\n- The library would reconnect automatically to issue pings, as it does now.\n- {{ZooKeeper.getConnection()}} would return the current ZKConnection object, which wraps the current TCP connection.\n- Upon a connection loss, all subsequent operations on the same ZKConnection would return a Connection Loss error. The library would internally reconnect automatically, but it would not make this TCP connection availble via the old ZKConnection.\n- Upon noticing a connection loss, the application would need to call {{ZooKeeper.getConnection()}} again to get the new ZKConnection object.\n\nThe ZKConnection object certainly needs to export the asynchronous methods that are in ZooKeeper today. I think it should also export the synchronous methods. I think these are both well-defined and useful in ZKConnection, as in my original example with {{createAsync()}} followed by {{createSync()}}.\n\nI think the ZooKeeper class should continue to export non-deprecated synchronous methods as well. These would just be convenience wrappers that invoke {{getConnection()}} followed by the synchronous operation on that. Much ZooKeeper code is entirely synchronous, and as such, does not depend on FIFO client order. I see no reason to force churn upon that code.\n\nI still think the asynchronous calls on the ZooKeeper class should be deprecated, since applications cannot rely on FIFO client order when using them. At a minimum, these should have a very clear warning to this effect, and applications should be encouraged to get a ZKConnection and then make asynchronous calls on that.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-24T18:52:22.341+0000","updated":"2016-10-24T18:52:22.341+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15604093","id":"15604093","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"body":"thanx diego, you did express well what i was trying to say. i also like your proposal. there are probably more details to work out, like how would it look for the C api? i like how it encapsulates nicely the relation between a sequence of operations, and your example does make a compelling argument for also including the sync api.\n\ndo we have some applications that we can use to validate the api? it would be nice to validate the design before we standardize it.\n\nwhat i meant by \"i think it's a good idea to document this issue in this jira\" is that it's good that we have this jira to discuss the problem and potential solutions.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-25T04:00:26.441+0000","updated":"2016-10-25T04:00:26.441+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15605104","id":"15605104","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"body":"bq. In my three-line example, it doesn't matter whether the second create is synchronous (mixing) or asynchronous (not mixing). Isn't it fine to issue a series of asynchronous calls ending with a synchronous call?\n\nMaybe, it depends on where you make the synchronous call. If you call it from a callback, then you may end up re-ordering the results. After checking it again, I don't think it is super important for this discussion. In your simple example, you're right that it doesn't matter whether the second call is sync or async.\n\nI like the idea of not making the behavior global and configurable via switch. In particular, the configuration switch is error prone. I still think that mixing API use and different behavior, even across modules, with the same ZK handle isn't good practice, but I'm fine with leaving it up to the application to decide, though.\n\nOn {{getConnection}}, I have a few high-level points:\n\n# I like the fact that it is all client side and it makes it clear to the application that requests are being sent over a given connection. Once the connection drops, a proper suffix of the operations will receive an error.\n# I'd rather not have the sync api and the async api over different objects. The proposal has the sync api in the zookeeper handle and the async api in the connection object. I'll discuss this some more below.\n# I don't like much the idea of exposing a \"connection\". The abstraction we have historically is a session and the fact that a session can have multiple connections over time is mostly transparent to the application, except for the connection loss event, which makes it clear that there are multiple connections going on underneath.\n\nOn the second point, we don't necessarily have to move the async api to such a connection object. We could instead have something like a token and the token essentially represents a connection. If the connection drops, then the token is invalidated. With such a token, we will be adding a new call for each operations to the handle, something like:\n\n{code}\npublic void create(final String path, \n                            byte data[],\n                            List<ACL> acl,\n                            CreateMode createMode,\n                            StringCallback cb,\n                            Object ctx,\n                            FIFOToken token);\n\n{code}\n\nand also a call to get the current token:\n\n{code}\npublic FIFOToken getFifoToken() {\n    return this.fifoToken;\n}\n{code}\n\nAgain, the main reason for suggesting this is to enable such FIFO-enforced calls in the handle API rather than having a connection object.\n\nAnother point I was thinking about with respect to the use of {{getConnection}} is the following. If I'm a developer, where should I call it and when? In principle, we can do it upon receiving a {{SyncConnected}} event via the default watcher (transition from {{Disconnected}} to {{SyncConnected}}. It might not be possible to do it at that point in the case I have one or more threads submitting operations, though. The applications will need to pause before we get the new connection, otherwise we can have a mix of threads sending to the invalid connection while others send to the new connection. In the case it is ok that the FIFO order guarantee is per thread, we can have each thread individually calling {{getConnection}} (or whatever other variant we end up agreeing upon) upon receiving a connection loss error. \n\nThe last point of the list is important because we have proposed quite some time back to remove connection loss by resending upon reconnecting in ZOOKEEPER-22. If we resend, then we won't be erroring out requests with a connection loss event upon dropping a connection. If we do it, then we avoid the gaps that we are discussing in this issue in the first place. ZOOKEEPER-22 needs work on the server-side, though. On the positive side, the client-side API changes are minimal. \n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"created":"2016-10-25T12:00:29.289+0000","updated":"2016-10-25T18:17:31.708+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15606298","id":"15606298","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. I don't like much the idea of exposing a \"connection\". The abstraction we have historically is a session and the fact that a session can have multiple connections over time is mostly transparent to the application, except for the connection loss event, which makes it clear that there are multiple connections going on underneath. --[~fpj]\n\nNobody wants ZOOKEEPER-22 more than I do ;). It would solve this issue and make correct ZooKeeper usage so much simpler. But until ZOOKEEPER-22 is done, the concept of a connection is not hidden from applications, and exposing connections may be the most straightforward and honest thing to do. Even with the FIFO token, the application would need to know to grab a new FIFO token after seeing a connection loss event, so FIFO tokens can't be a fully separate concept from connections.\n\nOtherwise, the FIFO token vs {{getConnection()}} are equivalent in terms of their expressiveness, so I see the choice as a question of aesthetics.\n\n\nbq. Another point I was thinking about with respect to the use of getConnection is the following. If I'm a developer, where should I call it and when? In principle, we can do it upon receiving a SyncConnected event via the default watcher (transition from Disconnected to SyncConnected. It might not be possible to do it at that point in the case I have one or more threads submitting operations, though. The applications will need to pause before we get the new connection, otherwise we can have a mix of threads sending to the invalid connection while others send to the new connection. In the case it is ok that the FIFO order guarantee is per thread, we can have each thread individually calling getConnection (or whatever other variant we end up agreeing upon) upon receiving a connection loss error. --[~fpj]\n\nI'd argue strongly for the latter approach of using connections/FIFO tokens only locally. Applications should grab a connection/FIFO token when they're doing asynchronous work, then forget it and grab another one later when needed.\n\nIf someone did want the FIFO client order guarantee across threads, they might be insane, but they can share their connection/FIFO token across threads. I don't think this will be common usage.\n\nTaking the example from page 4 of the paper, here's some possible code:\n\n{code}\npublic void newLeader(ZooKeeper zk, ArrayList<string> config) {\n    while (true) {\n        ZKConnection conn = zk.getConnection()\n        // \"The new leader makes the configuration change by deleting ready, ...\"\n        conn.deleteAsync(\"/ready\", callback=logStuff)\n        // \"...updating the various configuration znodes, ...\"\n        for (int i = 0; i < config.size(); i++) {\n            conn.createAsync(\"/config-\" + i, config.get(i), EPHEMERAL, callback=logStuff)\n        }\n        // \"...and creating ready.\"\n        try {\n            conn.createSync(\"/ready\", \"\", EPHEMERAL)\n        } except (ConnectionLoss) {\n            continue;\n        }\n        return;\n    }\n}\n{code}\n\nNote that this code is grabbing a connection (FIFO token) before starting its pipeline, using it locally, then dropping it. In case of a connection loss, it gets another one.\n\nThis could be more sophisticated by keeping track of which operations had previously succeeded in the callbacks, but it shouldn't be necessary.\n\nWe could also sprinkle in:\n{code}\n        if (conn.isLost()) {\n            continue;\n        }\n{code}\nas an optimization/pessimization, but again, it shouldn't be necessary.\n\n\\\\\n----\n\\\\\n\nbq. do we have some applications that we can use to validate the api? it would be nice to validate the design before we standardize it. --[~breed]\n\nGood point. I think we'd want well-intentioned applications that make async calls, maybe some that care about FIFO order and some that don't. Any ideas?\n\n\nThere are a couple more alternatives I want to raise for discussion:\n\nOne possible stance would be: _Well, this adds too much complexity, so you can't have FIFO client order until ZOOKEEPER-22 is done_, WONTFIX.\n\nAnother more extreme stance would be to eliminate the FIFO client order guarantee altogether. A big question I've been wondering about is whether FIFO client order is useful in real world applications, and whether it's worth the implementation trouble.\n\nFIFO client order provides two potential benefits:\n - Leveraging FIFO client order may improve application performance. It does not add significant runtime cost in general, yet it can reduce round-trip stalls for applications that leverage it.\n - FIFO client order may simplify reasoning about applications by reducing the possible state space that they operate in.\n\nOn the other hand:\n\n - FIFO client order adds complexity to the implementation. It has to be guaranteed at every level of the stack. This issue shows how it was lost in the highest levels of the client API. Even if we fixed this issue, Curator or other wrappers might still throw away FIFO client order at even higher levels. And at lower levels, though the current implementation maintains FIFO client order, this has widespread implications restricting its design, including its consensus algorithm, its threading model, and its choice of transport protocol.\n - Relatedly, solving ZOOKEEPER-22 would be simpler by eliminating the FIFO client order guarantee, as the library could retry operations in any order (both reads and writes).\n - How many applications rely on FIFO client order? Users didn't seem to notice this bug. Does that imply they're doing just fine without FIFO client order, or are the conditions for this bug so rare that it did not come up in production or testing?\n - Using FIFO client order correctly seems difficult. My above sample code, for instance, looks simple but is quite subtle and fragile. It assumes the asynchronous operations will succeed as long as the connection is not lost (existing znodes in the way? ACLs? quotas after ZOOKEEPER-451?), and it only avoids leaving garbage behind on client crashes by using ephemeral nodes. Compare to a version that issues all the createAsync requests, blocks on their successful completion (possibly recovering from errors in nontrivial ways), then creates the /ready node. I think it'd be easier to see why that version works, at the runtime cost of an extra round trip delay.\n\nI know this is only tangentially related to this issue, but I'm really interested in hearing your thoughts.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-25T19:56:46.612+0000","updated":"2016-10-25T19:56:46.612+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15616890","id":"15616890","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"body":"bq. Some of the issues you're describing, we only had the opportunity to discuss in more detail in the book. It is really not self-promotion, and it is where we had a chance to talk more about some of the subtleties we have. --[~fpj]\n\nIndeed, page 116-117 of the ZooKeeper: Distributed Process Coordination book mentions this issue. It suggests:\n\nbq. If Op2 depends on Op1, ... wait for a successful execution of Op1 before submitting Op2...this approach is safe, but it adds a performance penalty...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=ongardie","name":"ongardie","key":"ongardie","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Diego Ongaro","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-28T23:10:54.905+0000","updated":"2016-10-28T23:11:54.100+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15620604","id":"15620604","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mmerli","name":"mmerli","key":"mmerli","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Matteo Merli","active":true,"timeZone":"America/Los_Angeles"},"body":"Although unrelated to the API semantic discussion above, you could use {{multi()}} to have multiple updates to be performed atomically. That would be as good as the async op followed by the sync op, in that you only have to wait for 1 operation to be synced/complete.\n\nEg: \n{code:java}\nList<Op> operations = new ArrayList<>();\noperations.add(Op.create(\"/data-23857\", \"...\"));\noperations.add(Op.create(\"/pointer\", \"/data-23857\"));\nzk.multi(operations);\n{code}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mmerli","name":"mmerli","key":"mmerli","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Matteo Merli","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-10-30T21:35:01.138+0000","updated":"2016-10-30T21:35:01.138+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15632811","id":"15632811","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"body":"multi will handle some of the use cases, but a simple one that it doesn't handle is if you want to implement swap:\n\nzk.getData(znode, ...)\nzk.setData(znode, ...)\n\nyou can't do that with multi (and i don't think we should extend multi to do it :)\n\nmutli also doesn't handle the case when you are updating lots of data and would go over max packet size.\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-11-03T14:07:10.123+0000","updated":"2016-11-03T14:07:10.123+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15632820","id":"15632820","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"body":"i would love to see ZOOKEEPER-22 fixed, but i don't think it will be fixed anytime soon. (it would be awesome to be surprised though :)\n\n@diego perhaps you could implement your idea in your go client implementation and propose it again if it works out well? i like the getConnection proposal.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=breed","name":"breed","key":"breed","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Benjamin Reed","active":true,"timeZone":"America/Los_Angeles"},"created":"2016-11-03T14:12:04.132+0000","updated":"2016-11-03T14:12:04.132+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13014437/comment/15632972","id":"15632972","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"body":"I think it would be a lot less disruptive for applications to fix ZOOKEEPER-22. Why can't we simply jointly work on getting ZOOKEEPER-22 fixed? ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=fpj","name":"fpj","key":"fpj","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=fpj&avatarId=16030","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fpj&avatarId=16030","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fpj&avatarId=16030","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fpj&avatarId=16030"},"displayName":"Flavio Junqueira","active":true,"timeZone":"Europe/Berlin"},"created":"2016-11-03T14:54:20.959+0000","updated":"2016-11-03T14:54:20.959+0000"}],"maxResults":15,"total":15,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2619/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i3591r:"}}