{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13115854","self":"https://issues.apache.org/jira/rest/api/2/issue/13115854","key":"ZOOKEEPER-2930","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":1200,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310801","id":"12310801","key":"ZOOKEEPER","name":"ZooKeeper","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310801&avatarId=10011","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310801&avatarId=10011","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310801&avatarId=10011","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310801&avatarId=10011"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10484","id":"10484","description":"Apache ZooKeeper related","name":"ZooKeeper"}},"fixVersions":[],"aggregatetimespent":1200,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2017-11-07T12:14:31.869+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Wed Mar 07 10:44:27 UTC 2018","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2930/watchers","watchCount":7,"isWatching":false},"created":"2017-11-03T08:16:20.128+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/2","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/critical.svg","name":"Critical","id":"2"},"labels":["pull-request-available"],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"3.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":0,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12338036","id":"12338036","description":"Fix release against 3.4 branch","name":"3.4.10","archived":false,"released":true,"releaseDate":"2017-03-30"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12335444","id":"12335444","description":"Beta release against 3.5 branch","name":"3.5.3","archived":false,"released":true,"releaseDate":"2017-04-17"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12339207","id":"12339207","description":"Fix release against 3.4 branch","name":"3.4.11","archived":false,"released":true,"releaseDate":"2017-11-09"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12340141","id":"12340141","description":"Beta release against 3.5 branch","name":"3.5.4","archived":false,"released":true,"releaseDate":"2018-05-17"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12342040","id":"12342040","description":"Fix release against 3.4 branch","name":"3.4.12","archived":false,"released":true,"releaseDate":"2018-05-01"}],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2018-07-11T13:06:07.955+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12312378","id":"12312378","name":"leaderElection","description":"Leader election algorithm for ZooKeeper"},{"self":"https://issues.apache.org/jira/rest/api/2/component/12312379","id":"12312379","name":"quorum","description":"Quorum determination for ZooKeeper"},{"self":"https://issues.apache.org/jira/rest/api/2/component/12312382","id":"12312382","name":"server","description":"General issues with the ZooKeeper server."}],"timeoriginalestimate":null,"description":"I deploy a cluster of ZooKeeper with three nodes:\r\n\r\nofs_zk1:20.10.11.101, 30.10.11.101\r\nofs_zk2:20.10.11.102, 30.10.11.102\r\nofs_zk3:20.10.11.103, 30.10.11.103\r\n\r\nI shutdown the network interfaces of ofs_zk2 using \"ifdown eth0 eth1\" command.\r\n\r\nIt is supposed that the new Leader should be elected in some seconds, but the fact is, ofs_zk1 and ofs_zk3 just keep electing again and again, but none of them can become the new Leader.\r\n\r\nI change the log level to DEBUG (the default is INFO), and restart zookeeper servers on ofs_zk1 and ofs_zk2 again, but it can not fix the problem.\r\n\r\nI read the log and the ZooKeeper source code, and I think I find the reason.\r\n\r\nWhen the potential leader(says ofs_zk3) begins the election(FastLeaderElection.lookForLeader()), it will send notifications to all the servers. \r\nWhen it fails to receive any notification during a timeout, it will resend the notifications, and double the timeout. This process will repeat until any notification is received or the timeout reaches a max value.\r\nThe FastLeaderElection.sendNotifications() just put the notification message into a queue and return. The WorkerSender is responsable to send the notifications.\r\n\r\nThe WorkerSender just process the notifications one by one by passing the notifications to QuorumCnxManager. Here comes the problem, the QuorumCnxManager.toSend() blocks for a long time when the notification is send to ofs_zk2(whose network is down) and some notifications (which belongs to ofs_zk1) will thus be blocked for a long time. The repeated notifications by FastLeaderElection.sendNotifications() just make things worse.\r\n\r\nHere is the related source code:\r\n\r\n{code:java}\r\n    public void toSend(Long sid, ByteBuffer b) {\r\n        /*\r\n         * If sending message to myself, then simply enqueue it (loopback).\r\n         */\r\n        if (this.mySid == sid) {\r\n             b.position(0);\r\n             addToRecvQueue(new Message(b.duplicate(), sid));\r\n            /*\r\n             * Otherwise send to the corresponding thread to send.\r\n             */\r\n        } else {\r\n             /*\r\n              * Start a new connection if doesn't have one already.\r\n              */\r\n             ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY);\r\n             ArrayBlockingQueue<ByteBuffer> bqExisting = queueSendMap.putIfAbsent(sid, bq);\r\n             if (bqExisting != null) {\r\n                 addToSendQueue(bqExisting, b);\r\n             } else {\r\n                 addToSendQueue(bq, b);\r\n             }\r\n             \r\n             // This may block!!!\r\n             connectOne(sid);\r\n                \r\n        }\r\n    }\r\n{code}\r\n\r\nTherefore, when ofs_zk3 believes that it is the leader, it begins to wait the epoch ack, but in fact the ofs_zk1 does not receive the notification(which says the leader is ofs_zk3) because the ofs_zk3 has not sent the notification(which may still exist in the sendqueue of WorkerSender). At last, the potential leader ofs_zk3 fails to receive the epoch ack in timeout, so it quits the leader and begins a new election. \r\n\r\nThe log files of ofs_zk1 and ofs_zk3 are attached.","customfield_10010":null,"timetracking":{"remainingEstimate":"0h","timeSpent":"20m","remainingEstimateSeconds":0,"timeSpentSeconds":1200},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12895590","id":"12895590","filename":"zoo.cfg","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"created":"2017-11-03T08:20:06.553+0000","size":442,"mimeType":"application/octet-stream","content":"https://issues.apache.org/jira/secure/attachment/12895590/zoo.cfg"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12895592","id":"12895592","filename":"zookeeper1.log","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"created":"2017-11-03T08:20:31.988+0000","size":32325031,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12895592/zookeeper1.log"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12895591","id":"12895591","filename":"zookeeper2.log","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"created":"2017-11-03T08:20:33.376+0000","size":32794704,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12895591/zookeeper2.log"}],"aggregatetimeestimate":0,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"Leader cannot be elected due to network timeout of some members.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"customfield_12310290":null,"aggregateprogress":{"progress":1200,"total":1200,"percent":100},"customfield_12311024":null,"environment":"Java 8\r\nZooKeeper 3.4.11(from github)\r\nCentos6.5","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":1200,"total":1200,"percent":100},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16237258","id":"16237258","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"body":"zookeeper1.log ： ofs_zk1\r\nzookeeper2.log ： ofs_zk3","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"created":"2017-11-03T08:20:38.090+0000","updated":"2017-11-03T08:20:38.090+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16238828","id":"16238828","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"body":"I suggest that there can be more that one WorkSender in FastLeaderElection, so that network failure of some zk servers will not affect the notifications to others.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"created":"2017-11-04T07:33:40.660+0000","updated":"2017-11-04T07:33:40.660+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16241912","id":"16241912","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=yangzhixin","name":"yangzhixin","key":"yangzhixin","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"yangzhixin","active":true,"timeZone":"Asia/Shanghai"},"body":"I encounter the same problem. Wait for a conclusion.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=yangzhixin","name":"yangzhixin","key":"yangzhixin","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"yangzhixin","active":true,"timeZone":"Asia/Shanghai"},"created":"2017-11-07T12:14:31.869+0000","updated":"2017-11-07T12:14:31.869+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16249027","id":"16249027","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=beeflyme","name":"beeflyme","key":"beeflyme","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"caixiaofeng","active":true,"timeZone":"Etc/UTC"},"body":" Mark, meet the same problem.    ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=beeflyme","name":"beeflyme","key":"beeflyme","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"caixiaofeng","active":true,"timeZone":"Etc/UTC"},"created":"2017-11-13T01:14:00.999+0000","updated":"2017-11-13T01:14:00.999+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16350736","id":"16350736","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"GitHub user JonathanO opened a pull request:\n\n    https://github.com/apache/zookeeper/pull/456\n\n    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.\n\n    Move sock.connect() into the async connection worker thread.\r\n    Use initiateConnectionAsync for all connections.\r\n    This prevents connection delays blocking notifications to other nodes.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/transferwise/zookeeper ZOOKEEPER-2930\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/zookeeper/pull/456.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #456\n    \n----\ncommit 68e327e112b0910e56b9fa2b3ba948e4179adb6b\nAuthor: Jonathan Oddy <jonathan.oddy@...>\nDate:   2018-02-02T15:33:50Z\n\n    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.\n    \n    Move sock.connect() into the async connection worker thread.\n    Use initiateConnectionAsync for all connections.\n    This prevents connection delays blocking notifications to other nodes.\n\n----\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-02T18:00:49.557+0000","updated":"2018-02-02T18:00:49.557+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16352198","id":"16352198","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jono","name":"jono","key":"jono","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34052","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34052","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34052","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34052"},"displayName":"Jonathan Oddy","active":true,"timeZone":"Etc/UTC"},"body":"So, I think what happens is, if the 2nd node in the list dies in a way that causes new connections to time out then the notification messages to the 3rd node are delayed by >=5s while those to the 1st node are delivered on time. (sendNotifications() queues a notification to all three nodes (including the local node), in order, and toSend() blocks during sending the message to the 2nd node.)\r\n\r\nThis 5s delay means that if the 3rd node is elected, it will see the election complete >= 5s after the 1st node does. The 1st node attempts to connect to the 3rd on the leader port 5 times with a 1s delay (both hard coded) but, since the 3rd node hasn't seen the election complete, it hasn't started listening on that port yet. Unless you're very lucky with timing, the 1st node will give up and start a new election round before the 3rd realises that it has been elected. The 3rd node then sits there for initLimit before going back to the LOOKING state, leaving you with a broken cluster for at least initLimit.\r\n\r\nMy patch attempts to fix this by making the entire process of establishing a connection async, avoiding it blocking toSend().","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jono","name":"jono","key":"jono","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34052","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34052","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34052","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34052"},"displayName":"Jonathan Oddy","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-05T09:51:51.207+0000","updated":"2018-02-05T09:51:51.207+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16352637","id":"16352637","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user JonathanO commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/456#discussion_r166036745\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---\n    @@ -689,15 +669,15 @@ synchronized void connectOne(long sid){\n                 Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n                 if (lastCommittedView.containsKey(sid)) {\n                     knownId = true;\n    -                if (connectOne(sid, lastCommittedView.get(sid).electionAddr))\n    -                    return;\n    --- End diff --\n    \n    This part of the change isn't quite right since it relied on connectOne returning false on an IOException calling sock.connect(). We will no longer attempt to use lastProposedView.get(sid).electionAddr in the case that a connection using the lastCommittedView failed and the electionAddr has changed. I don't know what effect this will have. Maybe I need to move this condition into the async connection mechanism too?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-05T16:54:53.752+0000","updated":"2018-02-05T16:54:53.752+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16365494","id":"16365494","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"GitHub user JonathanO opened a pull request:\n\n    https://github.com/apache/zookeeper/pull/465\n\n    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.\n\n    Backported to 3.4 from the ZOOKEEPER-2930 branch.\r\n    \r\n    Move sock.connect() into the async connection worker thread.\r\n    Moved a load of connectOne(sid) into the async connection worker thread.\r\n    Use use the async connection worker for all connections.\r\n    This prevents connection delays blocking notifications to other nodes.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/transferwise/zookeeper branch-3.4-ZOOKEEPER-2930\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/zookeeper/pull/465.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #465\n    \n----\ncommit ca05df6049e3282fef9fd3f34d07337011b5f4f6\nAuthor: Jonathan Oddy <jonathan.oddy@...>\nDate:   2018-02-15T12:22:24Z\n\n    ZOOKEEPER-2930: Leader cannot be elected due to network timeout of some members.\n    \n    Backported from 3.5.\n    \n    Move sock.connect() into the async connection worker thread.\n    Moved a load of connectOne(sid) into the async connection worker thread.\n    Use use the async connection worker for all connections.\n    This prevents connection delays blocking notifications to other nodes.\n\n----\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-15T13:04:03.316+0000","updated":"2018-02-15T13:04:03.316+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16366332","id":"16366332","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/456#discussion_r168620297\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---\n    @@ -318,76 +318,167 @@ public Thread newThread(Runnable r) {\n          */\n         public void testInitiateConnection(long sid) throws Exception {\n             LOG.debug(\"Opening channel to server \" + sid);\n    -        Socket sock = new Socket();\n    -        setSockOpts(sock);\n    -        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);\n    -        initiateConnection(sock, sid);\n    +        initiateConnection(sid, self.getVotingView().get(sid).electionAddr);\n    +    }\n    +\n    +    private Socket openChannel(long sid, InetSocketAddress electionAddr) {\n    +        LOG.debug(\"Opening channel to server \" + sid);\n    +        try {\n    +            final Socket sock = new Socket();\n    +            setSockOpts(sock);\n    +            sock.connect(electionAddr, cnxTO);\n    +            LOG.debug(\"Connected to server \" + sid);\n    +            return sock;\n    +        } catch (UnresolvedAddressException e) {\n    +            // Sun doesn't include the address that causes this\n    +            // exception to be thrown, also UAE cannot be wrapped cleanly\n    +            // so we log the exception in order to capture this critical\n    +            // detail.\n    +            LOG.warn(\"Cannot open channel to \" + sid\n    +                    + \" at election address \" + electionAddr, e);\n    +            throw e;\n    +        } catch (IOException e) {\n    +            LOG.warn(\"Cannot open channel to \" + sid\n    +                            + \" at election address \" + electionAddr,\n    +                    e);\n    +            return null;\n    +        }\n         }\n     \n         /**\n          * If this server has initiated the connection, then it gives up on the\n          * connection if it loses challenge. Otherwise, it keeps the connection.\n          */\n    -    public void initiateConnection(final Socket sock, final Long sid) {\n    +    public boolean initiateConnection(final Long sid, InetSocketAddress electionAddr) {\n             try {\n    -            startConnection(sock, sid);\n    -        } catch (IOException e) {\n    -            LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n    -                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);\n    -            closeSocket(sock);\n    -            return;\n    +            Socket sock = openChannel(sid, electionAddr);\n    +            if (sock != null) {\n    +                try {\n    +                    startConnection(sock, sid);\n    +                } catch (IOException e) {\n    +                    LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n    +                            new Object[]{sid, sock.getRemoteSocketAddress()}, e);\n    +                    closeSocket(sock);\n    +                }\n    +                return true;\n    +            } else {\n    +                return false;\n    +            }\n    +        } finally {\n    +            inprogressConnections.remove(sid);\n             }\n         }\n     \n    -    /**\n    -     * Server will initiate the connection request to its peer server\n    -     * asynchronously via separate connection thread.\n    -     */\n    -    public void initiateConnectionAsync(final Socket sock, final Long sid) {\n    +    synchronized private void connectOneAsync(final Long sid, final ZooKeeperThread connectorThread) {\n    +        if (senderWorkerMap.get(sid) != null) {\n    +            LOG.debug(\"There is a connection already for server \" + sid);\n    +            return;\n    +        }\n             if(!inprogressConnections.add(sid)){\n                 // simply return as there is a connection request to\n                 // server 'sid' already in progress.\n                 LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\",\n                         sid);\n    -            closeSocket(sock);\n                 return;\n             }\n             try {\n    -            connectionExecutor.execute(\n    -                    new QuorumConnectionReqThread(sock, sid));\n    +            connectionExecutor.execute(connectorThread);\n                 connectionThreadCnt.incrementAndGet();\n             } catch (Throwable e) {\n                 // Imp: Safer side catching all type of exceptions and remove 'sid'\n                 // from inprogress connections. This is to avoid blocking further\n                 // connection requests from this 'sid' in case of errors.\n                 inprogressConnections.remove(sid);\n                 LOG.error(\"Exception while submitting quorum connection request\", e);\n    -            closeSocket(sock);\n             }\n         }\n     \n    +    /**\n    +     * Try to establish a connection to server with id sid using its electionAddr.\n    +     *\n    +     * Server will initiate the connection request to its peer server\n    +     * asynchronously via separate connection thread.\n    +     *\n    +     *  @param sid  server id\n    +     *  @param electionAddr election address\n    +     */\n    +    private void connectOne(final Long sid, InetSocketAddress electionAddr) {\n    +        connectOneAsync(sid, new QuorumConnectionReqThread(sid, electionAddr));\n    +    }\n    +\n    +    /**\n    +     * Try to establish a connection to server with id sid.\n    +     *\n    +     * Server will initiate the connection request to its peer server\n    +     * asynchronously via separate connection thread.\n    +     *\n    +     *  @param sid  server id\n    +     */\n    +    public void connectOne(final Long sid) {\n    +        connectOneAsync(sid, new QuorumConnectionReqBySidThread(sid));\n    +    }\n    +\n         /**\n          * Thread to send connection request to peer server.\n          */\n    -    private class QuorumConnectionReqThread extends ZooKeeperThread {\n    -        final Socket sock;\n    +    private class QuorumConnectionReqBySidThread extends ZooKeeperThread {\n             final Long sid;\n    -        QuorumConnectionReqThread(final Socket sock, final Long sid) {\n    +\n    +        QuorumConnectionReqBySidThread(final Long sid) {\n                 super(\"QuorumConnectionReqThread-\" + sid);\n    -            this.sock = sock;\n                 this.sid = sid;\n             }\n     \n             @Override\n             public void run() {\n    -            try{\n    -                initiateConnection(sock, sid);\n    -            } finally {\n    -                inprogressConnections.remove(sid);\n    +            synchronized (self.QV_LOCK) {\n    +                boolean knownId = false;\n    +                // Resolve hostname for the remote server before attempting to\n    +                // connect in case the underlying ip address has changed.\n    +                self.recreateSocketAddresses(sid);\n    +                Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n    +                QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n    +                Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n    +                if (lastCommittedView.containsKey(sid)) {\n    +                    knownId = true;\n    +                    if (initiateConnection(sid, lastCommittedView.get(sid).electionAddr)) {\n    +                        return;\n    +                    }\n    +                }\n    +                if (lastSeenQV != null && lastProposedView.containsKey(sid)\n    +                        && (!knownId || (lastProposedView.get(sid).electionAddr !=\n    +                        lastCommittedView.get(sid).electionAddr))) {\n    +                    knownId = true;\n    +                    if (initiateConnection(sid, lastProposedView.get(sid).electionAddr)) {\n    +                        return;\n    +                    }\n    +                }\n    +                if (!knownId) {\n    +                    LOG.warn(\"Invalid server id: \" + sid);\n    +                    return;\n    +                }\n                 }\n             }\n         }\n     \n    +    /**\n    +     * Thread to send connection request to peer server.\n    +     */\n    +    private class QuorumConnectionReqThread extends ZooKeeperThread {\n    --- End diff --\n    \n    Since we are making this change to run the connection establishment on a separate thread, I wonder if it would make sense to use an executor rather than instantiate a thread each time. What do you think?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-15T22:11:41.280+0000","updated":"2018-02-15T22:11:41.280+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16366335","id":"16366335","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user fpj commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/456\n  \n    I have also tested this PR a bit locally.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-15T22:12:25.888+0000","updated":"2018-02-15T22:12:25.888+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16372624","id":"16372624","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user JonathanO commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/456#discussion_r169910520\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---\n    @@ -318,76 +318,167 @@ public Thread newThread(Runnable r) {\n          */\n         public void testInitiateConnection(long sid) throws Exception {\n             LOG.debug(\"Opening channel to server \" + sid);\n    -        Socket sock = new Socket();\n    -        setSockOpts(sock);\n    -        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);\n    -        initiateConnection(sock, sid);\n    +        initiateConnection(sid, self.getVotingView().get(sid).electionAddr);\n    +    }\n    +\n    +    private Socket openChannel(long sid, InetSocketAddress electionAddr) {\n    +        LOG.debug(\"Opening channel to server \" + sid);\n    +        try {\n    +            final Socket sock = new Socket();\n    +            setSockOpts(sock);\n    +            sock.connect(electionAddr, cnxTO);\n    +            LOG.debug(\"Connected to server \" + sid);\n    +            return sock;\n    +        } catch (UnresolvedAddressException e) {\n    +            // Sun doesn't include the address that causes this\n    +            // exception to be thrown, also UAE cannot be wrapped cleanly\n    +            // so we log the exception in order to capture this critical\n    +            // detail.\n    +            LOG.warn(\"Cannot open channel to \" + sid\n    +                    + \" at election address \" + electionAddr, e);\n    +            throw e;\n    +        } catch (IOException e) {\n    +            LOG.warn(\"Cannot open channel to \" + sid\n    +                            + \" at election address \" + electionAddr,\n    +                    e);\n    +            return null;\n    +        }\n         }\n     \n         /**\n          * If this server has initiated the connection, then it gives up on the\n          * connection if it loses challenge. Otherwise, it keeps the connection.\n          */\n    -    public void initiateConnection(final Socket sock, final Long sid) {\n    +    public boolean initiateConnection(final Long sid, InetSocketAddress electionAddr) {\n             try {\n    -            startConnection(sock, sid);\n    -        } catch (IOException e) {\n    -            LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n    -                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);\n    -            closeSocket(sock);\n    -            return;\n    +            Socket sock = openChannel(sid, electionAddr);\n    +            if (sock != null) {\n    +                try {\n    +                    startConnection(sock, sid);\n    +                } catch (IOException e) {\n    +                    LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n    +                            new Object[]{sid, sock.getRemoteSocketAddress()}, e);\n    +                    closeSocket(sock);\n    +                }\n    +                return true;\n    +            } else {\n    +                return false;\n    +            }\n    +        } finally {\n    +            inprogressConnections.remove(sid);\n             }\n         }\n     \n    -    /**\n    -     * Server will initiate the connection request to its peer server\n    -     * asynchronously via separate connection thread.\n    -     */\n    -    public void initiateConnectionAsync(final Socket sock, final Long sid) {\n    +    synchronized private void connectOneAsync(final Long sid, final ZooKeeperThread connectorThread) {\n    +        if (senderWorkerMap.get(sid) != null) {\n    +            LOG.debug(\"There is a connection already for server \" + sid);\n    +            return;\n    +        }\n             if(!inprogressConnections.add(sid)){\n                 // simply return as there is a connection request to\n                 // server 'sid' already in progress.\n                 LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\",\n                         sid);\n    -            closeSocket(sock);\n                 return;\n             }\n             try {\n    -            connectionExecutor.execute(\n    -                    new QuorumConnectionReqThread(sock, sid));\n    +            connectionExecutor.execute(connectorThread);\n                 connectionThreadCnt.incrementAndGet();\n             } catch (Throwable e) {\n                 // Imp: Safer side catching all type of exceptions and remove 'sid'\n                 // from inprogress connections. This is to avoid blocking further\n                 // connection requests from this 'sid' in case of errors.\n                 inprogressConnections.remove(sid);\n                 LOG.error(\"Exception while submitting quorum connection request\", e);\n    -            closeSocket(sock);\n             }\n         }\n     \n    +    /**\n    +     * Try to establish a connection to server with id sid using its electionAddr.\n    +     *\n    +     * Server will initiate the connection request to its peer server\n    +     * asynchronously via separate connection thread.\n    +     *\n    +     *  @param sid  server id\n    +     *  @param electionAddr election address\n    +     */\n    +    private void connectOne(final Long sid, InetSocketAddress electionAddr) {\n    +        connectOneAsync(sid, new QuorumConnectionReqThread(sid, electionAddr));\n    +    }\n    +\n    +    /**\n    +     * Try to establish a connection to server with id sid.\n    +     *\n    +     * Server will initiate the connection request to its peer server\n    +     * asynchronously via separate connection thread.\n    +     *\n    +     *  @param sid  server id\n    +     */\n    +    public void connectOne(final Long sid) {\n    +        connectOneAsync(sid, new QuorumConnectionReqBySidThread(sid));\n    +    }\n    +\n         /**\n          * Thread to send connection request to peer server.\n          */\n    -    private class QuorumConnectionReqThread extends ZooKeeperThread {\n    -        final Socket sock;\n    +    private class QuorumConnectionReqBySidThread extends ZooKeeperThread {\n             final Long sid;\n    -        QuorumConnectionReqThread(final Socket sock, final Long sid) {\n    +\n    +        QuorumConnectionReqBySidThread(final Long sid) {\n                 super(\"QuorumConnectionReqThread-\" + sid);\n    -            this.sock = sock;\n                 this.sid = sid;\n             }\n     \n             @Override\n             public void run() {\n    -            try{\n    -                initiateConnection(sock, sid);\n    -            } finally {\n    -                inprogressConnections.remove(sid);\n    +            synchronized (self.QV_LOCK) {\n    +                boolean knownId = false;\n    +                // Resolve hostname for the remote server before attempting to\n    +                // connect in case the underlying ip address has changed.\n    +                self.recreateSocketAddresses(sid);\n    +                Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n    +                QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n    +                Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n    +                if (lastCommittedView.containsKey(sid)) {\n    +                    knownId = true;\n    +                    if (initiateConnection(sid, lastCommittedView.get(sid).electionAddr)) {\n    +                        return;\n    +                    }\n    +                }\n    +                if (lastSeenQV != null && lastProposedView.containsKey(sid)\n    +                        && (!knownId || (lastProposedView.get(sid).electionAddr !=\n    +                        lastCommittedView.get(sid).electionAddr))) {\n    +                    knownId = true;\n    +                    if (initiateConnection(sid, lastProposedView.get(sid).electionAddr)) {\n    +                        return;\n    +                    }\n    +                }\n    +                if (!knownId) {\n    +                    LOG.warn(\"Invalid server id: \" + sid);\n    +                    return;\n    +                }\n                 }\n             }\n         }\n     \n    +    /**\n    +     * Thread to send connection request to peer server.\n    +     */\n    +    private class QuorumConnectionReqThread extends ZooKeeperThread {\n    --- End diff --\n    \n    I considered it, especially as the QuorumConnectionReqBySidThread case (and the backport to 3.4 #465) are effectively run serially. It just seemed consistent with the existing approach to stick with creating a thread for every new connection. There shouldn't be large numbers of them being created, so I figured it should be fine.\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-02-22T10:18:36.386+0000","updated":"2018-02-22T10:18:36.386+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16381347","id":"16381347","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"body":"I hope this PB can be fix in version 3.4.X, since 3.4.X is the stable version.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jiangjiafu","name":"jiangjiafu","key":"jiangjiafu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jiangjiafu&avatarId=31525","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jiangjiafu&avatarId=31525","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jiangjiafu&avatarId=31525","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jiangjiafu&avatarId=31525"},"displayName":"Jiafu Jiang","active":true,"timeZone":"Asia/Hong_Kong"},"created":"2018-03-01T01:11:44.699+0000","updated":"2018-03-01T01:11:44.699+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16385920","id":"16385920","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jono","name":"jono","key":"jono","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34052","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34052","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34052","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34052"},"displayName":"Jonathan Oddy","active":true,"timeZone":"Etc/UTC"},"body":"PR #465 contains the backport of my fix to 3.4.x.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jono","name":"jono","key":"jono","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=34052","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34052","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34052","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34052"},"displayName":"Jonathan Oddy","active":true,"timeZone":"Etc/UTC"},"created":"2018-03-05T10:38:54.657+0000","updated":"2018-03-05T10:38:54.657+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/comment/16389384","id":"16389384","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"body":"Github user JonathanO commented on a diff in the pull request:\n\n    https://github.com/apache/zookeeper/pull/456#discussion_r172802731\n  \n    --- Diff: src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java ---\n    @@ -318,76 +318,167 @@ public Thread newThread(Runnable r) {\n          */\n         public void testInitiateConnection(long sid) throws Exception {\n             LOG.debug(\"Opening channel to server \" + sid);\n    -        Socket sock = new Socket();\n    -        setSockOpts(sock);\n    -        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);\n    -        initiateConnection(sock, sid);\n    +        initiateConnection(sid, self.getVotingView().get(sid).electionAddr);\n    +    }\n    +\n    +    private Socket openChannel(long sid, InetSocketAddress electionAddr) {\n    +        LOG.debug(\"Opening channel to server \" + sid);\n    +        try {\n    +            final Socket sock = new Socket();\n    +            setSockOpts(sock);\n    +            sock.connect(electionAddr, cnxTO);\n    +            LOG.debug(\"Connected to server \" + sid);\n    +            return sock;\n    +        } catch (UnresolvedAddressException e) {\n    +            // Sun doesn't include the address that causes this\n    +            // exception to be thrown, also UAE cannot be wrapped cleanly\n    +            // so we log the exception in order to capture this critical\n    +            // detail.\n    +            LOG.warn(\"Cannot open channel to \" + sid\n    +                    + \" at election address \" + electionAddr, e);\n    +            throw e;\n    +        } catch (IOException e) {\n    +            LOG.warn(\"Cannot open channel to \" + sid\n    +                            + \" at election address \" + electionAddr,\n    +                    e);\n    +            return null;\n    +        }\n         }\n     \n         /**\n          * If this server has initiated the connection, then it gives up on the\n          * connection if it loses challenge. Otherwise, it keeps the connection.\n          */\n    -    public void initiateConnection(final Socket sock, final Long sid) {\n    +    public boolean initiateConnection(final Long sid, InetSocketAddress electionAddr) {\n             try {\n    -            startConnection(sock, sid);\n    -        } catch (IOException e) {\n    -            LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n    -                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);\n    -            closeSocket(sock);\n    -            return;\n    +            Socket sock = openChannel(sid, electionAddr);\n    +            if (sock != null) {\n    +                try {\n    +                    startConnection(sock, sid);\n    +                } catch (IOException e) {\n    +                    LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n    +                            new Object[]{sid, sock.getRemoteSocketAddress()}, e);\n    +                    closeSocket(sock);\n    +                }\n    +                return true;\n    +            } else {\n    +                return false;\n    +            }\n    +        } finally {\n    +            inprogressConnections.remove(sid);\n             }\n         }\n     \n    -    /**\n    -     * Server will initiate the connection request to its peer server\n    -     * asynchronously via separate connection thread.\n    -     */\n    -    public void initiateConnectionAsync(final Socket sock, final Long sid) {\n    +    synchronized private void connectOneAsync(final Long sid, final ZooKeeperThread connectorThread) {\n    +        if (senderWorkerMap.get(sid) != null) {\n    +            LOG.debug(\"There is a connection already for server \" + sid);\n    +            return;\n    +        }\n             if(!inprogressConnections.add(sid)){\n                 // simply return as there is a connection request to\n                 // server 'sid' already in progress.\n                 LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\",\n                         sid);\n    -            closeSocket(sock);\n                 return;\n             }\n             try {\n    -            connectionExecutor.execute(\n    -                    new QuorumConnectionReqThread(sock, sid));\n    +            connectionExecutor.execute(connectorThread);\n                 connectionThreadCnt.incrementAndGet();\n             } catch (Throwable e) {\n                 // Imp: Safer side catching all type of exceptions and remove 'sid'\n                 // from inprogress connections. This is to avoid blocking further\n                 // connection requests from this 'sid' in case of errors.\n                 inprogressConnections.remove(sid);\n                 LOG.error(\"Exception while submitting quorum connection request\", e);\n    -            closeSocket(sock);\n             }\n         }\n     \n    +    /**\n    +     * Try to establish a connection to server with id sid using its electionAddr.\n    +     *\n    +     * Server will initiate the connection request to its peer server\n    +     * asynchronously via separate connection thread.\n    +     *\n    +     *  @param sid  server id\n    +     *  @param electionAddr election address\n    +     */\n    +    private void connectOne(final Long sid, InetSocketAddress electionAddr) {\n    +        connectOneAsync(sid, new QuorumConnectionReqThread(sid, electionAddr));\n    +    }\n    +\n    +    /**\n    +     * Try to establish a connection to server with id sid.\n    +     *\n    +     * Server will initiate the connection request to its peer server\n    +     * asynchronously via separate connection thread.\n    +     *\n    +     *  @param sid  server id\n    +     */\n    +    public void connectOne(final Long sid) {\n    +        connectOneAsync(sid, new QuorumConnectionReqBySidThread(sid));\n    +    }\n    +\n         /**\n          * Thread to send connection request to peer server.\n          */\n    -    private class QuorumConnectionReqThread extends ZooKeeperThread {\n    -        final Socket sock;\n    +    private class QuorumConnectionReqBySidThread extends ZooKeeperThread {\n             final Long sid;\n    -        QuorumConnectionReqThread(final Socket sock, final Long sid) {\n    +\n    +        QuorumConnectionReqBySidThread(final Long sid) {\n                 super(\"QuorumConnectionReqThread-\" + sid);\n    -            this.sock = sock;\n                 this.sid = sid;\n             }\n     \n             @Override\n             public void run() {\n    -            try{\n    -                initiateConnection(sock, sid);\n    -            } finally {\n    -                inprogressConnections.remove(sid);\n    +            synchronized (self.QV_LOCK) {\n    +                boolean knownId = false;\n    +                // Resolve hostname for the remote server before attempting to\n    +                // connect in case the underlying ip address has changed.\n    +                self.recreateSocketAddresses(sid);\n    +                Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n    +                QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n    +                Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n    +                if (lastCommittedView.containsKey(sid)) {\n    +                    knownId = true;\n    +                    if (initiateConnection(sid, lastCommittedView.get(sid).electionAddr)) {\n    +                        return;\n    +                    }\n    +                }\n    +                if (lastSeenQV != null && lastProposedView.containsKey(sid)\n    +                        && (!knownId || (lastProposedView.get(sid).electionAddr !=\n    +                        lastCommittedView.get(sid).electionAddr))) {\n    +                    knownId = true;\n    +                    if (initiateConnection(sid, lastProposedView.get(sid).electionAddr)) {\n    +                        return;\n    +                    }\n    +                }\n    +                if (!knownId) {\n    +                    LOG.warn(\"Invalid server id: \" + sid);\n    +                    return;\n    +                }\n                 }\n             }\n         }\n     \n    +    /**\n    +     * Thread to send connection request to peer server.\n    +     */\n    +    private class QuorumConnectionReqThread extends ZooKeeperThread {\n    --- End diff --\n    \n    Are you OK with this approach, or would you prefer me to change it?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"created":"2018-03-07T10:44:27.257+0000","updated":"2018-03-07T10:44:27.257+0000"}],"maxResults":14,"total":14,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/ZOOKEEPER-2930/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":2,"worklogs":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/worklog/121871","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user JiangJiafu commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/465\n  \n    Will this patch be merged to 3.4 branch？\n","created":"2018-07-11T11:58:43.123+0000","updated":"2018-07-11T11:58:43.123+0000","started":"2018-07-11T11:58:43.122+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"121871","issueId":"13115854"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13115854/worklog/121890","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=githubbot","name":"githubbot","key":"githubbot","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF GitHub Bot","active":true,"timeZone":"Etc/UTC"},"comment":"Github user JonathanO commented on the issue:\n\n    https://github.com/apache/zookeeper/pull/456\n  \n    Rebased on top of latest master.\n","created":"2018-07-11T13:06:07.950+0000","updated":"2018-07-11T13:06:07.950+0000","started":"2018-07-11T13:06:07.949+0000","timeSpent":"10m","timeSpentSeconds":600,"id":"121890","issueId":"13115854"}]},"customfield_12311820":"0|i3mcnj:"}}