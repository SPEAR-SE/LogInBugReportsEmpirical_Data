[A user on the mailing list reported the following NPE after upgrading from 0.7 to 0.8:

{noformat}
java:printError(380)) - Failed with exception null
java.lang.NullPointerException
       at org.apache.hadoop.hive.ql.metadata.Table.checkValidity(Table.java:162
)
       at org.apache.hadoop.hive.ql.metadata.Hive.getTable(Hive.java:946)
       at org.apache.hadoop.hive.ql.metadata.Hive.getTable(Hive.java:860)
       at org.apache.hadoop.hive.ql.exec.DDLTask.describeTable(DDLTask.java:252
7)
       at org.apache.hadoop.hive.ql.exec.DDLTask.execute(DDLTask.java:298)
       at org.apache.hadoop.hive.ql.exec.Task.executeTask(Task.java:133)
       at org.apache.hadoop.hive.ql.exec.TaskRunner.runSequential(TaskRunner.ja
va:57)
       at org.apache.hadoop.hive.ql.Driver.launchTask(Driver.java:1332)
       at org.apache.hadoop.hive.ql.Driver.execute(Driver.java:1123)
       at org.apache.hadoop.hive.ql.Driver.run(Driver.java:931)
       at org.apache.hadoop.hive.cli.CliDriver.processLocalCmd(CliDriver.java:261)
       at org.apache.hadoop.hive.cli.CliDriver.processCmd(CliDriver.java:218)
       at org.apache.hadoop.hive.cli.CliDriver.processLine(CliDriver.java:409)
       at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:684)
       at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:567)
       at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
       at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
       at java.lang.reflect.Method.invoke(Method.java:597)
       at org.apache.hadoop.util.RunJar.main(RunJar.java:156)

2012-06-18 19:51:23,180 ERROR org.apache.hadoop.hive.ql.Driver (SessionState.java:printError(380)) - FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask
{noformat}

Here's the relevant code from Table.checkValidity:

{code:java}
  public void checkValidity() throws HiveException {
    // check for validity
    String name = tTable.getTableName();
    if (null == name || name.length() == 0
        || !MetaStoreUtils.validateName(name)) {
      throw new HiveException("[" + name + "]: is not a valid table name");
    }
    if (0 == getCols().size()) {
      throw new HiveException(
          "at least one column must be specified for the table");
    }
    if (!isView()) {
      if (null == getDeserializerFromMetaStore()) {
        throw new HiveException("must specify a non-null serDe");
      }
      if (null == getInputFormatClass()) {
        throw new HiveException("must specify an InputFormat class");
      }
      if (null == getOutputFormatClass()) {
        throw new HiveException("must specify an OutputFormat class");
      }
    }
...
{code}

The NPE is getting thrown here: "if (0 == getCols().size())", most likely because getCols() returned null.

A couple points:
* A method like getCols() should never return null. Return an empty list if there are no columns.
* The exceptions should reference the fully qualified name of the Table in question.
* We should probably enforce validity checks only as data enters the metastore, and simply log a WARNing if a catalog object fails a validity check on its way out of the metastore (or maybe make the outbound failure action configurable?).
]