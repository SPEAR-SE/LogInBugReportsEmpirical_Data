[The naive fix is to have
{noformat}
output = new Object[eval.length];
try {
      for (; i < eval.length; ++i) {
        output[i] = eval[i].evaluate(row);
      }
}
{noformat}

in the select operator processOp.

However this affects all the other operations as well possibly leading to memory churn. All other approaches I could think of seem cumbersome.

1. Copy the object using the copyToStandardObject method in ObjectInspectorUtils modifies the object itself and requires re-initializing the joinKeys(ExprNodeEvaluators) with the new object inspector. However, this doesn't work with just these changes because we cannot re-initialize an ExprNodeEvaluator with a StandardObjectInspector. It expects a StructObjectInspector which will have to re-worked if we go with this approach.

2. Try to create a new object of the same composition with a shallow copy. However this is not straight-forward either. It requires the struct object inspector to be re-worked to return an object in the same composition as the original.

3. Special case SMB with an if in the select operator to create a new output object. This would hurt vectorization though because it adds an if condition in the tight loop.

4. Create a new select operator for SMB join which extends the current select operator. This could be fixed to have the naive solution above without the memory penalty for the other operations. However, this requires some plan side changes.

I am not sure if I have missed any other way of solving this. [~navis] Could you please provide your comments.

Thanks
Vikram.
, [~vikram.dixit] I've forgot whole context of SMBJoin. Could I get some test queries to follow up your description?, It is quite easy to reproduce this on a cluster but I haven't had success
with our unit tests. I will come up with one and post it here.

Thanks
Vikram.






-- 
Nothing better than when appreciated for hard work.
-Mark
, Attached is the test and a fix. The problem occurs when the small table is bucketed and partitioned and has a select sub-query. The select operator that is introduced as part of the sub-query causes the issue described.

Thanks to [~rhbutani] for helping with the solution and test case. It looks like the right way to run these type of tests is via the MinimrCliDriver as the CliDriver tests mask the issue by having a single reducer resulting in incorrect bucketing., https://reviews.apache.org/r/16213/, 

{color:green}Overall{color}: +1 all checks pass

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12618384/HIVE-5973.1.patch

{color:green}SUCCESS:{color} +1 4763 tests passed

Test results: http://bigtop01.cloudera.org:8080/job/PreCommit-HIVE-Build/623/testReport
Console output: http://bigtop01.cloudera.org:8080/job/PreCommit-HIVE-Build/623/console

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12618384, Updated to address Harish's comments., 

{color:green}Overall{color}: +1 all checks pass

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12618717/HIVE-5973.2.patch

{color:green}SUCCESS:{color} +1 4785 tests passed

Test results: http://bigtop01.cloudera.org:8080/job/PreCommit-HIVE-Build/637/testReport
Console output: http://bigtop01.cloudera.org:8080/job/PreCommit-HIVE-Build/637/console

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12618717, +1, thanks Vikram]