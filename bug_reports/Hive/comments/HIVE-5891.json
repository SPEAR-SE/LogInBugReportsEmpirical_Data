[[~sunrui] Can you add your test case as .q file in patch. You need to set hive.auto.convert.join=true; to effect map-join in .q tests. Also, I think it may result in lot of update to .q.out files since we may now use different alias than $INTNAME which appears in .q.out files.
Also, [~yhuai] can you take a look to see if this has any affect on Demux Operator. I don't think so, but you ll know better., [~sunrui] What will the plan of the query in the description look like with your patch? Will MapJoins and the Union be executed in the same job? Seems those two tmps appearing in the same position in those MapJoins triggered the bug. I was thinking if ids in those two QBJoinTrees are the same? If so, aliases of those two tables are probably still the same. 0.11 does not have this bug because it does not use a single job to evaluate those MapJoins and the Union.

I do not think it will affect Demux since Demux is at the reducer side.

btw, I also think "$INTNAME" is confusing... Seems it is used to represent those intermediate results. I'd like a name which has a meaningful part which can represent how this intermediate results are generated and a unique part to address the issue shown in this jira., Yin Huai  The following is the explain output for the merged task:
{panel}
  Stage: Stage-4
    Map Reduce
      Alias -> Map Operator Tree:
        null-subquery1:x-subquery1:$INTNAME 
            Map Join Operator
              condition map:
                   Inner Join 0 to 1
              condition expressions:
                0 
                1 {key}
              handleSkewJoin: false
              keys:
                0 [Column[_col0]]
                1 [Column[key]]
              outputColumnNames: _col1
              Position of Big Table: 0
              Select Operator
                expressions:
                      expr: _col1
                      type: int
                outputColumnNames: _col0
                Union
                  Select Operator
                    expressions:
                          expr: _col0
                          type: int
                    outputColumnNames: _col0
                    File Output Operator
                      compressed: false
                      GlobalTableId: 0
                      table:
                          input format: org.apache.hadoop.mapred.TextInputFormat
                          output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
        null-subquery2:x-subquery2:$INTNAME 
            Map Join Operator
              condition map:
                   Inner Join 0 to 1
              condition expressions:
                0 
                1 {key}
              handleSkewJoin: false
              keys:
                0 [Column[_col0]]
                1 [Column[key]]
              outputColumnNames: _col1
              Position of Big Table: 0
              Select Operator
                expressions:
                      expr: _col1
                      type: int
                outputColumnNames: _col0
                Union
                  Select Operator
                    expressions:
                          expr: _col0
                          type: int
                    outputColumnNames: _col0
                    File Output Operator
                      compressed: false
                      GlobalTableId: 0
                      table:
                          input format: org.apache.hadoop.mapred.TextInputFormat
                          output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
      Local Work:
        Map Reduce Local Work
{panel}

As you can see, MapJoins and the Union are to be executed in the same job. The aliases are changed from "$INTNAME" to "null-subquery1:x-subquery1:$INTNAME" and "null-subquery2:x-subquery2:$INTNAME" respectively.

I am thinking maybe we can change the intermediate alias name for a join stream from "$INTNAME" to "$JOIN_INTERMEDIATE". But which better name do you think for the case of DemuxOperator?

Ashutosh Chauhan : I will add the test case as a .q file when we finalize the patch:), Thanks [~sunrui] for confirming the plan. Will "JOIN_INTERMEDIATE" give an impression that the dataset is an intermediate dataset during the processing of join instead of an input dataset?

Also, I am sorry that I did not get your question about DemuxOperator. Why DemuxOperator is related to this issue?  I think Demux is not related to your change since it is an operator at the reducer side. , [~yhuai] Yes, "$JOIN_INTERMEDIATE" is intended to name an intermediate dataset during the processing of join, not for input dataset. Is there anything wrong with my understanding?  "$JOIN_STREAM" is also another candidate maybe.

GenMapRedUtils.java:
{code}
  private static boolean needsTagging(ReduceWork rWork) {
    return rWork != null && (rWork.getReducer().getClass() == JoinOperator.class ||
         rWork.getReducer().getClass() == DemuxOperator.class);
  }

splitTasks():
    if (needsTagging(cplan.getReduceWork())) {
      String origStreamDesc;
      Operator<? extends OperatorDesc> joinOp = cplan.getReduceWork().getReducer();
      QBJoinTree joinTree = parseCtx.getJoinContext().get(joinOp);
      if (joinTree != null) {
        streamDesc = joinTree.getJoinStreamDesc();
      } else {
        streamDesc = "$INTNAME";
      }
{code}

Look at the above piece of code, an alias is also needed when the reduce work starts
with a DemuxOperator. For this case, "$INTNAME" is still un-changed because I have no
idea how DemuxOperator works., I think the main problem is mergeMapJoinTaskIntoItsChildMapRedTask happens in the physical optimization phase which is after we break the plan using GenMapRedUtils. In this case 
{code}
while (cplan.getMapWork().getAliasToWork().get(streamDesc) != null) {
  streamDesc = origStreamDesc.concat(String.valueOf(++pos));
}
{\code}
will not help because those MapJoins were ReduceJoins and they were in different MR jobs. Also, seems the pattern triggers the bug looks like this...
{code}
             Union or Join
             /            \
            /              \
       MapJoin1             MapJoin1
      /       \            /        \
   MR1         small1     MR2        small2
{\code}
In here, MR1 and MR2 are two MapReduce jobs which generates intermediate datasets. small1 and small2 are two small tables. When mergeMapJoinTaskIntoItsChildMapRedTask attaches MapJoin1 and MapJoin2 to the Map phase of the job for Union or Join, MR1 and MR2 has the same alias... Actually, I am thinking using the id of a QB may be a good alias for an intermediate dataset. Thoughts?

I think your change will not affect DemuxOperator because before GenMapRedUtils starts to work, Correlation Optimizer (HIVE-2206) has already generated the optimized plan. But let's give it a try. Can you try this query and see if there is anything wrong?
{code:sql}
set hive.optimize.correlation=true;
SELECT tmp1.key
FROM (SELECT key, value
             FROM src
            GROUP BY a.key, b.value) tmp1
JOIN
           (SELECT key, value
            FROM src
           GROUP BY key, value) tmp2
ON (tmp1.key=tmp2.key)
JOIN
         (SELECT key
          FROM src
          GROUP BY key) tmp3
ON (tmp2.key=tmp3.key)
GROUP BY tmp1.key
{code}
The plan should have three MR jobs. The first one is used to evaluate tmp1. The second is used to evaluate tmp2. And the third one is used to evaluate the join of tmp1, tmp2, and tmp3, and gby.
, [~yhuai] I did try to use the QB id. Something like:
{code}
     streamDesc = parseCtx.getQB().getId() + ":$INTNAME";
{code}
But parseCtx.getQB().getId() returns null. I don't know the reason.

Actually, the id of QB is same as that of QBJoinTree. 
{code}
public class QBJoinTree implements Serializable{
  ...
  // The subquery identifier from QB.
  // It is of the form topSubQuery:innerSubQuery:....:innerMostSubQuery
  private String id;  
{code}
And QBJoinTree has a method getJoinStreamDesc() which is supposed to return the name for the intermediate dataset of the join operation. But this method is not used now. So I tried to use this method in my patch.

I tried your query. There is nothing wrong with it in HIVE 0.12. Below is part of the plan:
{code}
  Stage: Stage-2
    Map Reduce
      Alias -> Map Operator Tree:
        $INTNAME 
            Reduce Output Operator
              key expressions:
                    expr: _col0
                    type: int
              sort order: +
              Map-reduce partition columns:
                    expr: _col0
                    type: int
              tag: 0
              value expressions:
                    expr: _col0
                    type: int
        $INTNAME1 
            Reduce Output Operator
              key expressions:
                    expr: _col0
                    type: int
              sort order: +
              Map-reduce partition columns:
                    expr: _col0
                    type: int
              tag: 1
        tmp3:src 
          TableScan
            alias: src
            Select Operator
              expressions:
                    expr: key
                    type: int
              outputColumnNames: key
              Group By Operator
                bucketGroup: false
                keys:
                      expr: key
                      type: int
                mode: hash
                outputColumnNames: _col0
                Reduce Output Operator
                  key expressions:
                        expr: _col0
                        type: int
                  sort order: +
                  Map-reduce partition columns:
                        expr: _col0
                        type: int
                  tag: 2
      Reduce Operator Tree:
        Demux Operator
          Mux Operator
            Join Operator

{code}, [~yhuai] I think we can leave "$INTNAME" as is for this issue. Do you have any further comments? if no, I can prepare a new patch for review., [~sunrui] Sorry for getting back late.

I just took a look at QB. Seems it uses aliasToSubq to store the mapping from aliases to sub query expressions (QBExpr). Then, a QBExpr also stores a QB which represents the subquery QB. With this recursive way, all QBs for different levels of the query are stored. So, parseCtx.getQB() only gets the main query block and its id is null. I am not sure if we can get the right QB (the QB for a subquery) from GenMapRedUtils.splitTasks... Can you take a quick look to see if it is easy to get the correct QB? If so, we can use the id of a QB to replace INTNAME. If not, let's use joinTree.getId for those JoinOperators. Seems we do not need to take special care to DemuxOperator. Can you create a review request for your patch? I can leave comments on the review board.

Also, since QBJoinTree.getJoinStreamDesc is not used, let's delete it., [~yhuai] Thanks for your comments:)
It seems there is no quick way to get the correct QB for a join operator. However, since QBJoinTree's id is same as it's QB's id, we can just use QBJoinTree's id as QB's id. I found simliar usages in the HIVE code base.

I note that something wrong in my first patch. parseCtx.getJoinContext() is used to map the join operator to its QBJoinTree, but this is not enough. A join operator may be a MapJoin or SMBJoin operator instead of a common join operator, so parseCtx.getMapJoinContext() and parseCtx.getSmbMapJoinContext() should also be checked.

I have another thought. Maybe we can define a method in GenMapRedUtils. On each invokation, this method returns a unique intermediate name. Thus we don't have to use QB's id.

What's your opinion?, i see. yes, seems getMapJoinContext and getSmbMapJoinContext can also have QBJoinTrees. I think it will be good to show meaningful aliases for those intermediate results. So, users can know where does an intermediate result come from. Since it is not easy to get the correct QB.id, I prefer to use QBJoinTree.id right now. Once this bug has been fixed, we can work on a followup jira to get rid of INTNAME. Also, I guess that we do not have an unit test to cover this bug. Can you add an test query in multiMapJoin2.q and comment the reason that we need this test? Thanks., [~yhuai]
I attached a new patch and created review board entry:
https://reviews.apache.org/r/16422/, [~yhuai] This patch does not include modifications to the test output files of other impacted test queries. You can review the code change first. I will submit a new patch later., Thanks [~sunrui]. LGTM. I left two minor comments on the review board., [~yhuai]
I updated the patch per your comments.

I ran a round of ClientPostive test and found that q.out files of many test queries need to modified because "$INTNAME" in the explained plan would be changed to "null:$INTNAME". This is because the QB id for the top query is null. This makes no sense, so I enhanced the logic a little bit: don't use a QB id as prefix for the intermediate name if it is null., 

{color:green}Overall{color}: +1 all checks pass

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12620115/HIVE-5891.3.patch

{color:green}SUCCESS:{color} +1 4811 tests passed

Test results: http://bigtop01.cloudera.org:8080/job/PreCommit-HIVE-Build/738/testReport
Console output: http://bigtop01.cloudera.org:8080/job/PreCommit-HIVE-Build/738/console

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12620115, +1, Committed to trunk. Thanks, Sun!]