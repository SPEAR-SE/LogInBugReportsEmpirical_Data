[In the SQL standard, aliases are allowed to be reused at different levels of query nesting; conflicts are only illegal in the same FROM clause.  This is the same rule as for column names, actually (they can be reused at different levels of the query nesting, but not at the same level).  There are corresponding rules for resolving references when correlated subqueries are used (looking up into the closest scope).

I'm fine with making the rules stricter for Hive, since reusing a table alias is very confusing; just pointing this out.
, Right--this is reported as a bug because Hive is crossing levels. The first use of a.num in the above query should look into the CLOSEST scope, which is the subquery labeled a. What hive is doing here is looking into the NON-CLOSEST scope, and returning foo.num when it should return (subquery).num. That is the bug.

Whether we should allow it at ALL in hive, since it's confusing, is a broader question. I vote either for disallowing it at all, or disallowing it in strict mode., +1 to disallow it in strict mode. Simply disallowing it at all may be too aggressive and cause more confusion. 
I'm pretty sure that ambiguous is caused by predicate push down, we shall work it out rather than avoid it. , OK, I did some testing and verified that

1) this is due to the combination of reused alias and predicate push-down (either turning off ppd or using a different outermost alias fixes the plan)
2) this is a different bug from HIVE-1342 (I tried applying Ted's patch and it did not fix this one)

I'm going to let someone else who really wants it create a separate issue for preventing alias reuse in strict mode; as Ted says, we should fix these two bugs independent of that.
, Actually, after thinking about it some more, it's not practical to prevent alias reuse, even in strict mode.  Here's why.

Suppose I have

CREATE VIEW V AS SELECT * FROM BLAH T1 JOIN FLUB T2 ON T1.J=T2.K;

SELECT * FROM V T1 WHERE T1.X=3;

When we expand the view reference in the query, we'll end up with

SELECT * FROM (
    SELECT * FROM BLAH T1 JOIN FLUB T2 ON T1.J=T2.K
) V T1 WHERE T1.X=3;

And now in the expansion, T1 is legitimately duplicated, even though the person querying the view didn't even know that T1 was used inside the view definition (in general, could be very deep).

Expanding the view in this way is what allows us to do a lot of optimizations such as pushing predicates (e.g. T1.X=3) all the way down into the view. 
, We're fixing the bugs and sticking with the normal SQL rules, which allow duplicate aliases, for the reasons mentioned above.
]