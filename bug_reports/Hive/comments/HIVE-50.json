[Instead of specifying which column will be "special" in the create table statement, we can also specify that at insertion time:

CREATE TABLE tname (cname1 INT)
COMMENT 'This is a table'
PARTITIONED BY(dt STRING, pcol INT)
STORED AS SEQUENCEFILE; 

INSERT OVERWRITE tname PARTITION (dt = '2008-11-04') (pcol, cname1)
SELECT another.a, another.b FROM another;

This conforms to the standard SQL Syntax: http://dev.mysql.com/doc/refman/5.0/en/insert.html


The implementation would involves several steps:
1. Change the grammar to support specifying columns in the insert clause (the default will be all columns except partition columns), and change the plan generation to support that;
2. Allow specifying partition columns in the insert clause, change the execution code to create a new file on each new partition key.
3. Optimization: The bad thing about 2 is that if we have 100 reducers, then each of the partition will have 100 files. We could first generate the result of the select, and then do a count to see the number of rows in each partition, and then decide whether we should do another map-reduce job to gather all rows in the same partition together or not.


Overall this will be a very useful feature.
, This sounds good to me. I guess the PARTITION clause is just a syntax sugar at this point and this could implicitly be achieved by

INSERT OVERWRITE tname(dt, pcol, cname)
SELECT '2008-11-04', another.a, another.b FROM another;

We could always infer from this that a constant value is being put in the partition col dt and generate any optimizations that could be done for the PARTITION clause.

, Rather than having two places to define columns, it seems like it would be nicer to specify all columns once and then reference them in the partitioned by clause.

Ex:

CREATE TABLE events ( year int, month int, day int, event_type int, user_id int ) PARTITIONED BY ( year, month, day );

One of the side effects of this is that the column output order is defined solely by the actual column definition. As of 0.4.1, partitioned columns are always after "normal" columns which is annoying for cases where you want to expect query output to match the source files on which the query was run in terms of layout without having to have some explicit external ordering knowledge. In other words, partitioned columns should only be special to the query parser / optimizer and directory structures. Today, partitioning creates a requirement on the field ordering in files which violates the notion that there is no Hive file format and means reformatting files needlessly to partition them. Partitioned columns should be able to appear anywhere in the file layout.]