[The problem stems from DefaultExprProcessor:process(). During the AST walk, any error is cleared if a node matches a group by expression

{code}
...
      exprNodeDesc desc = TypeCheckProcFactory.processGByExpr(nd, procCtx);
      if (desc != null) {
        ctx.setError(null);
        return desc;
      }
{code}

Clearing the error was probably an attempt to address the generation of false errors during the DFS walk of the AST. Consider the AST fragment from the query

{code}
SELECT concat(src.key) FROM src GROUP BY concat(src.key)

        TOK_FUNCTION
            / \
           /   \
          /     \
     concat      .
                / \ 
               /   \
TOK_TABLE_OR_COL    key
         |
         |
        src
{code}

During the walk, process() will be called on src before TOK_FUNCTION. Because src is not a group by expression, an error will be set in ctx. However, when process() is called on TOK_FUNCTION, it matches the group by expression 'concat(src.key)' and the error is cleared, producing the expected behavior.

A problem arises with a query like

{code}
select concat(value, concat(value)) from src group by concat(value)
{code}

as the AST is such that 'value' (1st argument of outer concat) is processed before 'concat(value)'. When process() acts on 'value', it sets an error because it is not a group by expression. But then the error is cleared when process() is called on 'concat(value)'. The error should not really be cleared as it was generated outside of the group by expression.

The proposed solution is to keep track of the ASTNode that generated the error and only clear the error when it was generated from a node within the group by expression., The explanation looks good to me, but I am not convinced the solution will solve the problem.

When processing "concat(value, concat(value))". we will set "error" when processing the first "value", then overwrite the "error" when processing the second "value", correct?
I think the "error" should be part of the "return value" of the "process" function, instead of a global field in the "context".

Does that make sense?
, From an offline conversation - the solution still works for cases like "concat(value, concat(value))" because the error is only set with the first "value" - node processors terminate early when the global error is set. 

* Added better comments., Committed. Thanks Paul!]