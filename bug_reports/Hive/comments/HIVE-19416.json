[Deferring this to next release. Please mark this as blocker if you would like to get this in 3.0 branch., The current single version stats has:
1. Definitions and Categories
  - Valid transactional stats: 
    I.e., a conjunction of the three:
    ~ a committed transaction created the stats 
    ~ COLUMN_STATE_ACCURATE(CSA) state is true
    ~ Isolation-level (snapshot) compliant
  - Two kinds of stats: table and column 
  - COLUMN_STATS_ACCURATE(CSA) states for a table/partition: true or false.
     one for table, one per each column
  - Categories of clients: 
    ~ Stats reader: 
      ^ StatsOptimizer for aggregation query: transactional stats reader
      ^ The rest that uses stats for cost computation inputs: non-transactional stats reader
    ~ Stats updater: transactional stats updater

2. Transactional Stats Operations
  2.1 Stats Update
    Update the single version stats, both table and column and save a table snapshot to UPD_TXNS.
    - A client requests an update with stats and a table snapshot [1].
    - creates a TBLS/PARTITIONS row adding a row into UPD_TXNS row with table write snapshot.
      ~ Updates "table stats" by updading TABLE_PARAMS/PARTITION_PARAMS
    - Updates "column stats" by updating TAB_COL_STATS/PART_COL_STATS
    - commit/abort
      ~ abortTcn() deletes the UPD_TXN row for the transaction.

    Note: now stats reader determines the state of the transactional stats' updater transaction
      by checking TXNS for open state, and checking existence of a row in UPD_TXNS for committed/aborted.

  2.2 Stats Read
    StatsOptimizer determines validity of the MetaStore transactional stats 
    to use stats for an aggregation query.
    2.2.1 Table stats
      The reader gets a TBLS/PARTITIONS row that includes table stats. 
      Then check the validity of the table stats.
      - A client comes in with its request that includes the client's table snapshot. 
      - Reads a row from TBLS/PARTITIONS.
      - Check if the CSA for table stats is true. If not, return after setting CSA.
      - Check if stats' update transaction is committed: check if a row exists from UPD_TXNS 
        for the TXN_ID from TBLS/PARTITIONS. If not, invalid.
      - compare the current stats' table snapshot with the client's table snapshot  
      - if the table snapshots are  equal in commits, 
        table stats are valid.
    2.2.2 Column stats
      The reader gets a row from TAB_COL_STATS/PART_COL_STATS.
      The same steps as table stats.

3. Current/Possible invariants
  3.1 Current
    - Metastore TBLS/PARTITIONS keeps CSA updated for committed stats for both table and columns.
  3.2 Possible 
    - Metastore keeps one committed stats for both table and columns.

Notes:
[1]: transaction id and a valid writeId list for the table., 1. MetaStore Schema Changes for the patch 04 of HIVE-19417
1.1 New table UPD_TXNS
   A record is created per transaction write per table.

   UPDATE_ID: primary key column, generated by Datanucleus when 
      specified at "package.jdo" as datastore-identity . 
   TBL_ID: TBLS.TBL_ID referencing column. A foreign key is created for 
      this column referencing TBLS.TBL_ID.
   STATE: this is deleted for the next patch version.
   TXN_ID: Transaction id of the transaction to insert the row.
   WRITEID_LIST: valid writeIdList for the table of the transaction

1.2 Modification for TBLS and PARTITIONS tables

    A new column TXN_ID: transaction id of the UPD_TXNS., Hi [~ashutoshc], [~sershe], [~ekoifman] I have added a small description for this jira. 
Thanks, 
Steve. , Can you put this into code comments? Overall [~ekoifman] can review this based on his last comment., Ok Sounds good., Based on the talk with Ashutosh Chauhan, Sergey Shelukhin, Eugene Koifman, and I.
1. I will check and implement concurrent insert case detection and resolution based on txn_id (first version shall
  make the CSA state false, the next version may make the case  have the CSA state true). 
2. Hive aborted transaction case should turn the CSA state false.
3. I will explore (and implement if it  does not cause any issue) the possibility of using CSA state at TBLS/PARTITIONS 
  instead of keeping UPD_TXNS, which will simplify implementation. The basis of this is the invariant item that 
  Metastore TBLS/PARTITIONS keeps CSA updated for transactional stats in Metastore for both table and its columns., Looking at the patch now, not done reviewing yet, I post the comments in increments.
My main concern for now is that I don't quite understand why we need two mechanisms: first, some alter/add queries remove COLUMN_STATS_ACCURATE on write (we also invalidate it in the response on read but that seems to be just the communication mechanism), and then in is...Valid... method on read we check that parameter. However, in the is...Valid... method, we also check txns/validIdlists.
Shouldn't just the latter be enough, with no need for the former?
Using parameter as a communication mechanism from metastore to avoid massive QL changes looks good to me.

Also there are many TODOs in the patch. I would be nice to clean them up - fix simple ones, remove unnecessary ones if any, and make complex ones into work items.
, Another concern is that the code that gets the snapshot looks like it may affect locks/etc (LockException was added) or get write Ids outside where they are normally retrieved (in stats optimizer). 
I think optimizer runs before the locks are obtained, so this can lead to deadlocks if locks are obtained piecemeal, and also to some consistency issues I assume. It's not clear what to do to get correct/incorrect stats info for it, without the locks. Maybe locks would have to be moved before the optimizer. cc [~ekoifman] , Thank you Sergey for your comments. I really appreciate those. 

1. I will add an "API spec" shortly to be clear or to be specific on reader/updater. 
  But in short, 
  1.1 updater with alter... API method checks and remove COLUMN_STATS_ACCURATE(CSA) for the table or partition
    from the metastore. This is a global operation or metastore-wise persistent operation. 
    One case is concurrent insert case.
  1.2 reader checks whether the currently existing stats are snapshot-isolation-level-compliant with the calling query and sets
    CSA for the return object. Note that this is query by query return object. Since the reader side check is per-query.
2. I will clear TODOs.
3. Regarding taking snapshot info
  3.1. I think the Hive code is in the process of being changed to acquire locks at the beginning of query optimization of a query before 
    taking a database snapshot. So if we are depending on locks for logical consistency of Metadata objects, then we may have an issue.
  3.2 Just FYI. 
    The concerned table-write-id-list getting locations in StatsOptimizer is only used by a reader (not writer of a table/partition) so we don't 
    have the case where the current query is to increment write id of its target tables. I.e., a global database snapshot is already taken 
    before starting optimization and the code changes for this jira in StatsOptimizer is getting the info from the Metastore which is supposed to
    guarantee Committed Read isolation there in the Metastore DBMS access.
, Wouldn't 1.1 case be also detected by 1.2, assuming these two checks/alterations of tables are safe for races? I guess one case could be when table data is affected without creating a txn, so txn state cannot be recorded... however, if such changes exist (I'm not sure they do) how are they protected from races? is it by ACID locks? Just checking.
If my assumptions are correct (alter doesn't create txn/writeId but is safe due to locks), it might be cleaner for txn tables to not have the parameter stored, but instead just unset the txnId/writeIds data. If it's unset it will never match any query, which is the intention. The parameter can just be generated at read time, and not exist in DB.
3.1-2 I don't think anybody's working on that. If stats optimizer gets write IDs but then some in-flight txn commits before Driver gets locks and writeIds, it could mean stats optimizer picks different data than the actual query would pick. So that is a problem., Btw, a query like create table foo as select count(*) from bar will perform writes based on txn state, and can be executed as stats-only, so it's also relevant for writes., c/p:

Permalink Edit Delete
sershe Sergey Shelukhin added a comment - 3 hours ago - edited
I've committed the 03 patch to master-txnstats branch for now.
I will keep the JIRA open to 
1) Run the tests.
2) Address the feedback on 03 patch.

Please do all future work for transactional stats ON TOP OF master-txnstats branch, in separate patches. 
The epic patch to run the tests here should be made by diffing master with master-txnstats. 
I will periodically merge master to make sure it stays up to date; one can also merge locally just to produce a patch for tests.
Given that the branch was just created, the 03 patch is good for now for a test run.

The fix version for commits to the branch should be txnstats. We will bulk change it to 4.0/3.1 when we merge the branch.

I'm going to clean up existing jiras and file smaller scope items.
cc Steve Yeom Eugene Koifman Gunther Hagleitner

Permalink Edit Delete
sershe Sergey Shelukhin added a comment - 3 hours ago
Steve Yeom 
Can you update RB with 03 patch? Just to finish the review and perhaps file some more follow up jiras.

Also can you make a list of things that are missing? There are some JIRAs remaining as subtasks, I'm not sure if they are addressed as part of the epic patch or not. I filed some known issue JIRAs, let me know if there's more.
Or is it just enough to fix the tests and it's good?


Update: apparently 03 patch is not good, we will create the branch again later based on the 04-patch to come. The rest will remain the same., RE: lock acquisition.  The lock manager doesn't have an y deadlock detection logic in it.  It works by acquiring all locks for a given txn in 1 atomic operation.  So if locks are acquired piece meal, it can lead to deadlock., [~steveyeom2017] [~sershe] Is there a design document or some kind of documentation for this? Interesting in knowing what this feature entails and how it works., [~vgarg] design is code ;)
Let me try to add release notes. We can write something up that is larger than this, not sure if it's worth it., Updated the description]