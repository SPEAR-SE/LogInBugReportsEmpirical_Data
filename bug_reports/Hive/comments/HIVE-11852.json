[The issue here is that there is a MoveTask that's done as part of the import process which issues an alter_table which nukes the stats that were just created. On digging further, I discovered a couple of other cases that would result in the same stats squishing behaviour.

Patch attached to fix them, and a .q file to test them., 

{color:red}Overall{color}: -1 at least one tests failed

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12756376/HIVE-11852.patch

{color:red}ERROR:{color} -1 due to 1 failed/errored test(s), 9450 tests executed
*Failed tests:*
{noformat}
org.apache.hive.hcatalog.api.TestHCatClient.testTableSchemaPropagation
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/5318/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/5318/console
Test logs: http://ec2-174-129-184-35.compute-1.amazonaws.com/logs/PreCommit-HIVE-TRUNK-Build-5318/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 1 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12756376 - PreCommit-HIVE-TRUNK-Build, [~alangates], can I bug you for a review? (Most of the patch file size is the .q and the .out, I promise this time it's not a huge patch dump. :D ), I wonder instead of communicating via a config property during execution time, better approach might be to save this info (to not nuke stats) in alter_table work at query compile time and use that to not nuke stats., Further testing from Falcon shows that this fix is not enough, and misses some other case of stats being squished, canceling patch., [~ashutoshc], the problem with a config property here is that this stats squish I'm trying to prevent does not happen on the ql-side. This happens on the metastore, from the AlterTableHandler where an alter table gets issued from the client side. The metastore then decides that since the table has been altered, the table is now different, and thus, stats must be nuked.

I feel like if the decision to nuke the stats were not made by the metastore, but by the ql-side, that is cleaner and would not result in this problem, but then if stats squishing and table altering were two different metastore calls, we run into issues where one succeeding and the other not would lead to incorrect data elsewhere, apart from other performance implications as well.]