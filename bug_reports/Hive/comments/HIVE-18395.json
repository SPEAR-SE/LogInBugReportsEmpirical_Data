[I talked with Ashutosh Chauhan. 
We turned off using stats on ACID/MM since the operations to insert onto a ACID/MM table 
and to update the Metastore metadata on the table regarding stats are not in a single transaction. 
I.e., there could be a case where inserts on MM/ACID are successful but updating 
stats on the table in the Metastore are unsuccessful.

Probably to make the set of operations (insert and Metastore metadata update) transactional will fix the issue.  , Another viewpoint/reason why not using stats on a ACID/MM table is that 
a reader/select statement can not have a snapshot isolation regarding "actual data" and "stats on the Metastore". 
Since update on the data and the stats on the Metastore is not single transaction based and
also there is no mechanism to get consistent snapshot isolation view on stats regarding the 
actual data. , The above two comments indicate the following two use case scenarios for a reader statement:

1. Table data directory has newest transaction id(xid), let's say, 10, but the Metastore has stats with lastest xid 9 (if we keep last xid for a table).
  This indicates the corresponding Metastore side transaction to update stats to the data transaction of 10 failed. In this case, COLUMN_STATUS_ACCURATE 
  may be false. In this case, the compiler can choose an aggregate execution plan (not a plan to use stats on the Metastore).
2. A reader statement started and verified that both data directory and Metastore stats have xid, for example, 20 as the latest xid during compilation.
  But when it starts execution and acquires SLock on the Metastore stats, it finds the latest xid is 22. This indicates there was a new committed transaction 22 which 
  updated the stats. In this case, the reader should not use stats to keep the default snapshot isolation level on acid/MM table but execute an aggregate execution plan unless Metastore DBMS supports MVCC or snapshot isolation.
  Possibly recompilation., Talked with Ashutosh. 
1. The current system regarding stats gathering and using
  - The system updates Metastore stats only for insert statements for non-acid tables (keep in mind that only insert is supported for 
    non-acid tables).
  - Per table COLUMN_STATS_ACCURATE key and its value pair and other table stats are from TABLE_PARAMS table in the Metastore. 
    A updater/inserter sets to false this flag when its corresponding StatsTask fails. 
    Subsequent reader statement uses this flag value to determine whether to use stats for an aggregate statement.

    Note that a precondition for this flag to work is that any table data and its metadata updater operation should use this flag.
   , Currently aggregate queries like "SELECT MAX.." is using MetaStore stats when appropriate for non-ACID/non-MM tables. 
If used for aggregate queries, then it should be accurate. 

If used for an ACID or MM table, then snapshot isolation should be guaranteed since it is a regular SQL query., Hey [~sershe] I uploaded my current preview patch. 
It is not rebased to the master., The preview version "HIVE-18395.01.preview" works for a main success flow for executing
"select COUNT(*) and COUNT(col-name)" using table and column stats only
with hive.stats.autogether=true and hive.stats.column.autogather=true
for non-partitioned tables. But internally in metastore updating non-partitioned table stats is 
the same as single-partitioned table.
, Some small comments:
1) Seems to include some generated config in the patch.
2) TABLE_PARAMS_TXN - can we normalize this and not rely on JSON object? Since this will only be used for stats I assume, and stats only have one parameter (JSON string), we can store it as proper SQL data
[~ekoifman] you might want to look at the new tables schema since it's based on what ACID state is sufficient to map stats to a snapshot.
3) {noformat}
+      if (SessionState.get().getTxnMgr() != null && isTransactional) {
+        request.setTxnid(SessionState.get().getTxnMgr().getCurrentTxnId());
+      }
{noformat}
Is it enough to store transaction ID? Transaction ID will invalidate stats for every other table with every transaction, right? At least it should be writeId.
Also the doc calls for storing entire state information about when the stats were written - otherwise you cannot tell based on read-time snapshot if the stats are valid, for example in case of two inserts, where both can write stats, but both stats are invalid because the inserts don't see each other. 
4) {noformat}
+        /*
         if (isFullAcid && !work.isTargetRewritten()) {
           // Don't bother with aggregation in this case, it will probably be invalid.
           parameters.remove(statType);
           continue;
         }
+        */
{noformat}
Aggregation for full ACID will still be invalid.
5) This doesn't seem to affect basic stats in all the places they are updated. However, basic stats are also used for count(*) type queries (numRows). 
I sent a patch separately that has some changes for basic stats... Might make sense to also modify these places in this patch. Doesn't have to be the same change I made as long as it is sufficient to add txn info to basic stats.

It might help to exclude the generated code for review. I sometimes use the script like this, where $1 is base branch and $2 is file name:
{noformat}
rm -f  ~/patches/$2.nogen.patch
for f in `git diff $1 --name-only | grep -v "gen-" | grep -v "\/gen\/"`
do
  git diff $1 -- $f >> ~/patches/$2.nogen.patch
{noformat}, Again the patch is not yet to be reviewed. 

Items 2, 3 are already in my list to do
[~sershe] do you think you can explain a little further on item#4?, In summary, 
the comments from Sergey will be applied to the Design google doc soon 
if not yet added.

Also I have created a jira about the issue Sergey mentioned at 4). ]