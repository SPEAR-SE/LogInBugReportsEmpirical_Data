[@Chris: Can you update the JIRA with the change in behavior? In the case of this particular test, Hive deviates from the SQL standard and outputs an empty result set instead of a NULL result set when an aggregate function is run on an empty table/partition. I believe MR2 generates splits even though the input directory in empty and Hive in turn outputs an empty result set. The behavior on MR1 used to be the same as MR2, until a recent change that went into HDFS. It would really help to see the failure you are seeing on hadoop23., @Shreepadma: I had traced the code a while back and found that Hive was creating an empty file for these types of queries. Hadoop20 didn't care that the file was empty and would create a split, which would get a mapper. With Hadoop23 I noticed that there is a condition which checks to see whether the file is empty or not. If it is empty it doesn't create a split and hence doesn't get a mapper. In this way Hive could trick Hadoop20 into running an MR job, but this tactic doesn't work on Hadoop23. I don't remember the classes off-hand.

Here is the diff of the generated vs expected output. If I remember correctly, when no splits are generated it returns NULL.

Line 84: select max(ds) from TEST1; (no partitions exist)
Line 211: alter table TEST1 add partition (ds='1'); select max(ds) from TEST1;
Line 337: select count(distinct ds) from TEST1;
Line 1080: alter table TEST2 add partition (ds='1', hr='1'); alter table TEST2 add partition (ds='1', hr='2'); alter table TEST2 add partition (ds='1', hr='3'); select ds, count(distinct hr) from TEST2 group by ds;
Line 1453: alter table TEST1 add partition (ds='2'); select max(ds) from TEST1;

    [junit] diff -a /export/crawlspace/cdrome/workspace/hive/build/ql/test/logs/clientpositive/metadataonly1.q.out /export/crawlspace/cdrome/workspace/hive/ql/src/test/results/clientpositive/metadataonly1.q.out
    [junit] 84c84
    [junit] < NULL
    [junit] ---
    [junit] > 
    [junit] 211c211
    [junit] < NULL
    [junit] ---
    [junit] > 1
    [junit] 337c337
    [junit] < 0
    [junit] ---
    [junit] > 1
    [junit] 1080a1081
    [junit] > 1 3
    [junit] 1453c1454
    [junit] < NULL
    [junit] ---
    [junit] > 2, Yes, thats correct. When no splits are generated Hive takes a different code path and a NULL is emitted from the closeOp() of the groupByOperator. I originally noticed this problem with hadoop20 after HDFS-3672 was committed. I believe MAPREDUCE-4470 fixes the behavior on hadoop23 i.e., hadoop23 generates 1 split even when the directory is empty. I checked the behavior on hadoop20 and hadoop23 a month or so back and behavior seemed consistent with the empty result set. However, NULL is the correct behavior as per the SQL standard. Do you see this difference in behavior on the latest trunk? Thanks., HIVE-2955 started writing dummy value for empty file preventing being removed at CombineHiveInputFormatter. Could you try run test with the patch?

And.. First one (at line 84) should be null, IMHO. It could be a different issue., Following is the failure with branch 10 and Hadoop 0.23.5.

..
    [junit] 84c84
    [junit] < NULL
    [junit] ---
    [junit] > 
..

The same does not happen when this test case is run with Hadoop 2.0.0-alpha or 2.0.2-alpha. Looks like MAPREDUCE-3952 and MAPREDUCE-4470 are responsible. After building Hadoop 0.23.5 with MAPREDUCE-3952 and MAPREDUCE-4470 and using it, this patch succeeds. (MAPREDUCE-3952 was raised due to HIVE-2783)., Shall this be closed as Cannot Reproduce? Since we run with 2.0.0-alpha and latest builds also doesn't report this failure. https://builds.apache.org/job/Hive-trunk-hadoop2/lastCompletedBuild/testReport/, [~ashutoshc]: Can we keep this open until I can get approval from my manager that it is a non-issue when we move to 2.0. Currently we are still building on 0.23, so it is an issue for us.]