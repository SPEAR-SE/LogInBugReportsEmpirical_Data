[I've seen the same issue when I was trying to delete table with ~30.000 partitions, looks like it fails by timeout during getting information about partitions. , I notice a similar issue when I try to drop a table with about 50000 partitions.

Essentially, what seems to be happening with that flow is the following:

a) Deleting a table requires deleting all partition objects for that table, Table->Partition is a 1:many mapping
b) Deleting the partition objects requires deleting a all SD objects associated with the partitions, Partition->SD is a 1:1 mapping
c) Deleting SD objects requires looking for all CDs pointed to by the SDs, and wherever a CD has no more SDs pointing to it, we need to drop the CD in question, SD->CD is a many:1 mapping.
d) If a CD is to be deleted, we need to drop all List<MFieldSchema> associated with it (COLUMNS_V2 where CD_ID in list of CDs to delete.)

The big inefficiency here is that SD->CD is a many:1 mapping with a goal of reusing CDs for efficiency, but in practice, we don't. But the fact that it is many:1, not 1:1, means we need to do that additional check before dropping rather than simply dropping. This combination hits us in the worst way possible for both of those.

We need to rethink the way we use our objects and either drop the many:1 intent or actually make sure that we create a unique CD for every SD, or this is not going to be scalable. Other solutions that bypass this wonky model may also exist that we have to work out.]