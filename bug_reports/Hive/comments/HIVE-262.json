[forgot to update parse result files, Does this happen to only 2 consecutive joins with the same set of the keys?
, I marked this a s a Blocker, to indicate that this should definiotely go into the 0.20 branch., Does this happen to only 2 consecutive joins with the same set of the keys?  ----> YES, Ashish suggested the following approach:

Based on join conditions, create a set of all tables being joined (no outer join), and if one of them is null for a given value, all of them become null.

For example,

A join B on A.c1=B.c1 join C on A.c1=C.c1 right outer join D on A.c1=D.c1

A,B,C belong to the same group (since A joins with B and A joins with C).

So, for a given key (c1), if there is no row corresponding to either of A, B, or C - assume that
there is no row for all of them for that key.

That works for the example above, and the approach is different from the patch, However, the above does not work for the following:


A left outer join B on A.c1=B.c1 right outer join C on B.c1=C.c1

Consider the following rows for a given value of c1:

A --> a1 a2
B -> null
C -> c1 c2

Since there is no join, no pruning will happen, and the following output will be produced

null null c1
null null c1
null null c2
null null c2

whereas the correct output is:

null null c1
null null c2

Note that 2 extra rows will be produced.

So, I think the patch's approach should be better, need to add more tests, can you add explain plans for the new test cases. Otherwise this looks good., added explains to test, +1

looks good to me.

I am running the tests right now and will commit once they pass.
, committed. Thanks Namit!!]