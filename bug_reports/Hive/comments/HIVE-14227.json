[I spent some time understanding the issue. Seems the problem comes from disconnection between connection and session. For beeline client, we are creating a connection and then open a session on top of it. Then we close session and destroy the connection. That's fine. While if a connection (connection2) is created and we make calls with an existing session, that's legal. But if the other connection (connection1) in which session is opened gets destroyed, the session gets destroyed as well and we will see invalid sessionHandle from connection2.  Hope my understanding is correct. 

I'm thinking of the following approach: similar to a call openSession(), we can add a call bindSession(sessionHandle) for a new connection with an existing session handle. Then each connection will be aware of the session and the following calls can be called without sessionHandle. Also the session will remember associated connections with it and session can be really closed when there is no connections., Of course, seems solving the backward compatibility will be a little challenging. , + [~szehon] who had worked on that before. +[~romainr] from thrift client (HUE) perspective.

From what I understand to thrift client making hiveserver2 call: after opening a session and creating multiple connections, we are passing the same session over the connections. The issue is, the connection doesn't bind to one session so theoretically, the connection can use any session to make the call, thus, session can't be aware of the connections and the disconnected connection has to choose leaving the session open (causing the possible leak) or kill the session (cause invalid session handle from another connection).

I'm working/evaluating on this binding approach and feel it's promising. The hard part is to keep backward compatible. Want to hear more ideas on that.

The new workflow would be:

openConnection =>openSession/bindSession =>  make calls without sessionHandle => closeSession => closeConnection. 

closeSession will actually do unbindSession or closeSession if no active connections. If somehow closeSession is not called, closeConnection will do such work so it won't be any leaking.

 



, I admit i never thought in depth of a use-case about a connection binding to an existing session instead of a new one as I was just using beeline before, but it might be useful for client like Hue.

There was some discussion about this in HIVE-11485, and there was some fix in HIVE-13415, just in case you went aware.

I think [~cwsteinbach] might be able to offer some good inputs on this proposal.  He also mentioned in the previous discussion that session should be orthogonal to connection and support things like 'session migration', which I guess is being proposed here?
, Thanks [~szehon]. Not sure what you mean "session migration". What I'm proposing is to bind the session with the connection so the session knows how many connections associated with it. 

Attached patch-1: initial patch for the proposal. , 

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12819724/HIVE-14227.1.patch

{color:red}ERROR:{color} -1 due to no test(s) being added or modified.

{color:red}ERROR:{color} -1 due to 105 failed/errored test(s), 10156 tests executed
*Failed tests:*
{noformat}
TestMsgBusConnection - did not produce a TEST-*.xml file
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_acid_globallimit
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_list_bucket_dml_13
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_stats_list_bucket
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_subquery_multiinsert
org.apache.hadoop.hive.cli.TestMiniTezCliDriver.testCliDriver_acid_globallimit
org.apache.hadoop.hive.llap.daemon.impl.TestLlapTokenChecker.testCheckPermissions
org.apache.hadoop.hive.llap.daemon.impl.TestLlapTokenChecker.testGetToken
org.apache.hadoop.hive.metastore.TestMetaStoreMetrics.testConnections
org.apache.hadoop.hive.metastore.TestPartitionNameWhitelistValidation.testAppendPartitionWithValidCharacters
org.apache.hive.beeline.TestBeeLineWithArgs.org.apache.hive.beeline.TestBeeLineWithArgs
org.apache.hive.beeline.cli.TestHiveCli.testCmd
org.apache.hive.beeline.cli.TestHiveCli.testDatabaseOptions
org.apache.hive.beeline.cli.TestHiveCli.testErrOutput
org.apache.hive.beeline.cli.TestHiveCli.testHelp
org.apache.hive.beeline.cli.TestHiveCli.testInValidCmd
org.apache.hive.beeline.cli.TestHiveCli.testInvalidDatabaseOptions
org.apache.hive.beeline.cli.TestHiveCli.testInvalidOptions
org.apache.hive.beeline.cli.TestHiveCli.testInvalidOptions2
org.apache.hive.beeline.cli.TestHiveCli.testNoErrorDB
org.apache.hive.beeline.cli.TestHiveCli.testSetHeaderValue
org.apache.hive.beeline.cli.TestHiveCli.testSetPromptValue
org.apache.hive.beeline.cli.TestHiveCli.testSourceCmd
org.apache.hive.beeline.cli.TestHiveCli.testSourceCmd2
org.apache.hive.beeline.cli.TestHiveCli.testSourceCmd3
org.apache.hive.beeline.cli.TestHiveCli.testSqlFromCmd
org.apache.hive.beeline.cli.TestHiveCli.testSqlFromCmdWithDBName
org.apache.hive.beeline.cli.TestHiveCli.testUseCurrentDB1
org.apache.hive.beeline.cli.TestHiveCli.testUseCurrentDB2
org.apache.hive.beeline.cli.TestHiveCli.testUseCurrentDB3
org.apache.hive.beeline.cli.TestHiveCli.testUseInvalidDB
org.apache.hive.beeline.cli.TestHiveCli.testVariables
org.apache.hive.beeline.cli.TestHiveCli.testVariablesForSource
org.apache.hive.hcatalog.hbase.TestPigHBaseStorageHandler.org.apache.hive.hcatalog.hbase.TestPigHBaseStorageHandler
org.apache.hive.jdbc.TestJdbcDriver2.org.apache.hive.jdbc.TestJdbcDriver2
org.apache.hive.jdbc.TestJdbcWithLocalClusterSpark.org.apache.hive.jdbc.TestJdbcWithLocalClusterSpark
org.apache.hive.jdbc.TestJdbcWithMiniHA.org.apache.hive.jdbc.TestJdbcWithMiniHA
org.apache.hive.jdbc.TestJdbcWithMiniHS2.org.apache.hive.jdbc.TestJdbcWithMiniHS2
org.apache.hive.jdbc.TestJdbcWithMiniLlap.org.apache.hive.jdbc.TestJdbcWithMiniLlap
org.apache.hive.jdbc.TestJdbcWithMiniMr.org.apache.hive.jdbc.TestJdbcWithMiniMr
org.apache.hive.jdbc.TestMultiSessionsHS2WithLocalClusterSpark.org.apache.hive.jdbc.TestMultiSessionsHS2WithLocalClusterSpark
org.apache.hive.jdbc.TestNoSaslAuth.org.apache.hive.jdbc.TestNoSaslAuth
org.apache.hive.jdbc.TestSSL.testConnectionMismatch
org.apache.hive.jdbc.TestSSL.testConnectionWrongCertCN
org.apache.hive.jdbc.TestSSL.testInvalidConfig
org.apache.hive.jdbc.TestSSL.testSSLConnectionWithProperty
org.apache.hive.jdbc.TestSSL.testSSLConnectionWithURL
org.apache.hive.jdbc.TestSSL.testSSLFetch
org.apache.hive.jdbc.TestSSL.testSSLFetchHttp
org.apache.hive.jdbc.TestSchedulerQueue.testFairSchedulerPrimaryQueueMapping
org.apache.hive.jdbc.TestSchedulerQueue.testFairSchedulerQueueMapping
org.apache.hive.jdbc.TestSchedulerQueue.testFairSchedulerSecondaryQueueMapping
org.apache.hive.jdbc.TestSchedulerQueue.testQueueMappingCheckDisabled
org.apache.hive.jdbc.TestServiceDiscoveryWithMiniHS2.testConnectionWithConfigsPublished
org.apache.hive.jdbc.TestServiceDiscoveryWithMiniHS2.testConnectionWithoutConfigsPublished
org.apache.hive.jdbc.TestXSRFFilter.testFilterDisabledNoInjection
org.apache.hive.jdbc.TestXSRFFilter.testFilterDisabledWithInjection
org.apache.hive.jdbc.TestXSRFFilter.testFilterEnabledNoInjection
org.apache.hive.jdbc.TestXSRFFilter.testFilterEnabledWithInjection
org.apache.hive.jdbc.authorization.TestHS2AuthzContext.org.apache.hive.jdbc.authorization.TestHS2AuthzContext
org.apache.hive.jdbc.authorization.TestHS2AuthzSessionContext.org.apache.hive.jdbc.authorization.TestHS2AuthzSessionContext
org.apache.hive.jdbc.authorization.TestJdbcMetadataApiAuth.org.apache.hive.jdbc.authorization.TestJdbcMetadataApiAuth
org.apache.hive.jdbc.authorization.TestJdbcWithSQLAuthUDFBlacklist.testBlackListedUdfUsage
org.apache.hive.jdbc.authorization.TestJdbcWithSQLAuthorization.org.apache.hive.jdbc.authorization.TestJdbcWithSQLAuthorization
org.apache.hive.jdbc.miniHS2.TestHiveServer2.org.apache.hive.jdbc.miniHS2.TestHiveServer2
org.apache.hive.jdbc.miniHS2.TestHiveServer2SessionTimeout.testConnection
org.apache.hive.jdbc.miniHS2.TestHs2Metrics.org.apache.hive.jdbc.miniHS2.TestHs2Metrics
org.apache.hive.jdbc.miniHS2.TestMiniHS2.testConfInSession
org.apache.hive.minikdc.TestHs2HooksWithMiniKdc.org.apache.hive.minikdc.TestHs2HooksWithMiniKdc
org.apache.hive.minikdc.TestJdbcNonKrbSASLWithMiniKdc.org.apache.hive.minikdc.TestJdbcNonKrbSASLWithMiniKdc
org.apache.hive.minikdc.TestJdbcWithDBTokenStore.org.apache.hive.minikdc.TestJdbcWithDBTokenStore
org.apache.hive.minikdc.TestJdbcWithMiniKdc.org.apache.hive.minikdc.TestJdbcWithMiniKdc
org.apache.hive.minikdc.TestJdbcWithMiniKdcCookie.org.apache.hive.minikdc.TestJdbcWithMiniKdcCookie
org.apache.hive.minikdc.TestJdbcWithMiniKdcSQLAuthBinary.org.apache.hive.minikdc.TestJdbcWithMiniKdcSQLAuthBinary
org.apache.hive.minikdc.TestJdbcWithMiniKdcSQLAuthHttp.org.apache.hive.minikdc.TestJdbcWithMiniKdcSQLAuthHttp
org.apache.hive.service.TestHS2ImpersonationWithRemoteMS.org.apache.hive.service.TestHS2ImpersonationWithRemoteMS
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testConfOverlay
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testExecuteStatement
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testExecuteStatementAsync
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testExecuteStatementParallel
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testGetFunctions
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testGetInfo
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testGlobalCompileLockTimeout
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testOpenSession
org.apache.hive.service.cli.TestEmbeddedThriftBinaryCLIService.testTaskStatus
org.apache.hive.service.cli.TestRetryingThriftCLIServiceClient.testSessionLifeAfterTransportClose
org.apache.hive.service.cli.operation.TestOperationLoggingAPIWithMr.org.apache.hive.service.cli.operation.TestOperationLoggingAPIWithMr
org.apache.hive.service.cli.operation.TestOperationLoggingAPIWithTez.org.apache.hive.service.cli.operation.TestOperationLoggingAPIWithTez
org.apache.hive.service.cli.operation.TestOperationLoggingLayout.org.apache.hive.service.cli.operation.TestOperationLoggingLayout
org.apache.hive.service.cli.session.TestSessionCleanup.testTempSessionFileCleanup
org.apache.hive.service.cli.session.TestSessionGlobalInitFile.testSessionGlobalInitDir
org.apache.hive.service.cli.session.TestSessionGlobalInitFile.testSessionGlobalInitFile
org.apache.hive.service.cli.session.TestSessionGlobalInitFile.testSessionGlobalInitFileAndConfOverlay
org.apache.hive.service.cli.session.TestSessionGlobalInitFile.testSessionGlobalInitFileWithUser
org.apache.hive.service.cli.session.TestSessionHooks.testProxyUser
org.apache.hive.service.cli.session.TestSessionHooks.testSessionHook
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithBinary.testExecuteStatement
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithBinary.testExecuteStatementAsync
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithBinary.testGetFunctions
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithBinary.testOpenSession
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithHttp.testExecuteStatement
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithHttp.testExecuteStatementAsync
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithHttp.testGetFunctions
org.apache.hive.service.cli.thrift.TestThriftCLIServiceWithHttp.testOpenSession
org.apache.hive.service.cli.thrift.TestThriftHttpCLIServiceFeatures.testForwardedHeaders
{noformat}

Test results: https://builds.apache.org/job/PreCommit-HIVE-MASTER-Build/623/testReport
Console output: https://builds.apache.org/job/PreCommit-HIVE-MASTER-Build/623/console
Test logs: http://ec2-204-236-174-241.us-west-1.compute.amazonaws.com/logs/PreCommit-HIVE-MASTER-Build-623/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.TestCheckPhase
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 105 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12819724 - PreCommit-HIVE-MASTER-Build, Is this patch still relevant? I would be interested in reviewing on RB if so ;), Yew. It's still relevant. Of course from the unit test failures, EmbededThriftCliService e.g. doesn't create ServerContext which needs to be addressed. But I will create a RB so you can review and give suggestions., [~aihuaxu] I think what [~szehon] is referring to here is that to implement session level failover, it will help if we don't close the session on the server, when the client tcp socket that opened the session gets closed., [~aihuaxu] Thanks for the patch. Reviewing it today. Please note that we also have a way to send thrift payloads over http (in case that needs special consideration)., Thanks [~vgumashta]. What I'm trying to do is to let session be aware of the connections. So if the session is bound to 3 connections, disconnecting 2 connections only unbind the session and the disconnection of the third connection will close the session. , Hi [~aihuaxu], I just started looking at this issue and related code. Looks like each instance of HiveConnection class holds a reference to a Transport instance (representing the underlying tcp/http connection) and a reference to SessionHandle. Like you mentioned, there is no binding between the Transport instance and SessionHandle. But I don't see how a new HiveConnection can hold a reference to an existing SessionHandle. Looks like when we need to create a new HiveConnection, we create a new HiveSessionImpl instance and attach the handle the HiveConnection. Also when we need to close a HiveConnection, we close the Hive session first. 

So can you elaborate how a new HiveConnection can use an existing HiveSession? Thanks!, [~taoli-hwx] This issue happens when you use thrift API directly, not from JDBC. One workflow can be as follows. Notice you need to pass sessionHandle to each request so you can pass in an existing sessionHandle created from another connection. Then when you close the connection, it will also close the session while the session is still used by another connection.

{noformat}
        final TSocket tSocket = new TSocket(host, port);
        tSocket.open();
        final Client client = new Client(new TBinaryProtocol(tSocket));

        TOpenSessionReq req = new TOpenSessionReq();
        Map<String, String> openConf = new HashMap<String, String>();
        req.setConfiguration(openConf);
        TOpenSessionResp resp = client.OpenSession(req);

        TGetTablesReq getTablesReq = new TGetTablesReq(resp.getSessionHandle());
        client.GetTables(getTablesReq);
{noformat}, SessionHandle is getting passed in most (all?) calls to HS2: https://github.com/apache/hive/blob/master/service-rpc/if/TCLIService.thrift

In TThreadPoolServer (https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/server/TThreadPoolServer.java#L300)
the call order seems to be:

createContext -> processContext -> openSession (where we capture and set sessionHandle in the context as context.setSessionHandle(sessionHandle) -> deleteContext

Similarly, could we do for, say ExecuteStatement:

createContext -> processContext -> ExecuteStatement (where we capture and set sessionHandle like above) -> deleteContext

IOW, you can attach the session to any connection for every request individually. And keep a count of number of connections for every session which you decrement in deleteContext. When it reaches 0, you can delete the session.

Am I missing something ?, I think this is more like keeping track of the active operations for the session, not the number of connections.  We only call cerateContext() when the new connection is created, not ExecuteStatement() or getCatalog(), etc. 

Counting active operations may also not work since even if the count is 0, the user may want to keep the session open and submit additional operations.    ]