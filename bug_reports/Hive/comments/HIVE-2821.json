[I tried it in hive 0.8.1 
select count(*) from (
select /*+ MAPJOIN(b) */ a.* from src a join src1 b on a.key=b.key where a.key=48
union all
select /*+ MAPJOIN(b) */ aa.* from src aa
join src1 bb on aa.key=bb.key where aa.key=100
) t;

it was success.
i also tried this:

select count(1) from (
select key,value from (select /*+ MAPJOIN(b) */ a.* from src a join  src1 b on a.key=b.key where a.key=48) t1 
union all
 select key,value from (select /*+ MAPJOIN(b) */ aa.* from src aa join src1 bb on aa.key=bb.key where aa.key=100) t2 
) t3;

it ok.

so It's only happened in hive0.7 version.
, hive> explain select count(1) from (    
    > select key,value from (select /*+ MAPJOIN(b) */ a.key, a.value from src a join src1 b on a.key=b.key) t1 
    > union all
    > select key,value from (select /*+ MAPJOIN(bb) */ aa.key, aa.value from src aa join src1 bb on aa.key=bb.key) t2 
    > ) t3;
FAILED: Hive Internal Error: java.lang.NullPointerException(null)
java.lang.NullPointerException
	at org.apache.hadoop.hive.ql.optimizer.ppr.PartitionPruner.prune(PartitionPruner.java:170)
	at org.apache.hadoop.hive.ql.optimizer.GenMapRedUtils.setTaskPlan(GenMapRedUtils.java:553)
	at org.apache.hadoop.hive.ql.optimizer.GenMapRedUtils.setTaskPlan(GenMapRedUtils.java:514)
	at org.apache.hadoop.hive.ql.optimizer.GenMapRedUtils.initPlan(GenMapRedUtils.java:125)
	at org.apache.hadoop.hive.ql.optimizer.GenMRRedSink1.process(GenMRRedSink1.java:76)
	at org.apache.hadoop.hive.ql.optimizer.GenMRRedSink3.process(GenMRRedSink3.java:64)
	at org.apache.hadoop.hive.ql.lib.DefaultRuleDispatcher.dispatch(DefaultRuleDispatcher.java:89)
...

environment: hive-05b8af0(0.8.1release); Mac 10.7.3; java 1.6.0_31-b04-415-11M3635.

I debug in eclipse to see how to generate mapjoin plan, find current logic depends on the sequence walk each TableScanOperator.

For case like: 
TS_1 -> \
TS_2 ->  Mapjoin_3 -> \
....................TS_4 -> Mapjoin_5
must walk TS_1 or TS_2 first, or hive will throw NPE;

For case like:
TS_1 -> \
TS_2 -> Mapjoin_3 -> Union_4 -> \
.....................................TS_5 -> Mapjoin_6
must walk TS_5 first, or throw NPE;

What i do is to replace "private HashMap<String, Operator<? extends Serializable>> topOps;"(in SemanticAnalyzer.java) with "private LinkedHashMap<String, Operator<? extends Serializable>> topOps;"  and hack a Transform in Optimizer.java to adjust the sequence of each TSOperator. I tested, it works well.

But that is not enough for case like Mapjoin union all Mapjoin(map only union) then followed by a reducer. I have another hack, in ql/src/java/org/apache/hadoop/hive/ql/optimizer/GenMapRedUtils.java:
123c123
<     if (!seenOps.contains(currTopOp)) {
---
>     if (!seenOps.contains(currTopOp) && currTopOp!=null) {
It's toooooo hack, and not even tested by running job(its plan from explain is OK). I'm waiting for official patch too., No longer reproducible on trunk.]