[DbTxnManager will use DbLockManager(), so I think hive.zookeeper.quorum is not relevant., yes you are right!, but still deadlock., I confirm, we are having the same issue on Hive 1.1.0, and I reproduced it on 1.2.1

CREATE TABLE test_db.test_table (id INT) 
PARTITIONED BY (part STRING)
STORED AS ORC ;

INSERT INTO TABLE test_db.test_table PARTITION (part="test")
VALUES (1), (2), (3), (4) 
;

SET hive.exec.dynamic.partition.mode=nonstrict ;
SET hive.support.concurrency=true ;

INSERT OVERWRITE TABLE test_db.test_table PARTITION (part)
SELECT * FROM test_db.test_table ;

nothing happens, and when doing a SHOW LOCKS in another shell we get :

+----------+-----------+------------+------------+-------------+--------------+-----------------+-----------------+----------------+
| lockid   | database  | table      | partition  | lock_state  | lock_type    | transaction_id  | last_heartbeat  |  acquired_at   |
+----------+-----------+------------+------------+-------------+--------------+-----------------+-----------------+----------------+
| 3765     | test_db   | test_table | NULL       | WAITING     | EXCLUSIVE    | NULL            | 1440603633148   | NULL           |
| 3765     | test_db   | test_table | part=test  | WAITING     | SHARED_READ  | NULL            | 1440603633148   | NULL           |
+----------+-----------+------------+------------+-------------+--------------+-----------------+-----------------+----------------+

from looking at the source of org.apache.hadoop.hive.ql.lockmgr.EmbeddedLockManager, I would say it is stuck
in the for loop of the method lock(List<HiveLockObj> objs, int numRetriesForLock, long sleepTime), 
where lockPrimitive() keeps failing on the second lock.





]