[see todo: TestAcidOnTez.testCtasTezUnion - todo tagged with this HIVE-16669

also note: in the same test, minor compaction creates delete_delta_0000018_0000021  even though the smallest delete_delta has txn 20.  Tighten the bounds to make file selection more efficient., HIVE-16669.wip.patch has tests and some notes, Can Major compaction use Vectorized reader underneath?, consider: delta_26_29 and delete_delta_29_29 - current implementation of getAcidState() will consider delete_delta_29_29 obsolete.  Given current implementation of write path/compaction this can't happen but if deleta and delete_delta ranges can evolve independently it could.  Perhaps getAcidSate() should keep 2 'working' collections and filter each separately., If we have table based WriteIDs, can compactor compact up to the smallest open WriteID in a table rather that smallest open global txn?
This would mean compactor is less likely to starve due to long running write transactions (multi statement especially), if compactor runs in a txn, it must write to min_history.  Suppose txnid:7 is A, txnid:70 is Compactor.  71 starts and sees 7 as A and 70 as O.  If 70 makes 7 empty we need to make sure {{cleanEmptyAbortedTxns()}} doesn't remove 7's entry from TXNS since files produced by 70 are not visible to 71 and if 70 reads older files, it will treat 7's data as committed (if {{cleanEmptyAbortedTxns()}} runs).

]