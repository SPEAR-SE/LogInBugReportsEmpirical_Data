[Do you have details on what thread safety issues you're seeing?
cc [~ekoifman], Here is the code for openTransaction():

{code}
  public boolean openTransaction() {
    openTrasactionCalls++;
    if (openTrasactionCalls == 1) {
      currentTransaction = pm.currentTransaction();
      currentTransaction.begin();
      transactionStatus = TXN_STATUS.OPEN;
    } else {
      // openTransactionCalls > 1 means this is an interior transaction
      // We should already have a transaction created that is active.
      if ((currentTransaction == null) || (!currentTransaction.isActive())){
        throw new RuntimeException("openTransaction called in an interior"
            + " transaction scope, but currentTransaction is not active.");
      }
    }

    boolean result = currentTransaction.isActive();
    debugLog("Open transaction: count = " + openTrasactionCalls + ", isActive = " + result);
    return result;
  }
{code}

So variables 

*  openTrasactionCalls (obviously misspelled)
* currentTransaction
* transactionStatus 

are not protected by anything and in case of concurrent access may accessed/modified concurrently causing all sorts of inconsistent behavior.
, It is used thru a threadlocal on a higher level, so all of these are effectively threadlocal. It would be nice to get rid of threadlocals, but that would be a much larger piece of work., Oh, I see. So the story is interesting. I was looking at HIVE-13836 and the fix for that. It seems that the problem is with HIVE-9174 which uses non thread-local RawStore which isn't thread-safe and the cover-up was HIVE-13836 where the real solution should have involved thread-local RawStore.

This means that all users of RawStoreProxy are in trouble because they do not use thread-locals. Looking at the code, these are:

* CompactorThread (hopefully there is only one)
* DbNotificationListener that does have a problem
* HiveMetaStore.HMSHandler which uses thread-local.

So this is really a problem for DbNotification listener.

So given the current model of thread-local access, this is a problem specific to the DbNotificationListener which should use thread-local RawStore rather than cover up things with a lock., On the other hand, is there any reason *not* to make openTransaction and the rest thread-safe?, The state is thread-specific. Each thread calls open, then does stuff (potentially with nested open/close), then calls commit/rollback ... if 2 threads happen to be using the same rawstore, we don't want their open/close and their operations to mix. So to make it thread-safe, the entire top-level transaction needs to be isolated, or the txn state would need to be separated into some sort of context object, I see, makes sense. Is there a specific reason not to create persistence manager per transaction which then should take care of nested transactions (which should create their own persistence manager and open transaction within its context)?, So, there is no sense in making openTrascationCalls volatile? For now it looks a bit odd - the variable is volatile (assuming multi-threading usage), but non-atomic operators ('++' and '--') have been used., This seems to be fixed by HIVE-15766, so nothing to be done. 
[~vgumashta] looks like you fixed this already., This was fixed as HIVE-15766]