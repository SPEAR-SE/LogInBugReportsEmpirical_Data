[Seems that we need a rollbackTransaction in method getPartition for ObjectStore:
{code:java}
  @Override
  public Partition getPartition(String dbName, String tableName,
      List<String> part_vals) throws NoSuchObjectException, MetaException {
    openTransaction();
    Partition part = convertToPart(getMPartition(dbName, tableName, part_vals));
    commitTransaction();
    if(part == null) {
      throw new NoSuchObjectException("partition values="
          + part_vals.toString());
    }
    part.setValues(part_vals);
    return part;
  }
{code}, Hi [~nemon] I can take a look at this if you are not actively working on this., I have assigned it to you.Thanks., Hi [~nemon] What is the value of {{hive.support.concurrency}} on your system? I think this issue is more related to concurrency and not related to unbalanced calls to open and commit transaction. When the concurrency is turned off both the session will be free to proceed without acquiring any ZK locks and hence the exception on one of the sessions. The trace shows that it is trying to get the StorageDescriptor of the partition while the other session has already dropped the partition. When you turn on the concurrency, the drop partition session will wait since until it acquires the lock and then proceed as expected., Our system does not support concurrency. 
When users submit both drop partition and modify the same partition concurrently by accident,then got uncommitted transaction.
For postgresql as backend,there will be a connection in state of idle in transaction.]