[[~the6campbells] Can you provide the HIVE version you have the problem?, [~the6campbells] I don't think it's a bug. The Char type has fixed-length with padding spaces but they are not to be included the value of the fields and won't be considered when you call the upper/lower function. The result is as expected.

, If you think you have additional issue, please reopen or open a new one., The Hive documentation is vague at best with respect to when padding is preserved/ignored:

"Char types are similar to Varchar but they are fixed-length meaning that values shorter than the specified length value are padded with spaces but trailing spaces are not important during comparisons. The maximum length is fixed at 255." 

There is no discussion on non-comparison operations such as upper, lower, concat etc.

Consider the following, the driver may return CCHAR will trailing blanks but a string operation such as concat fails to preserve them. Should an application locally perform a scalar operation on the returned value such as LEN, LOWER etc then it may retain the spaces. Meanwhile server side an 'equivalent' expression is not blank preserving.

select rnum, cchar, concat( concat( concat( cchar,'...'), cchar),'...') from tchar. 

So the driver will return BB<spaces> and then BB...BB... for the 2nd and 3rd projected item. Similarly length(cchar) returns 2 and not 5 etc.

Customers using technologies such as Hana, DB2, Netezza, ... will expect the blank padded behaviour. To all intents and purposes most SQL persons would not consider the implementation to be fixed length character.

i.e length(cchar) returns 32

i.e cchar || '...' ..... returns 'BB                              ...BB                              ...'

Should this be the design intent of Hive I would ask for the documentation to be far more comprehensive is stating the semantics. 

, This was by design. The SQL spec didn't seem to have any specifics here regarding the trailing spaces behavior, and MySQL/Postgres (which I had available at the time) had similar semantics regarding how trailing spaces for char were treated during length()/concat(). upper()/lower() should not be affected by this, I wouldn't suggest that use MySQL and Postgres alone is ideal to cross check SQL semantics. 

Should the Apache implementation for CHAR(n) stay this way going forward I recommend you get the documentation improved. 

Having seen companies migrate applications across vendors where this sort of thing burns them. Many may not know what ISO-SQL 20xx states (let alone care) and will presume that their source vendor(s) have followed the specification etc. 

Given the server side string operations etc, they may as well stay with VARCHAR and know that trailing spaces are not preserved vs the 'appears' to have spaces when projected but not in other cases. 

See discussion: http://www.postgresql.org/docs/9.1/static/datatype-character.html

See discussion of MySQL JDBC: https://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html re padCharsWithSpace

If you apply a <fold> (upper/lower) the type of the result is supposed to be from the <character value expression>

Length should be the number of characters in the <string value expression> - where number of  characters is based upon the semantics of the character set of the <string value expression>

If both operands are fixed length character strings, concatenation result is a fixed length character string with a length equal to the sum of the lengths of the operands where the length cannot exceed the maximum allowed for a fixed length character string.

Cheers., [~the6campbells] I didn't exactly follow your point. Are you recommending improving the documentation or some sort of enhancement? Based on my understanding, fixed length CHAR(n) is more efficient than varchar. The behavior of fixed length is, the padding trailing spaces won't be counted as part of the string. 

I do see an issue that if we insert a string with trailing spaces "abc " into CHAR(10),  we lost the last space. I think that's an issue since that trailing space is part of the original string.


What does this mean? "If both operands are fixed length character strings, concatenation result is a fixed length character string with a length equal to the sum of the lengths of the operands where the length cannot exceed the maximum allowed for a fixed length character string." , I saying that if the current implementation is by design and will not change that it be more completely documented. In particular, to show examples of how the design may deviate from other systems which implement fixed length character types as many vendors do (Teradata, DB2, Informix, Netezza, ....). 

Unfortunately, the current implementation "feels" like cases where vendors have added syntax that other products have but the implementation is not the same/has various gaps. The SQL documentation on the Apache Hive WIKI has limited discussion on the implementation etc. 

As for the last comment: ISO-SQL concatenation CHAR(x) || CHAR(y) should return CHAR(x+y) with implementation details re what happens when x+y > maximum precision of CHAR that a vendor provides. 
, Got your point.

1. From your last comment, I notice that it will return char(64) as the result for "concat(lower(cchar), upper(cchar)) ".  

2. And we should preserve the trailing space of the original string as I mentioned above.

[~jdere] Why we didn't return char(255) for such case? Do you agree (2) is an issue since regardless of the type you choose, we should get the value you stored, right?, - char(64) is correct per the rules mentioned above, since the combined length (32+32 = 64) is less than the char max length of 255. If the lengths exceed that (like concat(cchar, cchar, cchar, cchar), I believe it reverts to string type.
- As for (2), that depends on what we decide are the semantics regarding trailing spaces for char. Currently for Hive we ignore them for the purposes of comparison, length, and concatenation. As mentioned earlier this is similar to the MySQL/Postgres char semantics (which has often been done when for Hive dev). It's not impossible to change this, though we might have to think about backward compatibility issues again if we do., Got it. Thanks., [~the6campbells] Are you satisfied with the explanation? This is considered to by design. If you are concerned about the documentation, I will find out how to get it updated to reflect your point and trailing space. Let me know., HIVE-9899 doc bug is opened to keep track of the doc change. I'm closing this out. Let me know if you have other concerns. ]