[Problem:
When creating a child directory, the ACLs of the new directory were set based on the file permissions of the parent directory instead of following the ACL-inheritance rules. As a result, the ACLs for the group as well as the default ACLs are not set correctly. 

Proposed fix:
1. If the parent directory has default ACL entries set, then the child directory will inherit from parent's ACL entries, including all named/unnamed user, group and default entries.
2. If the parent directory does not have default ACL entries, but does have some ACL entries set such as a named user, by default the group ACL entry for the sub-directory is already set correctly in the current implementation. But we need to add the ACL entries for USER and OTHER. 
3. If the parent directory does not have any ACL entries, set the child directory permissions using the parent's file permissions.

For reference, here is some background info on the mask: 
1. From hadoop documentation: "The mask is a special ACL entry that filters the permissions granted to all named user entries and named group entries, and also the unnamed group entry. If the user doesn't supply a mask while setting an ACL, then a mask is inserted automatically by calculating the union of permissions on all entries that would be filtered by the mask."
2. From Linux acl manual, section CORRESPONDENCE BETWEEN ACL ENTRIES AND FILE PERMISSION BITS: "If the ACL has an ACL_MASK entry, the group permissions correspond to the permissions of the ACL_MASK entry.  Otherwise, if the ACL has no ACL_MASK entry, the group permissions correspond to the permissions of the ACL_GROUP_OBJ entry.", I am working on adding some test cases to cover the ACL inheritance. If anyone has review comments to the proposed solution, please comment on the JIRA., Update patch to include testcase, Request for code review, 

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12770132/HIVE-11481.2.patch

{color:green}SUCCESS:{color} +1 due to 1 test(s) being added or modified.

{color:red}ERROR:{color} -1 due to 4 failed/errored test(s), 9770 tests executed
*Failed tests:*
{noformat}
org.apache.hadoop.hive.cli.TestHBaseCliDriver.testCliDriver_hbase_queries
org.apache.hadoop.hive.cli.TestNegativeCliDriver.testNegativeCliDriver_authorization_uri_import
org.apache.hadoop.hive.hwi.TestHWISessionManager.testHiveDriver
org.apache.hive.jdbc.TestSSL.testSSLVersion
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/5890/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/5890/console
Test logs: http://ec2-174-129-184-35.compute-1.amazonaws.com/logs/PreCommit-HIVE-TRUNK-Build-5890/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.TestCheckPhase
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 4 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12770132 - PreCommit-HIVE-TRUNK-Build, Thanks for the patch Carita.  I am having some trouble how the patch solves the issue, it seems it is setting only the default ACL's on the target if there are any, and falls back to the old way if there are not?, Hi Szehon,

Thanks for reviewing the patch. Yes this patch sets the default ACLs if they exist, and if not, it sets the traditional user/group/other permissions. The difference between this patch and the old way is how we're setting the group permissions. 

When an ACL is set on a directory, the value returned from sourcePerm.getGroupAction() is not the actual group permissions, it is the mask. When we set a named user or named/unamed group ACL, the mask is automatically defined as the union of those permissions. For example, drwxrwx---+ is actually showing the user:mask:other. 

When there are ACLs set on a directory, the child directory is already created with the correct group ACL permissions in the current implementation. The issue is that the group file permissions are not set correctly because they were overwritten with the parent's mask (retrieved from sourcePerm.getGroupAction()). This patch fixes the issue by not overwriting the group with the parent's mask file permissions if there are ACLs for the directory, keeping the group value that was set earlier with the chgrp command in the method. We only need to set the group ACL entry if there are no ACL entries set., Thanks for explanation, I will have to play with this patch, I apologize for the delay .., Hi Carita, I spent some time reading up on default ACL's and taking a deeper look and have some review questions.

1.  Shouldn't we also set default ACL's on the child, if they are a directory?  This code maybe called in situation where input is a nested directory (like multi-column partition tables).  "When a directory is created inside a directory that has a default ACL, the new directory inherits the parent directory's default ACL both as its access ACL and default ACL."


2.  Do we still need to remove the base ACL's regardless of whether there are no defaults?  If I recall correctly it was to prevent some duplicates (as you are again setting USER and OTHER). 

3.  Can you write a test case that uses DEFAULT Acl's?  The test you added seems to use AclEntryScope.ACCESS but not DEFAULT., Hi Szehon, I updated the review board with the new patch.

1. This is true. The child directory inherits the parent's default ACLs as its own default ACLs, and also as it access ACLs. I made some code changes for the child directory to inherit the parent's default ACL as its access ACL, overwriting the named user|group access ACL if exists. For example, the parent directory has following ACLs:
{noformat}default:user:foo:r--
user:foo:rwx{noformat}
after inheritance, the child will have the following ACLs:
{noformat}default:user:foo:r--
user:foo:r--{noformat}
Can you please verify that this should be the case?

2. We are removing the baseAclEntries if there are Default ACLs. This is to prevent the setfacl command from failing if there are duplicate ACL entries with the same scope, type, and name. For example, this following command {noformat}"hadoop fs -setfacl -R --set 'user::rwx,user::r--' /path"{noformat} will fail with "setfacl: Invalid ACL: multiple entries with same scope, type and name."
If there are no default ACLs, we don't need to remove baseAclEntries. At this point, only the group access ACL is present in the ACL list, and the "setfacl -R" command requires the user, group and other entries. That is why I'm setting USER and OTHER again. For example, this following command {noformat}"hadoop fs -setfacl -R --set 'user::r--' /path"{noformat} will fail with "setfacl: Invalid ACL: the user, group and other entries are required."

3. I updated the testcase to include Default ACLs. Thank you for asking to include this. After including default ACLs, I found that more code changes were needed to address your question #1. , 

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12780018/HIVE-11481.3.patch

{color:green}SUCCESS:{color} +1 due to 1 test(s) being added or modified.

{color:red}ERROR:{color} -1 due to 19 failed/errored test(s), 9978 tests executed
*Failed tests:*
{noformat}
TestCliDriver-skewjoin_union_remove_2.q-cluster.q-udf_asin.q-and-12-more - did not produce a TEST-*.xml file
TestHWISessionManager - did not produce a TEST-*.xml file
TestSparkCliDriver-timestamp_lazy.q-bucketsortoptimize_insert_4.q-date_udf.q-and-12-more - did not produce a TEST-*.xml file
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_order2
org.apache.hadoop.hive.cli.TestEncryptedHDFSCliDriver.testCliDriver_encryption_insert_partition_dynamic
org.apache.hadoop.hive.cli.TestNegativeCliDriver.testNegativeCliDriver_authorization_uri_import
org.apache.hadoop.hive.cli.TestNegativeCliDriver.testNegativeCliDriver_columnstats_partlvl_multiple_part_clause
org.apache.hadoop.hive.ql.exec.spark.session.TestSparkSessionManagerImpl.testMultiSessionMultipleUse
org.apache.hadoop.hive.ql.exec.spark.session.TestSparkSessionManagerImpl.testSingleSessionMultipleUse
org.apache.hadoop.hive.ql.security.authorization.plugin.TestHiveOperationType.checkHiveOperationTypeMatch
org.apache.hive.jdbc.TestSSL.testSSLVersion
org.apache.hive.spark.client.TestSparkClient.testAddJarsAndFiles
org.apache.hive.spark.client.TestSparkClient.testCounters
org.apache.hive.spark.client.TestSparkClient.testErrorJob
org.apache.hive.spark.client.TestSparkClient.testJobSubmission
org.apache.hive.spark.client.TestSparkClient.testMetricsCollection
org.apache.hive.spark.client.TestSparkClient.testRemoteClient
org.apache.hive.spark.client.TestSparkClient.testSimpleSparkJob
org.apache.hive.spark.client.TestSparkClient.testSyncRpc
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/6503/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/6503/console
Test logs: http://ec2-174-129-184-35.compute-1.amazonaws.com/logs/PreCommit-HIVE-TRUNK-Build-6503/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.TestCheckPhase
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 19 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12780018 - PreCommit-HIVE-TRUNK-Build]