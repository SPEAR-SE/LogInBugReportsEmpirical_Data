[HiveBaseFunctionResultList use RowContainer to store collected map output row, all rows should be added into RowContainer then start read from it, RowContainer does not support write after read. Remove current lazy execution mode as it depends on RowContainer write-after-read., Process all inputs and stored output rows in RowContainer and then read from it is not very performance efficient. We could just use a queue to store output rows as ResultIterator only process next record while get next output row., 

{color:red}Overall{color}: -1 at least one tests failed

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12663637/HIVE-7799.2-spark.patch

{color:red}ERROR:{color} -1 due to 4 failed/errored test(s), 5980 tests executed
*Failed tests:*
{noformat}
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_sample_islocalmode_hook
org.apache.hadoop.hive.cli.TestMiniTezCliDriver.testCliDriver_dynpart_sort_opt_vectorization
org.apache.hadoop.hive.cli.TestNegativeCliDriver.testNegativeCliDriver_fs_default_name2
org.apache.hadoop.hive.cli.TestSparkCliDriver.testCliDriver_union_null
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-SPARK-Build/79/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-SPARK-Build/79/console
Test logs: http://ec2-54-176-176-199.us-west-1.compute.amazonaws.com/logs/PreCommit-HIVE-SPARK-Build-79/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 4 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12663637, I think with the v2 patch we need unbounded memory as we store the results in Queue and sometime a single input record could generate more than one record (UDTF) or some operators (such as group by) flush after processing many input records., Let me look at the RowContainer and see if we can modify/extend it to support read/write like a queue with a persistent support. As far as I see we need persistent support., Thanks,[~venki387], it seems i miss something here, group by does need a persistent storage support here., Whenever {{ResultIterator.hasNext()}} or {{ResultIterator.next()}} is called we first serve records from RowContainer until all records in RowContainer are consumed. If there are no more records in RowContainer then we clear RowContainer and call {{processNextRecord}} or {{closeRecordProcessor}} in {{ResultIterator.hasNext()}} to get the next output record(s). So we start adding records only when RowContainer is empty (or cleared). I am trying to understand how we got into the situation where we are trying to write after reading has started. One scenario I can think of is if Spark has two threads like in producer-consumer., ScriptOperator is spawning a separate thread which is adding the records to collector. Iterator thread is trying to read from RowContainer while ScriptOperator spawned thread is adding the records. There may be other operators that may spawn threads for processing. Looks like we need a synchronized queue with persistence support. , MapDB might offer something we use or wrap: https://github.com/jankotek/mapdb, When resolved me might consider adding 

 * orc_merge1.q
 * orc_merge2.q
 * orc_merge3.q
 * orc_merge4.q

from HIVE-7792., Depends on the implementation of {{ResultIterator.hasNext()}}, it is designed to be a lazy iterator as it only try to call {{processNextRecord()}} while RowContainer is empty, but RowContainer does not support add more rows after already read as mentioned in previous comments. Here is what happens while different queries is executed:
# For Map only job, it write map output into file directly, no need Collector in this case.
# For Map Reduce job with GroupByOperator, {{HiveBaseFunctionResultList.collect()}} is triggered by {{closeRecordProcessor()}}, which is beyond the lazy-computing logic, so the ResultIterator does not do lazy computing in this case.
# For Map Reduce job without GroupByOperator(like cluster by queries), ResultIterator do lazy computing, and it clear RowContainer each time befor call {{processNextRecord()}}. While read/write HiveBaseFunctionResultList in the same thread, access progress of RowContainer is like .....clear()->addRow()->first()->clear()->addRow()->first()...... so it won't violate RowContainer's access rule. But with mutli threads to read/write HiveBaseFunctionResultList, as the ScriptOperator does which venki mentioned above, it would definitely hit this JIRA issue.

In my opinion, there are 2 solutions:
# remove ResultIterator lazy computing feature as patch1 does.
# implement a RowConatiner-like class, which support current RowContainer features. it also need to be thread-safe, and support add row after {{first()}} is already called. 

The second solution is quite complex, it may introduce performance degrade after support thread-safe access and write-after-read, compare with the performance upgrade of lazy-computing support, it's hardly to say whether it's worthy or not now. So I suggest we take the first solution to fix this issue, and left the possible optimization to milestone 4., reattach the first patch., [~chengxiang li] Your plan sounds good. Lets log a JIRA to enable lazy computing and we will revisit in milestone 4., 

{color:red}Overall{color}: -1 at least one tests failed

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12664112/HIVE-7799.3-spark.patch

{color:red}ERROR:{color} -1 due to 3 failed/errored test(s), 6253 tests executed
*Failed tests:*
{noformat}
org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_sample_islocalmode_hook
org.apache.hadoop.hive.cli.TestMiniTezCliDriver.testCliDriver_dynpart_sort_opt_vectorization
org.apache.hadoop.hive.cli.TestNegativeCliDriver.testNegativeCliDriver_fs_default_name2
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-SPARK-Build/92/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-SPARK-Build/92/console
Test logs: http://ec2-54-176-176-199.us-west-1.compute.amazonaws.com/logs/PreCommit-HIVE-SPARK-Build-92/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 3 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12664112, Hey guys, I created HIVE-7873 to track the improvement in M4., Thank you guys! I have committed this to spark!]