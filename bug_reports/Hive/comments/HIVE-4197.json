[bq. Standard Compliance: we defer from the SQL standard here (Partition/Order spec), which only allows expressions to be Column References.
I think we can keep allowing expressions. This is more powerful, subsumes column reference only and I don't see any confusion arising because of this.

bq. the Sql Standard allows boundary amount to be any expression of type Unsigned Int. We are only allowing this to be a constant.
We are more restrictive than standard. But thats fine for now, we can improve on this later.

bq. : we don’t plan to support this feature (window frame exclusion) in release 1.
Yeah.. lets defer this to later release.

In section 2, I didn't get the concept of source window spec and thereby subsequent points. Can you give an example in form of queries? That will help me formulate my opinion.

bq.  How do we achieve this stable order? Any suggestions.
This implies we must enforce secondary sort in reduce sink, otherwise order of values for that key in reducer is unspecified. This effectively means that we are inserting an order spec. Since in this case, user has not specified an order spec, doing ordering on partitioning column is reasonable. I believe this is already the case in current implementation. Although this forces us to forgo some optimizations (predicate pushdown) but thats fine for first release. Later on, we can remember when we are introducing ordering ourselves vs when user has asked for it, to give those optimization rules a chance to fire. 

bq. FOLLOWING unsigned int NULL ANY ??
I am also not clear what to do this in corner case. I think throwing an error is reasonable.

bq. Speciﬁcation of a Range based Window: is not based on the Sort expression
I think here we don't have a luxury to deviate from standard on this one. As you have noted this might be confusing. Better to remove it and be standard compliant. 

bq. • Notion of UDAFs that shouldn’t have a Window Frame: Rank, Dense_Rank, Percent_Rank, Cume_Dist, Lead, Lag are conﬁgured this way.
I think its fine to keep existing behavior. Can't think of a use case where defining a window frame for these functions making sense.

bq. Notion of Lead/Lag UDFs usable as arguments in UDAFs:
I think we can keep this since it serves useful use case. Though if it is burdensome to implement or results in umaintainable code, I would prefer to remove it. So, I will leave this decision upto you., Harish,

This is really helpful, thanks.  I have a few questions:

Section 2.1, what is a Source Window Spec?

Section 3, I can't see any way in an MR framework to guarantee order stability without adding an order clause.  I suppose we could add an implicit one that doesn't change the window frame, but that seems expensive.  I'd say just note that we don't guarantee a stable order here and if users want a stable order they should put in an order by.

Section 3.1.2 The addition of +1 to all of the following specifications seems wrong.  If window definition says BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW I believe the spec stipulates that it will end at the current row, not one past the current row.  

Section 3.1.3 
Where are we at on RANGE support?  I'm wondering if it would be better to focus on stabilizing ROWS support for now and adding RANGE support later., Ashutosh, thanks for reviewing.

- agree with you on Partition/Order expressions, Boundary amount deviations from Standard.

- Stable order issue:
It is not just restricted to when no order is specified. It also crops up when 2 rows have the same value on the Order expressions. This affects  the window frame and processing of functions that dependent on the order(rank,dense_rank...)
One thought is to add the FileName and FileOffset virtual columns to the Order Spec. 

Source Window Spec:
as I understand this, it is the ability to reference another Window definition in the Query and inherit components from it. For e.g.

{noformat}
select a,b, rank() over (w1 unbounded preceding and current row),
from xyz
window w1 (partition by x order by y)
{noformat}

The effective window spec for rank() is:
{noformat}
rank() over (partition by x order by y w1 unbounded preceding and current row)
{noformat}

The rule we have adopted is that each component Partition, Order, WindowFrame is independently inherited from a source Window Spec. Inheritance happens only if that component is not defined. As I said in the doc, it is not clear to me what the spec is mandating here.

- Agree with your other points. 
1. The way we have Range Windows is confusing. Should associate it with the Order expression
2. Don't see the point of allowing Windows on Lead, Lag, Rank etc.So then Jira 4192 can be resolved as '.working as designed'
3. Lead/Lag UDFs will keep it in for now; but may remove if it becomes hard to maintain, Alan, thanks for reviewing.

- Have explained the concept of Source Windowspec in the previous response to Ashutosh.
- The stable sort issue also crops up when there multiple rows with the same Order expressions. Again, see previous response.
- The Window Frame Range I was documenting was [start,end), so the end side is open ended. This an artifact of our implementation...
- Range support is there; I think the changes we need to make are manageable. But if we run into major blocks, then agree we can defer this. , [~alangates] Stable sort issue seems to be an important one, especially since because of shuffle enhancements between hadoop1 and hadoop2 sort is not stable between two for same query. Harish's proposal is to always add filename and file offset virtual column which I think will enforce stable sort. In absence of any other solution, this looks like fine to me. Do you think we can do any better? , bq. Stable sort issue seems to be an important one ...

Yeah, I hadn't thought about the point that even in ORDER BY our sort needs to be stable in order to give consistent results.  It sucks that we have to introduce a sort even in queries without an ORDER BY, but oh well.  I agree that FileName and FileOffset are a good proxy, as that will maintain stability in the sort., Adding FileName, Offset Virtual Columns is not straightforward.
Consider the following query:
{noformat}
select p_mfgr, p_name, p_size, 
min(p_retailprice),
rank() over(partition by p_mfgr order by p_name)as r
from part
group by p_mfgr, p_name, p_size
{noformat}
Adding the VCs to the OrderSpec for rank requires that we add them to the Select List also; otherwise we get the error: Expression not in GROUP BY key 'INPUT__FILE__NAME'

It gets more challenging if the Query has Joins or SubQueries. 
It will not work if the Query has a PTF(a PTF is not required to output the VCs).
Any suggestions?, Hmm.. One way I can think of is to sort rows ourselves. We need to add an extra column in mapper (combination of task.id and monotonic increasing row number) and than in PTFOperator have an implementation of ByteBasedList which uses Priority Queue to store data in memory instead of ByteBuffer. This Priority Queue will insert data in order of this new column we added and dropping it soon after.
However, this seems to me is pretty heavy-handed approach. I will prefer something simpler. Harish, this problem of stable sort is getting exposed only on hadoop2, so I will suggest for now lets focus on other issues as we think and come up with a better solution for it, since on hadoop1 we don't have such a problem.
, https://reviews.facebook.net/D9717 Review request on behalf of [~rhbutani], upload updated doc., Committed to branch. Thanks, Harish!]