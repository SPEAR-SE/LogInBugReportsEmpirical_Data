[I think it primarily comes down to this: the hive conf object once modified with a generated query id, never resets the query id for a subsequent query.

{code}
+    String queryId = confOverlay.get(HiveConf.ConfVars.HIVEQUERYID.varname);
+    if (queryId == null || queryId.isEmpty()) {
+      queryId = QueryPlan.makeQueryId();
+      confOverlay.put(HiveConf.ConfVars.HIVEQUERYID.varname, queryId);
+      sessionState.getConf().setVar(HiveConf.ConfVars.HIVEQUERYID, queryId);
+    }
{code}

Once the query id has been set by a previous query, it never changes. This is incorrect behavior. I am not sure about what the change was trying to do but this needs to get fixed. Thanks!, I will take a look. That seems to be an issue and not my intention. 


, [~vikram.dixit] This is to check if we provide queryId from the client. If a client provides a queryId, then we will use that queryId internally, otherwise, we will make a new one since the client could need a meaningful queryId. 

Seems there is a bug in here. We should make a new queryId inside if statement and set it outside the if statement., OK. We had a followup to fix HIVE-12456 to avoid storing queryId in SessionState since multiple queries can run in the same session at the same time. Later we will combine session conf and confOverlay conf to the query conf so the query should have the new queryId.

[~vikram.dixit] Did you have the patch-12456 applied?, [~aihuaxu] - I'm curious as to why we allow the queryId to be overwritten by users. Isn't that meant to be unique within HiveServer. If some historic query information were to be retained by HiveServer - that would break. The query name can already be overwritten., QueryId should be unique. The user overwritten queryId is for the user to provide meaningful queryId if the user wants to and the user needs to make sure it's unique.  

If the user doesn't overwrite the queryId, then hive will generate one as before. , OK. I think there is an issue there. confOverlay is passed from the client. Seems we need to make a copy of that otherwise if the client reuses the same confOverlay, then queryId is reused. Is that the issue? I will correct that., The issue here is that if we make a change in the incoming configuration, it remains set for the duration of the session. We need to make sure that the user does not set the query id configuration because there is a chance of them breaking what a query id is - a unique id for each query. I think what you really want is something like the HIVE_LOG_TRACE_ID which could be renamed to something like a HIVE_USER_TRACE_ID - an id that a user can set and trace which can stay constant until the user decides to change it. You could create a separate configuration too for the use case you have. I think allowing the user to mess around with the query id looks like a recipe for bugs. I think we should move the query id to a config that the user cannot change and just put it in the utilities class for e.g. like INPUT_NAME that mapreduce used., Actually what I need is the unique queryId. Think of the scenario that hive is just one of the components in the pipeline. The client could have a queryId (e.g., to trace the generation of the query) and then call hive. Then such queryId can link them together and better for diagnosis. If we create other ids, then seems to defeat that purpose. 

If the user doesn't provide queryId, then Hive will take care of that. Is the following the actual issue you see?
{nformat}
I think there is an issue there. confOverlay is passed from the client. Seems we need to make a copy of that otherwise if the client reuses the same confOverlay, then queryId is reused. Is that the issue? I will correct that.
{noformat}
 , [~aihuaxu] Consider the following scenario: In Tez/Spark, if we end up caching the small table based on the hive query id. If say the user set the hive query id for 1 query and does not reset it for the subsequent query, we will end up picking the previously cached hash table for the join resulting in incorrect results right? Creating a new conf object would only work if we reset the query id after the query completes. If we allow it to exist in the configuration object after a query has completed running, it will result in incorrect results or some weird behavior.

Consider hs2 or cli session, if a user in a session assigns a query id and doesn't reset it, it can result in incorrect results. You are expecting a user to set a query id each time after setting it once? I don't think that is great behavior., I moved to initialize the queryId earlier so that starting from the beginning of the execution, the workflow will have unique queryId. 

Actually I think your statement makes sense. What I need is really a traceId. Does the same queryId cause the issues? If it does, I can change to disallow the change from the client., I see. I will disallow the input of queryId and generate a new one every time then. , Yeah. The same queryId causes issues. We should disallow a change from the client. 

The HIVE_LOG_TRACE_ID is already present in the hive configuration. You could use that., Great! Thanks!, Attached the patch-1: disallow the input of the queryId. queryId will be regenernated and put in confOverlay for each query. 

[~vikram.dixit] Can you take a look?, It looks good to me. I ran a local test for the same. +1 pending tests., 

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12793636/HIVE-13286.1.patch

{color:red}ERROR:{color} -1 due to no test(s) being added or modified.

{color:red}ERROR:{color} -1 due to 5 failed/errored test(s), 9832 tests executed
*Failed tests:*
{noformat}
TestSparkCliDriver-groupby3_map.q-sample2.q-auto_join14.q-and-12-more - did not produce a TEST-*.xml file
TestSparkCliDriver-groupby_map_ppr_multi_distinct.q-table_access_keys_stats.q-groupby4_noskew.q-and-12-more - did not produce a TEST-*.xml file
TestSparkCliDriver-join_rc.q-insert1.q-vectorized_rcfile_columnar.q-and-12-more - did not produce a TEST-*.xml file
TestSparkCliDriver-ppd_join4.q-join9.q-ppd_join3.q-and-12-more - did not produce a TEST-*.xml file
org.apache.hive.service.cli.session.TestHiveSessionImpl.testLeakOperationHandle
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/7292/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/7292/console
Test logs: http://ec2-174-129-184-35.compute-1.amazonaws.com/logs/PreCommit-HIVE-TRUNK-Build-7292/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.TestCheckPhase
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 5 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12793636 - PreCommit-HIVE-TRUNK-Build, Attached patch-2: fix the unit test., [~aihuaxu] I think the bug still exists here. I see that once I set a query id, it never changes. I think you need the following change in the Driver class as well:

{code}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/Driver.java b/ql/src/java/org/apache/hadoop/hive/ql/Driver.java
index 7327a42..1fac526 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/Driver.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/Driver.java
@@ -403,13 +403,7 @@ public int compile(String command, boolean resetTaskIds) {
     }
     saveSession(queryState);

-    // Generate new query id if it's not set for CLI case. If it's session based,
-    // query id is passed in from the client or initialized when the session starts.
-    String queryId = conf.getVar(HiveConf.ConfVars.HIVEQUERYID);
-    if (queryId == null || queryId.isEmpty()) {
-      queryId = QueryPlan.makeQueryId();
-      conf.setVar(HiveConf.ConfVars.HIVEQUERYID, queryId);
-    }
+    conf.setVar(HiveConf.ConfVars.HIVEQUERYID, QueryPlan.makeQueryId());

     //save some info for webUI for use after plan is freed
     this.queryDisplay.setQueryStr(queryStr);

{code}

I ran a test with a lot more queries than earlier and it turned out that the query id did not change., Actually this is what you need:

{code}
diff --git a/ql/src/java/org/apache/hadoop/hive/ql/Driver.java b/ql/src/java/org/apache/hadoop/hive/ql/Driver.java
index 7327a42..fc10242 100644
--- a/ql/src/java/org/apache/hadoop/hive/ql/Driver.java
+++ b/ql/src/java/org/apache/hadoop/hive/ql/Driver.java
@@ -402,14 +402,9 @@ public int compile(String command, boolean resetTaskIds) {
       TaskFactory.resetId();
     }
     saveSession(queryState);
+    String queryId = QueryPlan.makeQueryId();

-    // Generate new query id if it's not set for CLI case. If it's session based,
-    // query id is passed in from the client or initialized when the session starts.
-    String queryId = conf.getVar(HiveConf.ConfVars.HIVEQUERYID);
-    if (queryId == null || queryId.isEmpty()) {
-      queryId = QueryPlan.makeQueryId();
-      conf.setVar(HiveConf.ConfVars.HIVEQUERYID, queryId);
-    }
+    conf.setVar(HiveConf.ConfVars.HIVEQUERYID, queryId);

     //save some info for webUI for use after plan is freed
     this.queryDisplay.setQueryStr(queryStr);
{code}, Attaching a full version in case hive qa gets to run the test., [~vikram.dixit] Seems the fix will get new queryId for the query, but I feel if the query is from the session, then the query will have 2 different ids, first the one generated in HiveSessionImpl.java and then a new one in Driver.java. 

Did you see the issues from hive CLI tests? , Let me take a look at CLI cases. , Yeah. In one of the cli tests, I just added this:

set hive.query.id = abc;

And added a log in TezTask class. I saw that we were retaining the id in this case., When we set in the session, it's saved in the session conf and carry over to each query. I guess we should disable setting hive.query.id in the session ideally. I will move the setting new queryId a little earlier in CliDriver.java so both CLI and Session queries should work.

, [~vikram.dixit] Attached patch-4: we will generate a new queryId for CLI case now. So set hive.query.id=abc; actually won't take effect.

Do you think it makes sense to have a follow up to disable setting session properties?, 

Here are the results of testing the latest attachment:
https://issues.apache.org/jira/secure/attachment/12794191/HIVE-13286.4.patch

{color:green}SUCCESS:{color} +1 due to 1 test(s) being added or modified.

{color:red}ERROR:{color} -1 due to 4 failed/errored test(s), 9835 tests executed
*Failed tests:*
{noformat}
TestSparkCliDriver-groupby3_map.q-sample2.q-auto_join14.q-and-12-more - did not produce a TEST-*.xml file
TestSparkCliDriver-groupby_map_ppr_multi_distinct.q-table_access_keys_stats.q-groupby4_noskew.q-and-12-more - did not produce a TEST-*.xml file
TestSparkCliDriver-join_rc.q-insert1.q-vectorized_rcfile_columnar.q-and-12-more - did not produce a TEST-*.xml file
TestSparkCliDriver-ppd_join4.q-join9.q-ppd_join3.q-and-12-more - did not produce a TEST-*.xml file
{noformat}

Test results: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/7310/testReport
Console output: http://ec2-174-129-184-35.compute-1.amazonaws.com/jenkins/job/PreCommit-HIVE-TRUNK-Build/7310/console
Test logs: http://ec2-174-129-184-35.compute-1.amazonaws.com/logs/PreCommit-HIVE-TRUNK-Build-7310/

Messages:
{noformat}
Executing org.apache.hive.ptest.execution.TestCheckPhase
Executing org.apache.hive.ptest.execution.PrepPhase
Executing org.apache.hive.ptest.execution.ExecutionPhase
Executing org.apache.hive.ptest.execution.ReportingPhase
Tests exited with: TestsFailedException: 4 tests failed
{noformat}

This message is automatically generated.

ATTACHMENT ID: 12794191 - PreCommit-HIVE-TRUNK-Build, [~vikram.dixit] How is the new patch? Can you take a look?, I tested the latest patch. It works as expected. +1, [~aihuaxu] Are the test failures related? Otherwise let me know and I can commit the patch to master and branch-2. I will raise a follow-on jira for disallowing the user to set this configuration., [~vikram.dixit] Those tests are not related. Sorry. Forgot to mention that. , Committed to both master and branch-2.0. Thanks [~aihuaxu]!]