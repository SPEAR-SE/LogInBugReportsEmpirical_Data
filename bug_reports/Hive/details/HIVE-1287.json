{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"12460589","self":"https://issues.apache.org/jira/rest/api/2/issue/12460589","key":"HIVE-1287","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310843","id":"12310843","key":"HIVE","name":"Hive","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310843&avatarId=11935","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310843&avatarId=11935","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310843&avatarId=11935","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310843&avatarId=11935"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2010-03-29T20:25:07.361+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Mon Apr 20 05:04:42 UTC 2015","customfield_12310420":"42551","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HIVE-1287/watchers","watchCount":3,"isWatching":false},"created":"2010-03-29T18:55:23.734+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2015-04-20T05:04:42.414+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12312586","id":"12312586","name":"Query Processor","description":"Tracks issues dealing with query processing."}],"timeoriginalestimate":null,"description":"The field names for {{Struct}} types are currently being matched for testing type equivalence. This is readily seen by running the following example:\n\n{noformat}\n\nhive> create table source ( foo struct < x : string > );\nOK\nTime taken: 3.094 seconds\n\nhive> load data local inpath '/path/to/sample/data.txt' overwrite into table source;\nCopying data from file:/path/to/sample/data.txt\nLoading data to table source\nOK\nTime taken: 0.593 seconds\n\nhive> create table sink ( bar struct < y : string >);\nOK\nTime taken: 0.11 seconds\n\nhive> insert overwrite table sink select foo from source;\nFAILED: Error in semantic analysis: line 1:23 Cannot insert into target table \nbecause column number/types are different sink: Cannot convert column 0 \nfrom struct<x:string> to struct<y:string>.\n\n{noformat}\n\nSince both {{soruce.foo}} and {{sink.bar}} are similar in definition with only field names being different, data movement between these two should be allowed. \n\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"122972","customfield_12312823":null,"summary":"Struct datatype should not use field names for type equivalence.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=aprabhakar","name":"aprabhakar","key":"aprabhakar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arvind Prabhakar","active":true,"timeZone":"America/Los_Angeles"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=aprabhakar","name":"aprabhakar","key":"aprabhakar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arvind Prabhakar","active":true,"timeZone":"America/Los_Angeles"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"Mac OS X (10.6.2) Java SE 6 ( 1.6.0_17)","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12460589/comment/12851075","id":"12851075","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zshao","name":"zshao","key":"zshao","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=zshao&avatarId=14358","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zshao&avatarId=14358","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zshao&avatarId=14358","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zshao&avatarId=14358"},"displayName":"Zheng Shao","active":true,"timeZone":"America/Los_Angeles"},"body":"I think we should support the following query:\n{code}\ninsert overwrite table sink select CAST(foo AS struct<y: string>) from source;\n{code}\n\nThis is better than directly converting them, because there can be confusions (There are 2 ways to convert from struct<x: string, y: string> and struct<y: string, x: string>, and Hive is taking one of them).\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zshao","name":"zshao","key":"zshao","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=zshao&avatarId=14358","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zshao&avatarId=14358","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zshao&avatarId=14358","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zshao&avatarId=14358"},"displayName":"Zheng Shao","active":true,"timeZone":"America/Los_Angeles"},"created":"2010-03-29T20:25:07.361+0000","updated":"2010-03-29T20:25:07.361+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12460589/comment/12851097","id":"12851097","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=aprabhakar","name":"aprabhakar","key":"aprabhakar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arvind Prabhakar","active":true,"timeZone":"America/Los_Angeles"},"body":"Thanks for your comment Zheng.\n\nI can see how the {{CAST}} would work, but believe that we need a stronger type checking semantic. Traditionally, a {{CAST}} is used to bypass compile time checks. While this is very powerful concept, it can lead to data corrpution if not used with caution.\n\nAn alternative to using the {{CAST}} approach would be to use compile time type checking without regard to the field names. This is similar to function signatures in say Java - where it does not matter what the parameter names are, as long as they are specified in the correct order. This can be achieved by thinking of field names as aliases for the datatypes of that field.\n\nFor example - the columns defined as {{struct < a : string >}} and {{struct < b : string >}} are type-equivalent because they are both of the type {{struct < ? : string >}}. \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=aprabhakar","name":"aprabhakar","key":"aprabhakar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arvind Prabhakar","active":true,"timeZone":"America/Los_Angeles"},"created":"2010-03-29T21:11:12.622+0000","updated":"2010-03-29T21:11:12.622+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12460589/comment/12851122","id":"12851122","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zshao","name":"zshao","key":"zshao","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=zshao&avatarId=14358","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zshao&avatarId=14358","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zshao&avatarId=14358","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zshao&avatarId=14358"},"displayName":"Zheng Shao","active":true,"timeZone":"America/Los_Angeles"},"body":"> Traditionally, a CAST is used to bypass compile time checks. While this is very powerful concept, it can lead to data corrpution if not used with caution.\n\nThe semantics of type equivalence as you mentioned is weaker than the current one. It can also lead to data corrpution if not used with caution.\nAsking users to use \"CAST\" is safer than implicitly treating struct<a:string> and struct<b:string> to be the same type.\n\nDoes that make sense?\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zshao","name":"zshao","key":"zshao","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=zshao&avatarId=14358","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zshao&avatarId=14358","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zshao&avatarId=14358","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zshao&avatarId=14358"},"displayName":"Zheng Shao","active":true,"timeZone":"America/Los_Angeles"},"created":"2010-03-29T21:50:54.069+0000","updated":"2010-03-29T21:50:54.069+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12460589/comment/12851166","id":"12851166","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=aprabhakar","name":"aprabhakar","key":"aprabhakar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arvind Prabhakar","active":true,"timeZone":"America/Los_Angeles"},"body":"I think I understand your point of view. Let me explain mine:\n\nRight now there is no consistent type checking. What we have is implicit type conversion where possible - such as converting a struct to string but not the other way around. In other places this implicit type conversion leads to internal error. In case of struct to struct conversion however the check is rigid to the field names. This is not consistent.\n\nMy suggestion is to provide type equivalence semantics within the query language framework. Doing this will help in the following ways:\n- Implicit type conversion would not be allowed and would require explicit CAST to convert to another type. \n- The query compiler would ensure that the data types are equivalent and therefore allow data to flow without having to invoke any UDF for every row. This should help us gain performance relative to the current approach.\n- Providing type equivalence checks will also be fundamental to building higher-level UD*Fs which would otherwise have to deal with cast semantics. \n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=aprabhakar","name":"aprabhakar","key":"aprabhakar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Arvind Prabhakar","active":true,"timeZone":"America/Los_Angeles"},"created":"2010-03-29T23:55:39.732+0000","updated":"2010-03-29T23:55:39.732+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12460589/comment/14502354","id":"14502354","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=Tagar","name":"Tagar","key":"tagar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10448","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10448","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10448","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10448"},"displayName":"Ruslan Dautkhanov","active":true,"timeZone":"America/Denver"},"body":"@Zheng, I don't get how implicit casting from struct<a:string> to struct<b:string> can cause data corruption. \nIt would be great to see this fixed in a future Hive release.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=Tagar","name":"Tagar","key":"tagar","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10448","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10448","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10448","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10448"},"displayName":"Ruslan Dautkhanov","active":true,"timeZone":"America/Denver"},"created":"2015-04-20T05:04:42.414+0000","updated":"2015-04-20T05:04:42.414+0000"}],"maxResults":5,"total":5,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HIVE-1287/votes","votes":2,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0lebz:"}}