{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13178729","self":"https://issues.apache.org/jira/rest/api/2/issue/13178729","key":"HIVE-20380","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310843","id":"12310843","key":"HIVE","name":"Hive","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310843&avatarId=11935","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310843&avatarId=11935","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310843&avatarId=11935","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310843&avatarId=11935"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":null,"customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Fri Aug 24 00:59:44 UTC 2018","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HIVE-20380/watchers","watchCount":1,"isWatching":false},"created":"2018-08-13T23:25:37.911+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12310230":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"0.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[],"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"customfield_12312337":null,"customfield_12312338":null,"updated":"2018-08-25T00:58:05.886+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":"Lately ORC CBs are becoming ridiculously small. First there's the 4Kb minimum (instead of 256Kb), then after we moved metadata cache off-heap, the index streams that are all tiny take up a lot of CBs and waste space. \r\nWasted space can require larger cache and lead to cache OOMs on some workloads.\r\nReducing min.alloc solves this problem, but then there's a lot of heap (and probably compute) overhead to track all these buffers. Arguably even the 4Kb min.alloc is too small.\r\n\r\nThe initial idea was to store multiple CBs per block, however this is a lot of work all over the place (cache mapping, cache lookups, everywhere in the readers, etc.). \r\nConsolidating and reducing allocation sizes after we know the \"real\" size after decompression is the new idea (see comments) that can be confined to the allocator and is also more flexible - no dependence on cache map, so we don't need to make sure stuff is contiguous and such (for example, R_I streams that we want to consolidate are interleaved with large bloom filters, that we don't want to read or consolidate when they are not needed - but cache key structure depends on offsets, so we'd need a new cache map for R_I and separate logic for these streams). Also streams like PRESENT with one small CB cannot be combined with anything realistically speaking, but shrinking the allocation will help them.\r\n\r\nThere are also minor heap improvements possible.\r\n1) Intern tracking tag.\r\n2) Replace AtomicLong object with a long and unsafe CAS method, we only ever use one method, compareAndSwap.\r\n\r\nOne more idea is making tracking less object oriented, in particular passing around integer indexes instead of objects and storing state in giant arrays somewhere (potentially with some optimizations for less common things), instead of every buffers getting its own object. \r\n\r\ncc [~gopalv] [~prasanth_j]\r\n\r\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"LLAP cache should cache small buffers more efficiently","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":null,"customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13178729/comment/16588243","id":"16588243","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"body":"Hmm, for ROW_INDEX actually boundaries cannot be made consistent for partial reads without decompessing the entire ROW_INDEX every time, because sizes of streams are not known in advance. Might require custom keys to put all row_index together and read bloom filters the normal way.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"created":"2018-08-22T02:01:17.713+0000","updated":"2018-08-22T02:01:17.713+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13178729/comment/16591009","id":"16591009","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"body":"After trying various approaches I think since this will anyway involve memory copying and interleaving buffers, what needs to happen instead is that we need to decrease allocation size after decompression. \r\nThat is much simpler than having a separate cache and consolidating CBs into a single buffer, doing partial cache matches, adding offsets to LlapDataBuffer-s, etc.\r\n\r\nOne issue is that, for small cache-wide table case, where the entire cache can become locked, it's not helpful to replace the fully locked cache of 128Kb buffers with 4Kb of data each, with 4Kb buffers sitting in cache every 128Kb. You still cannot get 128Kb. So, we'd have to move data. We will not have multiple CBs per the Java buffer object, but merely change allocations so small CBs don't use large cache buffers.\r\n\r\nIf we do this shrinking before putting data into cache, then unlike regular cache defragmentation, which is complex, we have a set of already locked buffers that are also invisible to anyone else, so we can trivially consolidate within all the buffers allocated by a read, that noone can touch in any way, and free up some large buffers completely and also some parts of the smaller buffers (e.g. if we have 10 ROW_INDEX streams, each with <4Kb of data, but sitting in 128Kb allocs because the ORC file CB size is 128Kb, we can create 10 4Kb buffers within one of those 10, and straight up deallocate 9 remaining 128Kb buffers, plus the 64Kb + 16Kb + 8Kb in the first one). We can also do an extra step (e.g. if we have a single 4Kb-of-data-128Kb-alloc) of allocating a small buffer explicitly (without defragmentation, and with a flag to not split buffers larger than the original for this - no point in creating a 4Kb buffer out of another 128Kb of empty space for this example), and copying there before deallocating the big one. That will be able to pick up all the crumbs created by other consolidations like the one above. Without splitting and retries the allocation can be cheap and safe.\r\nThis will be controlled by a waste threshold setting.\r\n\r\nUnfortunately this will do slightly less than nothing at all for Hive 2 without the defrag patch. But, if we backport the defrag patch (pending) this will also work for Hive 2.\r\n\r\nI may not be able to work on this to completion immediately so just posting a brain dump here for reference. cc [~gopalv]","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=sershe","name":"sershe","key":"sershe","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Sergey Shelukhin","active":true,"timeZone":"America/Los_Angeles"},"created":"2018-08-24T00:59:44.232+0000","updated":"2018-08-24T01:01:50.321+0000"}],"maxResults":2,"total":2,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/HIVE-20380/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i3x0cn:"}}