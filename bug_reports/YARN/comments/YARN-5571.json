[These query params preclude the need to query AppToFlowTable which means one less operation and hence a potentially faster query.
We currently do not maintain any state in reader i.e. App to flow mapping is not maintained so app to flow information is not available in cache., Just to elaborate further, we allow entities to be written from multiple clusters which can lead to a clash of Application IDs' (however unlikely as cluster timestamp is also used in App id).
This means that there can be potentially same AppID from 2 different clusters belonging to 2 different flows coming to us.
These query params if specified, will then help us to skip querying app to flow table., I believe design is made keeping in mind that federation support. But debatably with rarest scenario, what is app-id/user-id/flowname/flowurnid are same!!! Here cluster-id would come into picture. One one thing guarantee is cluster-id/namespace will be different. In the REST endpoints I see that cluster-id is null. 
There is slight differentiation with in the output of below required I believe
# GET /ws/v2/timeline/clusters/\{cluster name\}/apps/\{app id\} : Query for an App-id for an specified cluster-name in pathParam. Here, queryParam is not useful right? 
# GET /ws/v2/timeline/apps/\{app id\} : Query for an app-id for ALL the cluster from storage.

I would appreciate if you can point out me any flow-diagram/sequence-diagram for storage if any. , REST endpoints without clusters are just short URLs' for letting user query without cluster ID if the client from which query is made belongs to the same cluster where timeline service resides or if there is only one cluster. Here we will take cluster ID as value of RM Cluster ID configuration by default.

GET /ws/v2/timeline/clusters/{cluster name}/apps/{app id} : Query for an App-id for an specified cluster-name in pathParam. Here, queryParam is not useful right?
--> No, even here flow context information can be useful. When we are querying application, the table to be queried is Application table. The row key while querying application includes flow info as well because app belongs to a specific flow. But we do not make it mandatory. Because we keep a mapping from {{app+cluster=>userid, flow,flowrun}} in app to flow table.
When a query arrives without flow info in query param, we will first look into AppToFlow Table to find out flow context info based on app and cluster ID. And then use this info to finally query application table. If flow context info is specified via query params, we do not need to query app to flow table. 

GET /ws/v2/timeline/apps/{app id} : Query for an app-id for ALL the cluster from storage
--> No. This means query for an app assuming cluster is the same as the one in which ATS is running.

For more info on the REST APIs', refer to ATSv2 documentation. We have a PDF attached in YARN-5174 which contains the latest documentation.
You can also refer to HBase Schema attached in YARN-2928., Hi [~varun_saxena],
So IIUC, *GET /ws/v2/timeline/apps/\{app id\}* is sufficient and passing the additional param information (flowName, flowRunId, userId) is like optional to speedup the query which is also captured effectively in the REST documentation. But only thing being REST API is not much intuitive without understanding the Hbase storage structure.
After referring to code and the document [ATSv2BackendHBaseSchemaproposal.pdf |https://issues.apache.org/jira/secure/attachment/12811223/ATSv2BackendHBaseSchemaproposal.pdf] mentioned in the  YARN-2928 for the Hbase storage structure, felt some modifications are required for it  like, 
# currently there are 5 tables but the doc shows 4 tables for hbase, 
# sample entity table in the doc shows to contain the app configuration which is not as per current plan, 
# Many places FLOWID is used instead of FlowNAME,
# Name of the tables seems to be different from the ones being used in the code
# Similar mappings present in each Table as present in the code to be present in the document too...

Not sure whether it would be ideal to capture these info in the ATSv2 documentation but better to get these captured as final ATSv2 HBASE Schema documentation  and attach it in YARN-2928, Thoughts ?


, The HBase Schema document I agree may not reflect all the changes as this corresponds to YARN-3411 and we did make some changes since then.
We can probably update this document to reflect the modification. Will be useful for YARN devs., IIUC, userId and flowId is optional as a optimization avoiding an extra call. And flowrunid is not at all even optional. Apps can be queried without flowrunid. API doc enforces to user to provide flowrinid which is not mandatory. This is because of HBase schema structure *clusterId!userName!flowName!flowRunId!AppId* where queries can be at flowName level.
{code}
userid - If specified, only entities belonging to this user will be returned. This query param must be specified along with flowname and flowrunid query params, otherwise it will be ignored. If userid, flowname and flowrunid are not specified, we would have to fetch flow context information based on cluster and appid while executing the query.
{code}

I think API doc improvement can be done., bq. userId and flowId is optional as a optimization avoiding an extra call. And flowrunid is not at all even optional.
Flow run id is required because application belongs to a specific flow run.

HBase Schema doc needs to be improved upon. Will be useful for developers who want to contribute and understand how data is stored. As of now to know the schema, you can refer to ***Table classes in application, flow, apptoflow and entity packages under {{org.apache.hadoop.yarn.server.timelineservice.storage}}.
[Link to code | https://github.com/apache/hadoop/tree/trunk/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage], If we have to support fetching all the apps within a cluster, upto a limit, this currently is not advisable as it would lead to a full table scan. Because the API guarantees returning entities in a descending order by created time.

We can discuss further if we have a strong use case for this.
, bq. support fetching all the apps within a cluster, upto a limit, this currently is not advisable as it would lead to a full table scan. Because the API guarantees returning entities in a descending order by created time.
The JIRA YARN-5561 is focusing on /apps, /app-attempt and /containers. We can discuss particular point i.e retrieving full cluster apps can be discussed there. 

As far as this JIRA concern, I understand that userId/flowName/flowrunId are filters for faster query. If there is any improving API documentation JIRA exist already then I will close this JIRA else this can be used to improve the documentation. I am open to either of the choices., Ok...
We can have discussion on REST endpoints on YARN-5561 and do documentation changes here. There is no open JIRA for documentation change.
, As per the discussion, these params are for faster look up of entities. So, resolving as wont fix. Thanks Varun for clearing doubts!!]