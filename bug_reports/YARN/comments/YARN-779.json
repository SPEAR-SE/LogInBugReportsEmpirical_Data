[It may be that if a ContainerRequest has been partially allocated and it is remove the count goes also out of synch., Can you please explain the erroneous scenario a bit more? I understand how the state of table 1 is created, but I am wondering which method call exactly changes the state to what depicted in table 2. The only public methods that manipulated the state are addContainerRequest and removeContainerRequest, which none seems to be able to perform such state transformation., Table 2 reflects the state on the RM, which is updated whenever a container is allocated (see AppSchedulingInfo.java)., Thanks [~sandyr]. Let me run by you my understanding of the problem, to ensure that we are on the same page. The reported erroneous scenario could be addressed by reseting the outstanding requests at RM, whenever ANY gets 0. The actual problem, however, still remains since the AMRMClient receives a ContainerRequest and decomposes it into independent ResourceRequests. The information about the disjunction between the requested resources is, thus, not available at RM to properly maintain the list of outstanding requests. Building on top of the original example, here is the erroneous scenario:

{code}
@AMRMClient
ContainerRequest(..., {node1, node2}, ..., 10)
ContainerRequest(..., {node3}, ..., 5)
{code}

The internal state at RM will be:

{code}
@AppSchedulingInfo
Resource  #
-------------
node1    10
node2    10
node3    5
ANY      15
{code}

In other words, the original request of "(10*(node1 or node2)) and 5*node3"  could be interpreted in different way such as "10*node1 and (5*(node2 or node3))". If my understanding is correct, then solution lies in changing the API between AM and RM, to also send the original disjunction between the requested resources. We then need to change the AppSchedulingInfo to properly maintain the added information. Does this makes sense?

, [~maysamyabandeh], I follow you until the end.  What API changes do you have in mind? i.e. what would be required to send the disjunction between requested resources that is not available now?, The MR AM has solved this problem purely on the AM side (can't remember the JIRA number, but I'll post it when I find it), so I think it should be possible to do this without changing the RM or the AMRM protocol.  The basic issue is that, when a container is given to the app, we need to associate it with a ContainerRequest so that we can cancel the right resource requests.  In general, the AMRMClient cannot automatically perform this association.  Consider a situation where an app needs two tasks, one on node1 or node2, and one on node2 or node3.  When the app receives a container on node2, it will assign it to one of these tasks, but only the app knows which task it is assigning it to.  So we need some sort of API for the app to communicate this knowledge to the AMRMClient., That API is AMRMClient.removeContainerRequest()., Ah, I misunderstood how removeContainerRequest works.  That gets rid of my concerns., The attached patch includes a unit test that shows how the bug manifests in the discussed erroneous scenario. If we are going to go for the suggested solution of changing API between AM and RM, perhaps it would be better to open a new jira with a more descriptive title., Fixed the test case with correct setting for relaxedLocality., I am thinking perhaps we can solve the problem without needing a complete change in the API. Since we are using Protocol Buffers, we can freely add new fields to the message.

What we need is a way to express in a set of ResourceRequests the disjunction between the requested containers in ContainerRequest. For that we can use a locally unique resourceRequestId generated by the AMRMClientImpl.java. For example if application requires one container in (node1 || node2), #addContainerRequest decomposes it into two ResourceRequests but tagged with the same resourceRequestId. 
* ResourceRequest(node1, id1234);
* ResourceRequest(node2, id1234);

Later, when the ResourceManager services a ResourceRequest with ID id1234, it can update all other corresponding ResourceRequests from the same application with the same ID of id1234. Thanks to Protocol Buffers, there will be no inconsistency between old/new clients with new/old servers.

Feedbacks are appreciated., Submitting patch on behalf of [~maysamyabandeh].

[~maysamyabandeh] in future, pls mark the issue as "Patch Available" by hitting the "Submit Patch" button. Thanks!, Sure [~acmurthy]. Note taken for other jiras. But the current jira is still in the brainstorming phase and the attached patch is just a unit test showing the problem.]