[Pids might get reused. so we need to guard against that.
Is there any generic Linux OS mechanism that would make the running containers die when the NM dies? e.g. On Windows, NM can use JobObject's to make this happen., I don't think there is a built in way to do this on Linux/Unix, but I could be wrong.  You also have to take into account the fact that the original process (PID) may spawn off other processes that need to be killed as well (like Streaming).  The best way I can think of to do this is to save the PID the process group ID and the user that launched that PID.  If the pid is still running then and it is part of the same process group and owned by the same user, shoot it.

We should also make sure that it is pluggable.  This is because once we switch over to using Linux Containers, VMs, or some other form of isolation we can more easily tell which processes are part of that group, and shoot them., [~kihwal] also mentioned to me that we could do a best effort in a JVM shutdown hook, and then have this as a backup for anything that we were not able to kill, which seems very reasonable. , The objective here is to only cover the cleanup during startup? If so, then this issue should be a subtask of YARN-72, as it covers cleaning up containers before shutdown and also during startup., Clarification for previous comment: YARN-72 only covers killing of containers on shutdown., With YARN-495 in, we changed NM reboot behaviour to be a simple resync - kill all containers and re-register with RM.

So in sum, YARN-72 cleans up containers on shutdown, YARN-495 does so on resync. 

There is still case when operator issues a shutdown but because NM_SLEEP_DELAY_BEFORE_SIGKILL_MS + NM_PROCESS_KILL_WAIT_MS + SHUTDOWN_CLEANUP_SLOP_MS is not enough to cleanup all containers. We can make the later configurable or can mandate operators to kill containers explicitly in that case.

Closing this as a duplicate.]