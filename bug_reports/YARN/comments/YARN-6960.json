[I'd be curious to understand the use case where you're running into this issue. My main concern which that fix is that an app that's entering an inactive queue will not be able to preempt its way into running. In your example, assume we kill the jobs in root.a and root.b, so that the apps in root.c and root.d share the cluster 50/50.  Now we submit a new app to root.a. Since all we have is an AM until the AM can run and request other containers, root.a's fair share will remain 0, and the app in root.a will never be able to preempt the apps in root.c or root.d., Yep, that concern is definitely valid. I wrote a patch that implements this definition of activity, and ran into exactly the problem you're describing while testing it. A new proposal then would be that a leaf queue is active if either of these conditions is met:

* There is at least one non-AM container running in the queue
* The cumulative demand of applications in the queue is greater than zero

That way, in the example you give above, the fair share of {{root.a}} becomes 1/3 as soon as it attempts to run another job.

Backing up a step to the use case, we have interactive Spark applications the expectation for which is that results are returned to the user on the order of seconds, or at worst a few minutes (assuming that the query is reasonable). We don't want to have to create a new {{SparkContext}} and upload + localize JARs for each query, since that would inflate query execution time, so one of these applications will keep the same {{SparkContext}} around indefinitely, and will thus be a long-running YARN application. When one of these apps isn't running any queries/jobs, it'll scale down its executor count to make room for other YARN applications. So sometimes we wind up with multiple YARN applications with minimal resource usage and no demand, and we've observed that this causes unequal distribution of resources between other running applications, even though they're in equally weighted queues. The example in the description is kind of silly/simplistic, but it's essentially what we see happen., [~daniel@cloudera.com], I've uploaded a patch proposing a new definition of queue activity. It also needs tests, but I wanted to first see how the community feels about this change, and revise it as necessary based on feedback before writing tests for it.

My understanding of a queue's demand is that it's the cumulative current usage of all apps in the queue plus the cumulative requested additional resources for all apps in the queue. Therefore if no apps are requesting additional resources, the demand will be equal to the usage of the AMs. Then, as soon as any app attempts to do anything, it's demand will be greater than the AM usage, and the queue will become active.

I've tested this patch and it seems to have the desired effect. Going back to the example in the description, {{root.c}} and {{root.d}} have equal fair shares despite the idle applications in {{root.a}} and {{root.b}}., Attaching a slightly modified patch that sets the fair share of an inactive queue equal to its current utilization. This doesn't change the behavior for queues with no running applications, since the fair share before the patch and with the patch are both equal to zero. It does protect AM containers in queues that are inactive by the new definition from being preempted though, since queues containing those AMs are no longer over their fair shares., I'll take a look when I get a chance., Thanks, Daniel. Having thought about this some more, I don't think that either of the two patches I've posted is a good solution. In the first patch, inactive queues have fair shares of zero, and AM containers are subject to preemption even when running in high-priority queues. And in the second patch, applications running in idle queues define what their fair shares are irrespective of cluster-side settings, which doesn't make sense.

I'll think about this some more and try to come up with a better idea, but I'd also be quite interested in hearing your opinion and those of others. ]