[The expired transition occurs when the application expires, i.e.: is misbehaving and not responding properly with heartbeats.  Are you sure the application is expiring?  If it is then we should see something like a "Timed out after ## secs" message in the RM log.  I don't see that in the above log or other evidence that indicates it is expiring, but maybe that occurred earlier in the RM log.

Similarly I don't see any evidence of the AM unregistering from the RM.  That may have occurred earlier in the RM log than what is shown above, but if it did not then that would explain why the application is marked as failed.  An AM container can exit with a success code for its container, but if it fails to unregister first then the container exit code is irrelevant., No, its not expiring. its finishing with CONTAINER_FINISHED event and that is when this transition to FAILED occurs.
You can easily reproduce it by modifying one of the existing tests:
_TestAMRMClient_ â€“ just change command from "sleep 100' to "ls -a" and you'll see the same SUCCESS turning into FAILURE ;), bq. No, its not expiring.

If it's not expiring, then how is ExpiredTransition entering the picture?  According to the state machine setup, it should only be executing this when the EXPIRE event arrives, and it should only be sending that when it logs the timeout message I indicated earlier.  My apologies if I'm missing something.

As for TestAMRMClient, "sleep" or "ls" will make terrible ApplicationMasters since they will neither register nor unregister, and that should never result in a successful application run.  The only reason this test works with "sleep" as the AM is because the test relies on the fact that the command launched won't exit before it can emulate the registration/unregistration in the various test cases directly.  By changing the "sleep" to "ls" the command finishes so quickly that the test method doesn't get a chance to try to emulate a proper AM by registering -- the container is gone too soon.  If you add a testcase that simply waits for the application to complete on its own rather than trying to emulate an AM then you'll find that even sleep, like ls, will always result in failure., Got it, thanks.

Again, the real issue is the API which does not help at all. If I could submit any command then I should expect the lifecycle to be handled by the framework. That didn't happen and once again steered me in the wrong direction. Would be much nicer if there was a strategy with default implementation of lifecycle methods while exposing an override. This way even an arbitrary command emulating AM would be managed.
Anyway, I'll try to compile a more comprehensive feedback, but at the moment I got everything running in both local mini cluster and real cluster and while I still believe its an issue, feel free to change it to feature, enhancement or . . .
Certainly seems to be far more complex then it really has to be., bq. Again, the real issue is the API which does not help at all. If I could submit any command then I should expect the lifecycle to be handled by the framework.

While the ApplicationSubmissionContext allows an free-form command to be listed to run as the AM, that doesn't mean that just any command listed there will work.  YARN is not a distributed shell capable of running arbitrary shell commands as applications.  (The DistributedShell example application in YARN is closer to this.)   Each application must provide an ApplicationMaster that properly communicates with the RM via the ApplicationMasterProtocol in order to participate within a YARN cluster.

I'm sorry that you expected arbitrary shell commands to work in an ApplicationSubmissionContext, and the TestAMRMClient code is a terrible example of a proper YARN application.  Indeed, it doesn't even run properly without "help" from the test methods to emulate what a real AM must do.

Resolving this as Invalid since YARN applications do not always exit as FAILED and applications are not normally going through ExpiredTransition within the RM.  If you have followup concrete suggestions for how to make the AM-RM API better beyond what the AMRMClient abstraction already does that would be great.  Feel free to discuss them on the [yarn-dev@|http://hadoop.apache.org/mailing_lists.html#Developers-N10174] list or under a separate JIRA.]