[I have been working on an API design doc for a while. I am assigning this to myself. Will upload a first draft of the document., Attached is the first pdf draft (20160603) of the higher order API specification for YARN services.

An HTML version is also available here - 
http://home.apache.org/~gourksaha/YARN-4793/20160603-YARN-Simplified-V1-API-Layer-For-Services.html

Thanks to [~vinodkv], [~sidharta-s], [~vvasudev], [~billie.rinaldi] and [~kkaranasos] for contributing to and/or performing extensive reviews of the specification.

The source of the specification is in Swagger format and JSON examples are in asciidoc format (both uploaded to this JIRA). I used the [swagger2markup-cli|https://github.com/Swagger2Markup/swagger2markup-cli] utility to auto generate the pdf and html.

Few points to keep in mind while reviewing the document -
- Application name is a unique identifier for a specific user. It is more user-friendly and easy to remember than the YARN application identifier.
- Few of the advanced features referred to in the spec is still in the works like – Placement Policy (YARN-4902), Cluster/Docker networking (YARN-4007)
- Readiness check for containers and service needs architectural proof of concept

I have an early prototype of the REST API Service, implemented against this API spec. It is built on top of Apache Slider and uses slider-core as a dependent module. If there is consensus on the spec, I can submit a patch., First version of REST API service implementation based on swagger specification, Thanks Gour ! some comments I have on the patch:

*API Models*
- {artifact, resource, launch_command, number_of_containers} in Application seems duplicated with those inside the component. I feel in this scenario, a default global setting for artifacts, launch_command etc. is not that appropriate,  different components may likely have different requirements. IMHO, we only need the ones in Component, this makes the interface cleaner and underlying implementation simpler?
- unique_component_support: what is the primary use-case to have distinct component name ?
- What is the BaseResource object for? Why does Application, ApplicationStatus, Container, Resource need to extend this class?
- What does the Artifact#APPLICATION mean ?
- ApplicationState: What is difference  RUNNNG vs STARTED, FINISHED vs STOPPED
{code}
ACCEPTED, RUNNING, FINISHED, FAILED, STOPPED, STARTED;
{code}
- Application#lifetime: it is String type. Does this mean we have to define a scheme for user to specify the time in string format? How about just using long type ?  
- ApplicationStatus#errorMessage, how about call it diagnostics ? sometimes we may also return non-error messages.

*Implementation*
- “hadoop-yarn-services-api” should be under hadoop-yarn-slider module as peer to hadoop-yarn-slider-core
- why the changes needed in hadoop-project/pom.xml 
- We should not use a deprecated getPort() method {{logger.info("Listening at port = {}", applicationApiServer.getPort());}}, jenkins will report error.
- couple of things for below code
{code}
HADOOP_CONFIG = getHadoopConfigs(); 
SLIDER_CONFIG = getSliderClientConfiguration();
{code}
-- We cannot load hdfs config, that's for hdfs servers. Any reason you need the hdfs configs?
-- Instead of calling these two methods, I think we can just call {{YarnConfiguration yarnConf = new YarnConfiguration()}}. This will automatically load the yarn-site and core-site configs.

- Why do we need to explicitly call initHadoopBinding, which is already called the super.init() previously.
{code}
    SliderClient client = new SliderClient() {
      @Override
      public void init(org.apache.hadoop.conf.Configuration conf) {
        super.init(conf);
        try {
          initHadoopBinding();
        } catch (SliderException e) {
          throw new RuntimeException(
              "Unable to automatically init Hadoop binding", e);
        } catch (IOException e) {
          throw new RuntimeException(
              "Unable to automatically init Hadoop binding", e);
        }
      }
    };
{code}
- These two catch clauses are identical, and Exception extends Throwable, so we only need catch Throwable, if that's desired. 
{code}
    } catch (Exception e) {
      logger.error("Unable to create SliderClient", e);
      throw new RuntimeException(e.getMessage(), e);
    } catch (Throwable e) {
      logger.error("Unable to create SliderClient", e);
      throw new RuntimeException(e.getMessage(), e);
    }
{code}
- This will never return null, because the numberOfContainers is intialized as 1. you might want to check zero ?
{code}
      // container size
      if (application.getNumberOfContainers() == null) {
        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);
      }
{code}
- The lifetime field will never be null, because it is  intilized as "unlimited" by default
{code}
    // Application lifetime if not specified, is set to unlimited lifetime
    if (application.getLifetime() == null) {
      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);
    }
{code}
- IIUC, all these code are not needed, because appOptions is only used for logging, uniqueGlobalPropertyCache is not used logically, Python is not required any more in yarn-slider
{code}
    if (application.getConfiguration() != null
        && application.getConfiguration().getProperties() != null) {
      for (Map.Entry<String, String> propEntry : application.getConfiguration()
          .getProperties().entrySet()) {
        if (PROPERTY_PYTHON_PATH.equals(propEntry.getKey())) {
          addOptionsIfNotPresent(appOptions, uniqueGlobalPropertyCache,
              SliderXmlConfKeys.PYTHON_EXECUTABLE_PATH, propEntry.getValue());
          continue;
        }
        addOptionsIfNotPresent(appOptions, uniqueGlobalPropertyCache,
            propEntry.getKey(), propEntry.getValue());
      }
    }
{code}
- In agent-less world, the status command is probably not required. We need a different mechanism to determine container status. let's remove this for now
{code}
    appConfOptTriples.addAll(Arrays.asList(compName, configPrefix.toLowerCase()
        + ".statusCommand", DEFAULT_STATUS_CMD));
{code}
- remove the unused parameter globalConf in createAppConfigComponent
- remove unused method createAppConfigGlobal
- remove the commented out code in this class, there are quite a few places
- Can you please explain what this code tries to accomplish ? it's hard to understand what it tries to do.
{code}
    List<String> convertedDeps = new ArrayList<>();
    for (String dep : component.getDependencies()) {
      if (compNameArtifactIdMap.containsKey(dep)) {
        convertedDeps.add(compNameArtifactIdMap.get(dep));
      } else {
        convertedDeps.add(dep);
      }
    }
    if (hasPropertyWithValue(component, PROPERTY_DNS_DEPENDENCY, "true")) {
      if (component.getArtifact().getType() == Artifact.TypeEnum.APPLICATION) {
        convertedDeps.add(component.getArtifact().getId());
      } else {
        convertedDeps.add(compName);
      }
    }
    if (convertedDeps.size() > 0) {
      appConfOptTriples.addAll(Arrays
          .asList(compName, "requires", StringUtils.join(convertedDeps, ",")));
    }
{code}
- The lifetime is tied to the application according to the API, why does it need to pass down to every component? IIUC, the flow should be, once the app timeouts, all components for this app timeout.
{code}
          // set lifetime only to one component - chose whichever comes first
          if (firstComponent) {
            appCompOptionTriples.addAll(
                createAppConfigComponent(comp.getName(), comp, comp.getName(),
                    lifetime, globalConfig, null, compNameArtifactIdMap));
            firstComponent = false;
          } else {
            // TODO: Make lifetime non-null for now (avoid throwing exception)
            appCompOptionTriples.addAll(
                createAppConfigComponent(comp.getName(), comp, comp.getName(),
                    null, globalConfig, null, compNameArtifactIdMap));
          }
{code}, As this Jira targets to build a unified interface, I'd like to share some thoughts related to the resource modeling part. The core of Yarn is still to map the resource and workload. For the resource modeling proposed in YARN-3926, it extends the current Yarn static resource modeling to be a flat resource modeling. The end user has the potential to define/schedule their own resource. I am considering whether we should do further extension to make the resource modeling to be a hierarchy based modeling. The use case I see for future is the heterogenous environment with different hardware accelerators (GPU, Intel Xeon Phi, FPGA, etc). For example, if you treat one GPU as a unit of special resource, the flat resource modeling is good enough. But we are seeing cases that GPU to be shared between applications, even the application prefer to allocate certain range of memory inside GPU to avoid cache rotation issue. In this case, it's hard for scheduler to handle. There is relationship between resource (just like the relationship between applications in Slider). Scheduler must allocate GPU memory and GPU core on the same GPU. 

If we do have vision to cover more complicate environments with Yarn, maybe it's time to consider further extension on the resource modeling together with Slider integration and unified service API., [~gsaha] / [~jianhe], can we please move this initial patch to a sub-task under this JIRA? That way, as you keep making more progress on other items, each of them can be their own sub-tasks. Thanks!, [~grey] - you raise some interesting points on scheduling. I see you've left a similar comment on YARN-3926. Let's continue the discussion there(since it seems to be the more relevant ticket)., Uploading a revised version of the REST API service swagger specification, based on code reviews in YARN-5610, Uploading a minor revision to the REST API service swagger specification, and reflecting changes (including some of the older missed ones) to the examples asciidoc file. 

Generated a new pdf and html out of the yaml spec and examples asciidoc and uploading them as well (note, we use swagger2markup to autogenerate them).
, The html version is here - http://home.apache.org/~gourksaha/YARN-4793/20161207-YARN-Simplified-V1-API-Layer-For-Services.html, Branch is merged to trunk, resolve this, Removing assignee for this group effort.

Thanks to everyone who contributed to this useful feature!]