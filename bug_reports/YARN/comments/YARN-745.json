[+1 for this,
My idea is we can move the major functionality of UnmanagedAMLauncher to YarnClient.submitApplication. When an application is marked unmanaged in ApplicationSubmissionContext, user doesn't need set applicationId field in ApplicationSubmissionContext, and submitApplication() will 1) createApplication 2) wait for application accepted by RM 3) handle AM tokens, etc.
After submitApplication(), user can directly use AppliationMasterProtocol. It will be easier for users develop/debug AM. Because AM and client will be placed in a same process.
Currently UnmanagedAMLauncher will create a separated process for AM, which will be harder for debugging, etc.
Any thoughts on this?, That was the original plan of action for the unmanaged AM launcher. Its just specialization of yarnclient. Under a flag yarn client impl should be able to submit an unmanaged AM. However, running in-process or forking a new process should also be possible. Running in-process would be easier for debugging. Launching a separate process works for cases where people want to run their app in unmanaged mode (eg LAMA AM) Also when one already has an AM in jar then one could launch it in a process with java opts to enabled debugging instead of writing code to invoke YARNClient in unmanaged mode inside the AM., Thanks, if so, Hamster can leverage this to do some AM implementation/verification, etc. Would you mind me to take this Jira?, Sorry for late response. Please go ahead in case you havent already., Thanks! I haven't started yet, I'll start to do it later., Would this be backwards incompatible? [~vinodkv] [~kkambatl], I think it's still backwards compatible, in past, user has two ways to submit a unmanaged AM,
1) Submit by UnmanagedAMLauncher
2) Use YarnClient, first get a new app id, then submit app
As I commented, 
{quote}
When an application is marked unmanaged in ApplicationSubmissionContext, user doesn't need set applicationId field in ApplicationSubmissionContext, and submitApplication() will 1) createApplication 2) wait for application accepted by RM 3) handle AM tokens, etc.
After submitApplication()
{quote}
It's more like an extend to existed API, if we don't remove the UnmanagedAMLauncher (just leverage its code in yarn client), users can still use the previous two methods to submit an unmanaged AM., I would think moving classes between packages will be backwards compatible as long as the canonical class name remains the same. All yarn jars are added to the classpath, and the user shouldn't notice any difference. The dependencies for a project might change, but the binaries built against an older version should continue to work. ]