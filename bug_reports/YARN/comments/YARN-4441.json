[Hi [~mohdshahidkhan]
This is intentional. If application state is Final State stored, we will not return any error as its going to finished/completed immediately.

I am not really sure this is what you were also expecting. Kindly share details otherwise., If an application is already finished, then the killing the application does does not make any sense.
From UI we can call the kill operation and that event is logged as below.
And in the audit log we are getting the success message for the operation Kill Application Request is successful.

in the below code the problem is there at the first if check. 
Suppose application_xyz is already finished and when the kill request will come the target state will be KILLED and actual will be finished, the first if check will be true. 
Second if check also will be true as the target is KILLED and killApp method will be called and same will log the 
 USER=dr.who	OPERATION=Kill Application Request	TARGET=ClientRMService	RESULT=SUCCESS	APPID=application_xyz  | RMAuditLogger.java:91
 USER=dr.who	OPERATION=Kill Application Request	TARGET=RMWebService	RESULT=SUCCESS	APPID=application_xyz  | MAuditLogger.java:91

{Code}
 if (!app.getState().toString().equals(targetState.getState())) {
      // user is attempting to change state. right we only
      // allow users to kill the app

      if (targetState.getState().equals(YarnApplicationState.KILLED.toString())) {
        return killApp(app, callerUGI, hsr);
      }
      throw new BadRequestException("Only '"
          + YarnApplicationState.KILLED.toString()
          + "' is allowed as a target state.");
    }
{Code}

I think we should not allow to call the killApp if the application is already finished., hi [~mohdshahidkhan]
I still not very much liking the idea of throwing some new exceptions in this context.
There were a series of discussions happened in YARN-107 for same, and as per a common consensus this current approach is taken [YARN-107:comments|https://issues.apache.org/jira/browse/YARN-107?focusedCommentId=13720845&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13720845]. In my opinion, user wants to kill application due to some potential reason and that operation's intend  is to bring down the app. So if the app is in its final states, then its clearly fine that app will be shutdown. So throwing a new exception is not much needed. 
Coming to audit log, we have only success and failure in auditlog. And here we have the operation result as success eventhough kill doesnt happen (app is already finished/completed). So writing failure audit log is in-appropriate. Hence I think if needed, we can try to improve audit log success message to have some custom input which can give some details here. cc/[~rohithsharma] Thoughts?, May be audit log can be changed to appropriate log message. But nevertheless of any points, this would lead to compatibility issue. I would prefer to keep it as-it-is!!, Thanks [#Sunil G] and [#Rohith Sharma K S] for the analysis.
Have discussed the same with  [#Rohith Sharma K S] and  want to clarify that  we do not want to throw the new exception just want the avoid the killApp call in case the application's state is already stored in the app store.

In RMWebServices updateAppState API 
//currentlty we are ignoring the killAPP call for the application which are already killed.
{code}
if (!app.getState().toString().equals(targetState.getState())) {
      // user is attempting to change state. right we only
      // allow users to kill the app

      if (targetState.getState().equals(YarnApplicationState.KILLED.toString())) {
        return killApp(app, callerUGI, hsr);
      }
      throw new BadRequestException("Only '"
          + YarnApplicationState.KILLED.toString()
          + "' is allowed as a target state.");
    }
   {code} 
 #My proposal is to ignore the call also for the applications whose state's are stored to the application store.
    
    {code}
if (!app.getState().toString().equals(targetState.getState()) && !(app.isAppFinalStateStored())) {
      // user is attempting to change state. right we only
      // allow users to kill the app

      if (targetState.getState().equals(YarnApplicationState.KILLED.toString())) {
        return killApp(app, callerUGI, hsr);
      }
      throw new BadRequestException("Only '"
          + YarnApplicationState.KILLED.toString()
          + "' is allowed as a target state.");
    }
{code}, [~mohdshahidkhan] - Why shouldn't the logic you're proposing apply to RPC calls as well?, No handling needed for the RPC calls, the API already has the handling, ClientRMService.forceKillApplication() is skipping the the kill event if the application is in store state, our intention is to avoid the the ClientRMService.forceKillApplication() call from the RMWebService if the application's state is stored to application store., Why? The reason the webservice implementation calls the RPC function is to avoid having different logic between the two. If the RPC implementation decides to log the call in the audit log then that logic applies to the webservices side as well. I agree with [~sunilg] and [~rohithsharma] - this doesn't seem like an issue., Hi [#Varun Vasudev] why to send the kill request if the application is already finished?

Please check the ApplicationCLI killApplication API , we have similar check before invoking the RPC call to  kill the app.

{Code}
 if (appReport.getYarnApplicationState() == YarnApplicationState.FINISHED
        || appReport.getYarnApplicationState() == YarnApplicationState.KILLED
        || appReport.getYarnApplicationState() == YarnApplicationState.FAILED) {
      sysout.println("Application " + applicationId + " has already finished ");
    } else {
      sysout.println("Killing application " + applicationId);
      client.killApplication(appId);
    }
{Code}, That's a performance optimization for the RPC client - it avoids a RPC round trip. There's nothing stopping you from writing a YARN client without that check. The equivalent to the CLI code you posted would be to grey out the button on the web UI if the application is finished(which is a patch I'd be ok with).]