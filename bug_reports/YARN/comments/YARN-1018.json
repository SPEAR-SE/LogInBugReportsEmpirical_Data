[{code}
java.lang.IllegalArgumentException: Can't turn off locality relaxation on a request with no location constraints
	at com.google.common.base.Preconditions.checkArgument(Preconditions.java:88)
	at org.apache.hadoop.yarn.client.api.AMRMClient$ContainerRequest.<init>(AMRMClient.java:149)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
{code}

Looks to me like an extra {{!}} in the (complex) validator
{code}
      Preconditions.checkArgument(
              !(!relaxLocality && (racks == null || racks.length == 0) 
                  && (nodes == null || nodes.length == 0)),
              "Can't turn off locality relaxation on a " + 
              "request with no location constraints");
{code}

I think this probe should be skipped altogether. If someone asks for a relaxed priority and there no racks or nodes it should be downgraded to a no-op & not rejected.

, By setting locality relaxation to false, you're essentially saying "I want my container on these specific nodes and racks".  It doesn't make sense to say that and then not specify any nodes or racks.  My thinking was that it's better to fail and alert the user that what they're doing doesn't make sense than to silently not give them a container., OK, but there's a risk that an empty array has come from some feature (like the list of past containers), and that if the list is non-empty then that's because there were no past containers.

If it is rejected if the node list is empty, then you may end up coding
{code}
boolean strict = nodes.length! =0
new AMRMClient.ContainerRequest(capability, nodes, null, 0, !strict);
{code}, If I understand correctly, you're saying that someone might want to colocate containers with other containers that have already been scheduled, so the first can be anywhere, and the later ones need to be strictly on the same node(s) as the first.  While this is a situation that we should support, it seems to me that it should require the special handling that you're suggesting.  By the semantics of relaxLocality, the first request is expected to behave semantically differently than the ones that will come after it.  It is not a strictly local request, so setting the relaxLocality flag to false on it doesn't make sense.
, Actually I think I was just confused about what value to set when upgrading some code to 2.1 beta. I was trying to say 'dont care' on the request and it didn't work -which I felt was over strict.

For assigning a set of containers close to each other, I've opened YARN-1042, which is a more major piece of work, Ah ok cool.  In that case I'll close this and obviously feel free to reopen if you have further concerns., I'm re-opening this as it prevents containers without placement constraints being requested with the same priority as containers with restrictions. This check says "you can't flip the locality bit", while another check in the client says "you can't have different locality restrictions in the same priority"]