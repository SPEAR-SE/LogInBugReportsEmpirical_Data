[This is interesting. In general, user may not submit an application that asks for 50% of the whole cluster resources. It is possible that a cluster has more than 2 applications. If third application finishes, App2 can get enough resource and run. Then, "deadlock" breaks. Is this reasonable, [~venkateshrin] ?, I agree that apps that need the entire cluster capacity  are likely not common. However, I think the scenario above can happen in busy clusters where an app might make a request that exceeds _current_ capacity and hence block all other apps. Yes, whenever more resources get freed up and App1's request is satisfied, only then will App2 run. Note, since we are enumerating the set of active apps, the behavior is actually non-deterministic - if the new app happens to be enumerated before the large app, the allocation request will actually be satisfied. The change proposed here makes it deterministic and can also reduce the wait for jobs that can complete - the downside of course is the large app can now experience starvation if small apps keep getting through. , Possible duplicate of YARN-1631, I think we should fix this,
{code}
           if (!assignToQueue(clusterResource, required)) {
-            return NULL_ASSIGNMENT;
+            break;
           }
{code}
The {{return NULL_ASSIGNMENT}} statement means: if an app submitted earlier cannot allocate resource in a queue, the rest of apps in the queue cannot allocate resource in a queue too.

The {{break}} looks better to me.

And I agree this should be a duplicate of YARN-1631, Agree this is a duplicate of YARN-1631 ]