[We had them a long time ago, but moved them all to debug context as logs were getting inundated on reasonably large clusters.

If you can clarify what you mean by "per application lag", we can try adding that directly to app-metrics?, I saw all the debug code sitting in cap sched, but that's sort of the wrong layer as well.

We're basically trying to get a sense of how long container requests are hanging around for a given AM.  Today, we appear to log on either the failure or the success of the request.  But we don't log when the request was actually made.  I was thinking about pushing this into the audit log might be the way to go since it already logs the rest of the job life cycle., bq. We're basically trying to get a sense of how long container requests are hanging around for a given AM.
We have app and app-attempt metrics. We can simply capture the aggregate wait-time across all containers for an app, that works? A metric is better than the log IMO for your specific request., Metrics tend to require continual collection.  Aggregate is problematic because it assumes that all containers are have equal resource requirements.  , Log requests for containers from AM's.

The condition that !lastRequest.equals(request) protects the log from being spammed by repeated duplicate requests coming from AM heartbeats., Added patch for AppSchedulingInfo.updateResourceRequests, {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12680883/YARN-2806.patch
  against trunk revision 456b973.

    {color:red}-1 patch{color}.  Trunk compilation may be broken.

Console output: https://builds.apache.org/job/PreCommit-YARN-Build/5818//console

This message is automatically generated., {color:red}-1 overall{color}.  Here are the results of testing the latest attachment 
  http://issues.apache.org/jira/secure/attachment/12680883/YARN-2806.patch
  against trunk revision 163bb55.

    {color:green}+1 @author{color}.  The patch does not contain any @author tags.

    {color:red}-1 tests included{color}.  The patch doesn't appear to include any new or modified tests.
                        Please justify why no new tests are needed for this patch.
                        Also please list what manual steps were performed to verify this patch.

    {color:green}+1 javac{color}.  The applied patch does not increase the total number of javac compiler warnings.

    {color:green}+1 javadoc{color}.  There were no new javadoc warning messages.

    {color:green}+1 eclipse:eclipse{color}.  The patch built with eclipse:eclipse.

    {color:green}+1 findbugs{color}.  The patch does not introduce any new Findbugs (version 2.0.3) warnings.

    {color:green}+1 release audit{color}.  The applied patch does not increase the total number of release audit warnings.

    {color:green}+1 core tests{color}.  The patch passed unit tests in hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager.

    {color:green}+1 contrib tests{color}.  The patch passed contrib unit tests.

Test results: https://builds.apache.org/job/PreCommit-YARN-Build/5819//testReport/
Console output: https://builds.apache.org/job/PreCommit-YARN-Build/5819//console

This message is automatically generated., Looking at scheduler.AppSchedulingInfo (lines 141-146, trunk):

What is the significance of ResourceRequest.ANY, in terms of determining whether to LOG a ResourceRequest? Why only ResourceRequest.ANY?

Why is the ANY location the only one which can determine that "updatePendingResources = true"?

Are all updated resource requests from the AM initiated with a ResourceRequest at the ANY location? 

Can all allocate calls from the AM which do not include a ResourceRequest.ANY be considered followup requests to a previous initial request for those resources (e.g. by asking for less number of containers in the followup or by modifying preferred locations in the followup)?

{code:title=AppSchedulingInfo(141-146) |borderStyle=solid}
if (resourceName.equals(ResourceRequest.ANY)) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("update:" + " application=" + applicationId + " request="
              + request);
        }
        updatePendingResources = true;
{code}, [~EricWohlstadter] - Sorry, this patch has stayed unattended for a while.

Generally, as [~vinodkv] mentioned we try to not log resource requests since they fill logs in a massive way.

Regarding your question on {{ResouceRequest.ANY}}, the reason we use that condition as a metrics is that it's the only way the real resource requirements for the app (at that priority) changes - all other changes to hosts/racks etc. are tuning, they don't change the requirements of the app in a fundamental way. Makes sense? Thanks.]