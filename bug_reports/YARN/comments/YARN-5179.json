[[~Zhongkai], Perhaps the fix for YARN-5117 might be relevant here., @Arun, Thanks, I checked it. However, the vcoresUsed may not only be used in resource allocation, but in metrics and monitor too. I think the calculation of milliVcoresUsed should be fixed too : ), [~asuresh], given that YARN-5117 acknowledges that there is a problem with the way we calculated the CPU usage, I agree with [~Zhongkai] that we should revisit the way that milliVCores is computed in {{ContainersMonitorImpl}}. [~Zhongkai], could you upload a patch with your proposal to see if it makes sense?, I am interested in working on this. Can I take it forward?, I think ResourceUtilization.getCPU() has a similar sort of issue (i.e. it's difficult to interpret in cases where physical cores != vcores). Should we fix that here or in separate jira? Thoughts?
, bq. I think ResourceUtilization.getCPU() has a similar sort of issue (i.e. it's difficult to interpret in cases where physical cores != vcores). Should we fix that here or in separate jira? Thoughts?
Nevermind. I think physicalResource allows the RM to figure out how to properly interpret getCPU().
, [~asuresh]

While trying to reproduce this issue, seeing some values for milliVcoresUsed variable in recordUsage() method of ContainersMonitorImpl.java class. Also, I am seeing major code changes as part of https://issues.apache.org/jira/browse/YARN-4597. Hence, thought of confirming with you on this jira. Is this still valid?

Kindly let me know on how to proceed with this., [~manirajv06@gmail.com],

I think the issue is still valid and relevant. YARN-4597 has refactored things a bit, but the recordUsage() still exists in ContainerMonitorImpl, and is called by the MonitorngThread. Although, it is not currently used for scheduling decisions.. yet. Which would change once YARN-1011 lands.
, [~asuresh]

(edited with more details based on investigation)

Based on my understanding, resourceCalculatorPlugin.getNumProcessors() and maxVCoresAllottedForContainers difference cause this millivcores calculation issue. resourceCalculatorPlugin.getNumProcessors() simply holds of logical processors count. If a node has 4 logical cpu's, then getNumProcessors returns 4.

When yarn.nodemanager.resource.cpu-vcores is -1,

maxVCoresAllottedForContainers has values based on yarn.nodemanager.resource.count-logical-processors-as-cores property. If yarn.nodemanager.resource.count-logical-processors-as-cores is true, then maxVCoresAllottedForContainers is equal to resourceCalculatorPlugin.getNumProcessors(), otherwise, it differs. I am assuming yarn.nodemanager.resource.detect-hardware-capabilities has been enabled and yarn.nodemanager.resource.percentage-physical-cpu-limit is 100 in this case.

When yarn.nodemanager.resource.cpu-vcores is not equal to -1,

maxVCoresAllottedForContainers simply holds value of yarn.nodemanager.resource.cpu-vcores property. Since there is no validation in place, it can have any arbitrary no. (for ex, 100 etc)

Like Memory overflow limit, currently containers won't get killed when cpu usage exceeds. A container can use all the logical cores available in the node. Given this situation, I don't think using maxVCoresAllottedForContainers for millivcores calculation is correct as it can either lead to low or high cpu usage with respect to actual cpu usage when maxVCoresAllottedForContainers != resourceCalculatorPlugin.getNumProcessors().

Approach 1: Can we use actual vcores being used?

Instead of 

{code}float cpuUsageTotalCoresPercentage = cpuUsagePercentPerCore / resourceCalculatorPlugin.getNumProcessors();
int milliVcoresUsed = (int) (cpuUsageTotalCoresPercentage * 1000 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);{code}

Can we use this?

{code}float cpuUsageTotalCoresPercentage = cpuUsagePercentPerCore / resourceCalculatorPlugin.getNumVcoresUsed();
int milliVcoresUsed = (int) (cpuUsageTotalCoresPercentage * 1000 * resourceCalculatorPlugin.getNumVcoresUsed()/nodeCpuPercentageForYARN);{code}

Approach 2:

Instead of 

{code}float cpuUsageTotalCoresPercentage = cpuUsagePercentPerCore / resourceCalculatorPlugin.getNumProcessors();
int milliVcoresUsed = (int) (cpuUsageTotalCoresPercentage * 1000 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);{code}

Can we use?

{code}float cpuUsageTotalCoresPercentage = cpuUsagePercentPerCore / resourceCalculatorPlugin.getNumProcessors();
int milliVcoresUsed = (int) ((int) (cpuUsageTotalCoresPercentage * resourceCalculatorPlugin.getNumProcessors() * 1000)/100.0f);{code}

Please go through these above options and let me know your suggestions., [~asuresh]

I've updated my earlier comment with more details and described the possible solutions. Can you please take a look and provide your inputs?

Thanks, Thanks for the clarification, and apologies for the delay..
I am in favor of approach 1. [~kasha]/[~kkaranasos], thoughts ?, Thanks [~asuresh]. Added [~kasha] & [~kkaranasos] as watchers, just in case if they don't receive the email notifications., [~kasha]/[~konstantinos], any thoughts?, [~miklos.szegedi@cloudera.com] was looking into a similar issue very recently. Miklos - can you check if the proposals fix the issue that you were running into? , [~manirajv06@gmail.com], could you help me, what am I missing?

I ran a test and the numbers look right to me. Here is the code:
{code}
      float cpuUsagePercentPerCore = pTree.getCpuUsagePercent();
      float cpuUsageTotalCoresPercentage = cpuUsagePercentPerCore /
              resourceCalculatorPlugin.getNumProcessors();

      // Multiply by 1000 to avoid losing data when converting to int
      int milliVcoresUsed = (int) (cpuUsageTotalCoresPercentage * 1000
              * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);
{code}
And here are the values. I have 4 processors, and we use about 3 processors with our job. This is 75% of total CPU resources, so the first three numbers look right. I chose 8192 vcores in yarn.nodemanager.resource.cpu-vcores to have a very different number than the 4 cores. Then we prorate 75% to 8192 vcores, so we get about 6141 number of vcores, which is 6140747 millivcores. That sounds right. What would you expect in this case?
{code}
resourceCalculatorPlugin.getNumProcessors() = 4
cpuUsagePercentPerCore = 299.84116
cpuUsageTotalCoresPercentage = 74.96029
maxVCoresAllottedForContainers = 8192
nodeCpuPercentageForYARN = 100
milliVcoresUsed = 6140747
{code}
Approach #1 above would give us 3000, which is millirealcores. Why would we multiply and then divide by resourceCalculatorPlugin.getNumVcoresUsed()?
It is an interesting question though what metric is the most useful and simple from the user point of view. I think I like the 75% the most.
I think we have a documentation bug in yarn-default.xml, where we mention CPU cores here instead of vcores: 
yarn.nodemanager.resource.cpu-vcores	8	Number of CPU cores that can be allocated for containers., Thanks [~miklos.szegedi@cloudera.com] for your comments.

After my previous comment and proposals, had a offline discussion with [~naganarasimha_gr@apache.org] and was able to correct my understanding of vcores in general and especially by playing around with Default Container Executor & Linux container executor (with cgroups as well). 

Then, I ran a test with stress command (stress --cpu  4) to confirm my understanding about vcores with various possible options and compiled results in excel sheet. I've attached the same for reference. My box has 2 pcores and resourceCalculatorPlugin.getNumProcessors() is 4. Various Options are 

Using Linux container executor - 

1. Physical cpu limit is 100, Vcores is 2, Strict resource usage is false. cpuUsagePercentPerCore is 320 & Millivcores is 1600
2. Physical cpu limit is 100, Vcores is 4, Strict resource usage is false. cpuUsagePercentPerCore is 360 & Millivcores is 3600
3. Physical cpu limit is 50, Vcores is 2, Strict resource usage is false. cpuUsagePercentPerCore is 99 & Millivcores is 990
4. Physical cpu limit is 50, Vcores is 4, Strict resource usage is false. cpuUsagePercentPerCore is 98 & Millivcores is 1960

5. Physical cpu limit is 100, Vcores is 2, Strict resource usage is true. cpuUsagePercentPerCore is 100 & Millivcores is 500
6. Physical cpu limit is 100, Vcores is 4, Strict resource usage is true. cpuUsagePercentPerCore is 50  & Millivcores is 500
7. Physical cpu limit is 50, Vcores is 2, Strict resource usage is true. cpuUsagePercentPerCore is 50 & Millivcores is 500
8. Physical cpu limit is 50, Vcores is 4, Strict resource usage is true. cpuUsagePercentPerCore is 25 &  Millivcores is 500

Using Default Linux executor - 

Physical cpu limit is 100, Vcores is 200. cpuUsagePercentPerCore is 380 & Millivcores is 190000
Physical cpu limit is 50, Vcores is 200. cpuUsagePercentPerCore is 375 & Millivcores is 375000

Verified O/p of millivcores for each above option and its correctness with [~naganarasimha_gr@apache.org]. Initally, We had a doubt on our own understanding only when physical cpu limit is 50 and thought it should be half of the current millivcores, then we were able to reason it this way - for ex, in option 3, max utilization can go upto 200 because resourceCalculatorPlugin.getNumProcessors() is 2 (50% of 4 processors), but we got 99 as utilization. It means half of vcores should have been utilized, hence millivcores should be 1000 (approx). Based on these test results and our understanding, we don't see any issue with current calculation (like [~miklos.szegedi@cloudera.com] said in his comments).

Please correct me if you see any gap.]