{"expand":"renderedFields,names,schema,operations,editmeta,changelog,versionedRepresentations","id":"13103176","self":"https://issues.apache.org/jira/rest/api/2/issue/13103176","key":"YARN-7214","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype","name":"Bug","subtask":false,"avatarId":21133},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12313722","id":"12313722","key":"YARN","name":"Hadoop YARN","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12313722&avatarId=15135","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12313722&avatarId=15135","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12313722&avatarId=15135","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12313722&avatarId=15135"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10292","id":"10292","description":"Scalable Distributed Computing","name":"Hadoop"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12312322":null,"customfield_12310220":"2017-09-19T09:30:52.374+0000","customfield_12312520":null,"customfield_12312323":null,"customfield_12312521":"Tue Sep 19 09:30:52 UTC 2017","customfield_12310420":"9223372036854775807","customfield_12312320":null,"customfield_12310222":null,"customfield_12312321":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312923":null,"customfield_12312326":null,"customfield_12312920":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312921":null,"customfield_12312324":null,"customfield_12312720":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/YARN-7214/watchers","watchCount":2,"isWatching":false},"created":"2017-09-19T08:02:19.580+0000","customfield_12310192":null,"customfield_12310191":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.svg","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12313422":"false","customfield_12310310":"1.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12331976","id":"12331976","description":"2.7.1 release","name":"2.7.1","archived":false,"released":true,"releaseDate":"2015-07-06"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12340640","id":"12340640","name":"3.0.0-alpha3","archived":false,"released":true,"releaseDate":"2017-05-26"}],"issuelinks":[],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2017-09-19T09:38:19.054+0000","customfield_12312335":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"To Do"}},"components":[],"timeoriginalestimate":null,"description":"env: hadoop 2.7.1  with rm recovery and nm recovery enabled\ncase:\n spark app（app1） running least one container(named c1) in NM1.\n 1、NM1 crashed，and RM found NM1 expired in 10 minutes.\n 2、RM will remove all containers in NM1(RMNodeImpl). and  app1 will receive c1 completed message.But RM can not send c1(to be removed) to NM1 because NM1 lost.\n 3、NM1 restart and register with RM(c1 in register request)，but RM found NM1 is lost and will not handle containers from NM1.\n4、NM1 will not heartbeat with c1(c1 not in heartbeat request).  So c1 will not removed from context of NM1.\n5、 RM restart， NM1 re register with RM。And c1 will be handled and recovered. RM will send c1 complted message to AM of app1.  So, app1 received duplicated c1. \nonce spark AM   receive one container completed from RM, it will allocate one new container.\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12310320":null,"customfield_12312024":null,"customfield_12312340":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12887855","id":"12887855","filename":"screenshot-1.png","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"created":"2017-09-19T09:20:45.042+0000","size":59732,"mimeType":"image/png","content":"https://issues.apache.org/jira/secure/attachment/12887855/screenshot-1.png"}],"aggregatetimeestimate":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12312022":null,"customfield_12310921":null,"customfield_12310920":"9223372036854775807","customfield_12312823":null,"summary":"duplicated container completed To AM","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"subtasks":[],"customfield_12310291":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"environment":"hadoop 2.7.1  rm recovery and nm recovery enabled","customfield_12313520":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/13103176/comment/16171270","id":"16171270","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"body":"3. \n{code:java}\n public static class AddNodeTransition implements\n      SingleArcTransition<RMNodeImpl, RMNodeEvent> {\n\n    @Override\n    public void transition(RMNodeImpl rmNode, RMNodeEvent event) {\n      // Inform the scheduler\n      RMNodeStartedEvent startEvent = (RMNodeStartedEvent) event;\n      List<NMContainerStatus> containers = null;\n\n      NodeId nodeId = rmNode.nodeId;\n      RMNode previousRMNode =\n          rmNode.context.getInactiveRMNodes().remove(nodeId);\n      if (previousRMNode != null) {\n        rmNode.updateMetricsForRejoinedNode(previousRMNode.getState());\n      } else {\n        NodeId unknownNodeId =\n            NodesListManager.createUnknownNodeId(nodeId.getHost());\n        previousRMNode =\n            rmNode.context.getInactiveRMNodes().remove(unknownNodeId);\n        if (previousRMNode != null) {\n          ClusterMetrics.getMetrics().decrDecommisionedNMs();\n        }\n        // Increment activeNodes explicitly because this is a new node.\n        ClusterMetrics.getMetrics().incrNumActiveNodes();\n        containers = startEvent.getNMContainerStatuses();\n        if (containers != null && !containers.isEmpty()) {\n          for (NMContainerStatus container : containers) {\n            if (container.getContainerState() == ContainerState.RUNNING ||\n                container.getContainerState() == ContainerState.SCHEDULED) {\n              rmNode.launchedContainers.add(container.getContainerId());\n            }\n          }\n        }\n      }\n\n      if (null != startEvent.getRunningApplications()) {\n        for (ApplicationId appId : startEvent.getRunningApplications()) {\n          handleRunningAppOnNode(rmNode, rmNode.context, appId, rmNode.nodeId);\n        }\n      }\n\n      rmNode.context.getDispatcher().getEventHandler()\n        .handle(new NodeAddedSchedulerEvent(rmNode, containers));\n      rmNode.context.getDispatcher().getEventHandler().handle(\n        new NodesListManagerEvent(\n            NodesListManagerEventType.NODE_USABLE, rmNode));\n    }\n  }\n{code}\n\n4、 in NodeStatusUpdaterImpl.java\n      before register: getNMContainerStatuses will be called. So completedContainer will be put into recentlyStoppedContainers.\n      in register request: completed containers will be sent to RM.\n{code:java}\n  public void addCompletedContainer(ContainerId containerId) {\n    synchronized (recentlyStoppedContainers) {\n      removeVeryOldStoppedContainersFromCache();\n      if (!recentlyStoppedContainers.containsKey(containerId)) {\n        recentlyStoppedContainers.put(containerId,\n            System.currentTimeMillis() + durationToTrackStoppedContainers);\n      }\n    }\n  }\n{code}\nnormal heartbeat,  getContainerStatuses is called.\nSo completed container will not be put into containerStatuses beacause it is in recentlyStoppedContainers.\nSo completed container will not be sent to RM.\n{code:java}\nprotected List<ContainerStatus> getContainerStatuses() throws IOException {\n    List<ContainerStatus> containerStatuses = new ArrayList<ContainerStatus>();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId = container.getContainerId();\n      ApplicationId applicationId = containerId.getApplicationAttemptId()\n          .getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus =\n          container.cloneAndGetContainerStatus();\n      if (containerStatus.getState() == ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                + containerId + \" from NM context.\");\n          }\n          context.getContainers().remove(containerId);\n          pendingCompletedContainers.put(containerId, containerStatus);\n        } else {\n          if (!isContainerRecentlyStopped(containerId)) {\n            pendingCompletedContainers.put(containerId, containerStatus);\n          }\n        }\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(containerId);\n      } else {\n        containerStatuses.add(containerStatus);\n      }\n    }\n\n    containerStatuses.addAll(pendingCompletedContainers.values());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }\n{code}\n\n\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"created":"2017-09-19T08:14:51.708+0000","updated":"2017-09-19T08:14:51.708+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13103176/comment/16171322","id":"16171322","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"body":"in my thought,  containers in recentlyStoppedContainers can be removed from NMContext if NM heartbeat normally with RM.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"created":"2017-09-19T08:43:41.200+0000","updated":"2017-09-19T08:43:41.200+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13103176/comment/16171396","id":"16171396","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"body":"!screenshot-1.png!\ngenerally,\n1、 NM complete one container(c) and send to RM\n2、RM sent c to AM, tell AM c is completed.\n3、RM sent c to NM, tell NM c can be removed from NM.\nIf RM restart before step 3,  c will be duplicated container completed to AM.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=zsl2007","name":"zsl2007","key":"zsl2007","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"zhangshilong","active":true,"timeZone":"Asia/Shanghai"},"created":"2017-09-19T09:25:36.542+0000","updated":"2017-09-19T09:38:19.043+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/13103176/comment/16171402","id":"16171402","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=NeoMatrix","name":"NeoMatrix","key":"neomatrix","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"rangjiaheng","active":true,"timeZone":"Asia/Shanghai"},"body":"We found this problem in Spark streaming application, a long-running application, which has fixed number of containers; after NM lost, NM restarted and RM restarted, a duplicated container was allocated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=NeoMatrix","name":"NeoMatrix","key":"neomatrix","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"rangjiaheng","active":true,"timeZone":"Asia/Shanghai"},"created":"2017-09-19T09:30:52.374+0000","updated":"2017-09-19T09:32:00.380+0000"}],"maxResults":4,"total":4,"startAt":0},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/YARN-7214/votes","votes":1,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i3k847:"}}